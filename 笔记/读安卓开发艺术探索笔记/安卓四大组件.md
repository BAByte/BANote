[toc]
# 安卓四大组件
## 先说两句
四大组件我们经常用，我们也就掌握了他们的使用方法，但是他们的运行状态和工作方式，以及工作的过程作为一名初级开发者，其实都不懂这些东西，你可能会有疑问，这些东西都是谷歌工程师写死的，我会用就行了，真的有必要去学吗？其实有的，初学安卓都知道四大组件在安卓中是非常重要的，给我们的感觉就是：他们是组成一个软件的全部。那谷歌工程师为什么要设计成四大组件？为什么不是三个？不是两个？

既然这四大组件那么重要,如果去理解了，那我不就可以理解系统内部运行的机制？你在实际开发中遇到比四大组件复杂的代码真的是少之又少，所以我一直都觉得，没有看过安卓源码的安卓软件工程师，写不出好代码（不要停留在注释多就是好代码的阶段）！不接受反驳。

这里我再扯一扯题外话，为什么说注释多不代表代码好？如果一个稍微复杂项目的架构非常的好，如果你有经验，不需要注释你都能很快摸清。说到这里你就可能有点不服了，这其实是我们前面说的经验问题，如果一个稍微复杂项目架构确实好但是注释很少，你看不懂，那就是你看代码的方式不对。像安卓这么复杂的，注释还少吗？你看的懂？摸清一个项目就像摸清一个公司，你第一点要看的就是它做了什么？或者说它提供的服务是什么？一个公司的服务肯定很多，我们一般都是先从某个服务入手，摸清了它提供的服务后，你就可以猜测他们大概会有什么样的部门，摸清了大概有什么部门后，就可以开始猜测它们每个部门之间的协作和层次。到这里！你就对这个公司提供的这个服务了解的非常清楚了，那再深入就是到各个部门去了。

比如说我们用代码去实现一个拖动动画，它需要很多模块（触摸事件处理模块，绘制View模块等等）去配合，你了解了各个模块的作用后那你就开始想了解一下，当我松手的时候，View是如何平滑一段距离的，你肯定去找有关处理View移动的模块，你就会发现有个scroller能帮我们快速实现插值器，从而实现值的演变，从而控制View的惯性移动。这就好比你找到了一个部门，里面有个很牛逼的员工，这个服务的核心原来是他的工作，你发现了这个人才，那你可以用他为你创造一些价值。像sceoller就可以帮我们处理很多View的移动操作

这就是我摸清一个项目的经验。而不是一行一行代码的去看，一行一行代码去看是因为你要找出具体的实现（找出那个员工）。

---

## 四大组件是如何撑起一个软件的？
故事的开始在1991年的那个夜晚，刚从公司回来的我显得有点忧郁，我脑子里一直有 “退休” 两个字在回响着，当初毕业到创建这家食品公司再到这么多年的风风雨雨，我也年迈四十。我回想着这一生，还有什么是令我不满意的地方。兼程十几年，我也就创立了一个公司赚了点小钱。并没有给这个行业带来多大的变革。那天晚上我一人走在田径场上，突然我的想法变得疯狂起来：我想从头到尾再来一次创业，这一次是为了行业的变革。。。（改编自雷军从金山到创立小米的故事）。

我决定开一家连锁快餐店，名字我都想好了：“啃鸡鸡”。以前是做食品加工，对食品销售没有什么经验。我决定先开个门店，请两个店员（Activity），当有客人来的时候他们去做食物，然后卖给客人（除了展示页面Activity还放了很多繁重的任务）。

第二天我走到门口，发现很多人在排队，出来闯荡江湖的成就感又再一次浮现。但是一进店里，怎么没有店员？店员呢？我一边破口大骂，一边给客户道歉。两个店员这个时候冲了出来，一毛巾甩在我脸上并声说到：去你妈的，老子不干了，又要接待客人又要做菜。扭头就想走，在他扭头的那一刻，我想了很多，前台就应该招待客人，介绍我们的食物才对。果然我还是经验不足，怎么能让他们做菜呢?

经过一番的思考，我决定请多两个厨师（service），负责在后台做菜（这个时候厨师和客人是没有任何的接触，后台服务不被用户感知），但是我还发现一个问题，店里都是油炸食品并且保存在一个合适的环境，食品可以几个小时内保持口味和刚刚出炉的一样。那厨师这个时候不是闲了下来？嗯，作为一个出色的老板，必须要懂得如何压榨员工！！

我是这样安排的，当需要的时候，前台店员在接待客人点餐，厨师把食物打包好，前台就把食物给客人。这种模式（Service与Activity绑定实现直接交互）实施了一个星期后，客户都是好评连连，夸我们店效率高，我真的真的是个商业奇才！

随着我们的客人越来越多，日销售量越来越大。这一天我坐在店中看着人流量如同高数公路一样大的景况，不得又感叹一次，再次创业是对的。这个时候厨师跑了过来和我说：老板，我们每天对于食品原料的需求太大了。这一消息如雷贯耳，对啊，我们食品那么多：炸鸡鸡，炸薯棒，喊堡堡等等。店里对于原料的管理确实很烂。但是！作为一个食品加工企业的老板，这方面我可谓是业界顶尖。我请了几个采购（BroadcastReceiver），专门负责向食品原料公司采购（向其他组件或者进程进行通信），我还建立了一个原料仓库（ContentProvider）。这些采购员工去采购（进行通信），其他原料公司把原料送到我们的仓库（内容提供器的指定数据可以被外界更改的），厨师去仓库拿原料烹饪（去内容提供器拿数据）。

不出两年，我开了20家连锁店，我的商业模式也把这个行业进行了一次大的变革，我决定再为餐饮行业做点事情，我再次加强了对员工的管理：前台店员有服务员和售货员之分，如果一个客户是老熟客，如果有个店员能和他打好关系，搞清楚他的口味，让他每次一来就有亲切感，相信我们的客户满意度会提升，所以当这些老客户一来的时候，了解他的店员就要主动的为他服务啦!(显示启动Activity)。

还要怎样提升用户满意度呢？当客户点餐后坐下，服务员应该马上赶到将客户所坐下的桌子清理干净，如果客户是一个年轻男性当然要一个好看的女性服务员去收拾！如果客户是美女，好看的男性服务员就要马上到，性是社会发展的动力嘛（这里要求客户坐下后还没有叫服务员收拾，服务员要明白客户的意思，也没有指定要那个服务员，属于隐式调用）。

那厨师呢？我们的食物，烹饪难度不大，所以对于厨师来说，没客人的时候要工作，有客人的时候需要帮忙还是要帮忙，所以让厨师完全停止工作就要两个任务都完成，食物准备充足就可以考虑休息（stopService），如果客人也不多就可以考虑不帮前台打包了（unBinderService）。


一下子开了20家连锁店，我上次去旧晶三的那家连锁店微服私访的时候，车都被偷了。我也发现连锁店一多，管理起来不够方便，我决定给每家店安排一个经理（BroadcastReceiver），负责给我汇报工作，还要把我的意思传达下去（观察者模式）。这样我发现采购人员和经理的工作性质是不一样的，采购人员是和外界通信的，你上班别的公司可能是下班的，你下班，别的公司可能是上班的，所以我要求采购人员是24小时待命的，一有原料公司联系，必须马上和他们协商的。（这就是广播的静态注册，不只是软件使用的时候才工作）。这样一来，对于仓库管理（ContentProvider）也是需要24小时轮班了（所以说内容提供器只能静态注册，没有停止的概念）。

但是对于经理来说，我又不能在别人下班和女朋友约会的时候打个电话去审查吧？所以我希望是经理上班的时候向我汇报（这就是广播的动态注册，软件启动的时候才工作）。

安卓四大组件就是这样撑起一个软件的，撑起了我再次创业的梦想（啃鸡鸡，原型就是kfc和m计）


## Activity的工作流程
和书上一样，记录学习Activity启动到工作的大致流程。我只是写了一半，因为书上就写了一堆代码跳转跳转跳转，我实在是看不出有什么学习必要。你大可不必看这个。
从startActivity()方法开始，你可以看到这个方法有很多重载，但是最后都是跑到下面这个方法中执行
~~~java
public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,
            @Nullable Bundle options) {
        if (mParent == null) {
            options = transferSpringboardActivityOptions(options);
            Instrumentation.ActivityResult ar =
                mInstrumentation.execStartActivity(
                    this, mMainThread.getApplicationThread(), mToken, this,
                    intent, requestCode, options);
          ...
        } else {
            if (options != null) {
                mParent.startActivityFromChild(this, intent, requestCode, options);
            } else {
                // Note we want to go through this method for compatibility with
                // existing applications that may have overridden it.
                mParent.startActivityFromChild(this, intent, requestCode);
            }
        }
    }
~~~

mParent是什么？他代表AcitivityGroup,这个东西和他的名字一样：用来在一个界面嵌入多个Activity，显然现有Fragment，这个东西自然也被抛弃了。那他应该是默认就为null了，接下来就到execStartActivity()了，这个方法也是属于源码我也没下载，启动Activity的真正实现由ActivityManagerNative.getDefault()的startActivity实现，getDefault()获取到的是ActivityManagerService，这个东西继承自ActvitiyManagerNative，而ActvitiyManagerNative是一个Binder，一看到getDefault的时候应该就能想到是不是个单例了，确实是这样的。创建Activity的具体实现其实是在由系统的服务AMS去完成的，他是如何去处理Activity的添加过程？

AMS跑着跑着会先到ActivityStackSupervisor，然后跑到ActivityStack的resumeTopActivityLocked方法中，先说说这两个东西：ActivityStack是Activity的返回栈，ActivityStackSupervisor是栈的管理员。到目前的工作是把Activity的栈处理一下（关于返回栈的，我们就先不管），我们的Activity的生命周期的各种回调还没看到呢，代码继续跑，最后跑到ActivityStackSupervisor的realStartActivtyLocked()方法，这个方法中用到一个Binder，这个Binder的具体实现是ApplicationThread，这个东西的父类是ApplicationThreadNative，对应的AIDL文件是IApplicationThread，这个Aidl文件包含了大量的Activity的启动，停止的方法，这意味着启动Activiy的代码是ApplictionThread做的，这个类里面有什么呢？

内部有一个Handler类，这个类负责处理Activity和Service的启动，至于为什么要用handler,应该还是为了切换线程，ApplictionThread会sendMessages（这里是去启动Activity），handler接到后做出相应的反应，这里是调用performLaunchActivity()。

performLaunchActivity()工作流程
+ 获取Activity的信息
+ 创建Activity对象
+ 创建Appliction对象(如果存在就不创建，app的Application就是这里来的)
+ 创建ContextImpl对象给Activity（其实就是创建Activity内部的context）
+ 调用Activity的Attach()将Window和contextImpl和Activity绑定
+ 调用Activity的onCreat()

Activity就启动完了。其实没什么好了解的，就是在一堆方法里面瞎逛。

## Service的工作流程(和Activity大致一样，略)

## 

