[TOC]

# 设计原则

## 先说两句

在一年多以前我就学了设计模式，但是当时只是单纯的看了实现以及六大原则，在实际开发中其实很少使用，正好聪聪买了本《安卓源码设计模式实践》，里面是基于安卓的源码去分析设计模式，我觉得挺不错的。在开始前还是要说一下，设计原则不是硬性规定，在实际中你只能尽可能的去遵守，想要做到百分百遵守是不太可能的，所以在有时候你觉得某些设计违背了设计某个设计原则，你大可不必过于郁闷。

## 单一职责

按照以往的习惯，我们先看名字，英语：Single Responsibility Principle，中文：单一职责。他面向的维度，嗯，又或者说是范围是有区别的，比如是模块级别的单一职责，类级别，又或者是方法级别的，当你从不同级别去分析的时候其实可以让你更好的理解这个原则。

我自己实现过一个ImageLoad(其实是看了《安卓开发艺术探索》后写的)。书上的结构我觉得是可以优化的，一个图片加载框架需要有缓存，缓存(磁盘缓存，内存缓存，三级缓存(前面两者之和))，图片压缩，图片资源加载(网络下载还是本机获取)。在书上呢，他是先从内存获取，内存没有就从磁盘获取，磁盘没有就网络下载，而且全在一个ImageLoad类里面。当然书上只是简单的教我们怎么样去实现一个ImageLoad而已，那假设我们需要去优化，我们怎么写？

![image](https://ws1.sinaimg.cn/large/006ev5f6gy1fvo44579rqj30bu0r2abh.jpg)



我们看看包，每个包都会有一个接口或者抽象类作为限定子类的框架，我们直接说抽像，我分成了缓存（image_cache），压缩解析（image_compress），加载操作类(image_load)，加载器(image_load_way)。这里的目的就是为了单一职责，每个抽象只负责做一件事。这样说应该够清楚了吧？可以看看下面的代码。



**只负责缓存的抽象代码如下**

实现该接口的类只负责处理缓存，单一职责就体现出来了

~~~java
/**
 * Created by BA on 2018/7/28 0028.
 * 缓存公用接口
 *
 * @param <T> the type parameter ，媒体类型
 * @param <J> the type parameter，缓存具体实现类型
 */
public interface CacheInterface <T,J>{
    /**
     * Get t.
     *
     * @param uri  the uri
     * @param reqW the req w
     * @param reqH the req h
     * @return the t
     */
    public T get(String uri,int reqW,int reqH);

    /**
     * Put.
     *
     * @param uri the uri
     * @param t   the t
     */
    public void put(String uri,T t);

    /**
     * Init.
     *
     * @param context   the context
     * @param cacheSize the cache size
     */
    public  void init(Context context, int cacheSize);

    /**
     * Gets size.
     *
     * @return the size
     */
    public Object getSize();

    /**
     * Gets .
     *
     * @return the
     */
    public J getImpl();

    /**
     * Release.
     */
    public void release();

    /**
     * Clear.
     */
    public void clear();

    /**
     * Remove.
     *
     * @param uri the uri
     */
    public void remove(String uri);
}
~~~

---

**负责压缩和解析图片的抽象如下**

只负责解析和压缩图片的类，其实这里由于会从不同来源，你从下面都可以看到，这里应该用泛型的（这不是这里的重点）。

~~~java
public abstract class ImageCompressInterface {
    private static final String TAG = "ImageCompressInterface";
    public abstract Bitmap compress(Resources res, int id, int reqW, int reqH);
    public abstract Bitmap compress(FileDescriptor fd, int reqW, int reqH);
    public abstract Bitmap compress(Bitmap bitmap,int reqW, int reqH);
    public abstract Bitmap compress(String path, int reqW, int reqH);

    /**
     * bitmap转换成byte数组
     *
     * @param bitmap
     * @param needRecycle
     * @return
     */
    public static byte[] bitmapToByteArray(Bitmap bitmap, boolean needRecycle) {
       	...
        return result;
    }
}
~~~

---

**加载器抽象**

这个主要是处理从不同来源加载图片的抽象

~~~java
/**
 * Created by BA on 2018/7/28 0028.图片加载时可能是从网上下载
 */

public interface LoadFromAnywayInf {
    public static final int IO_BUFFER_SIZE = 8 * 1024;
    public Bitmap load(String uri,int reW,int reH);
}
~~~

---

**处理类的伪代码**

只给出了初始化缓存的伪代码

~~~java
class ImageLoad{
    CacheInterface <T,J> cache;
    public void init(CacheInterface <T,J> cache){
        this.cache=cache;
    }
    
    public Bitmap load(){
        ...
        return cache.load();
    }
}
~~~

## 小结

假设我只需要内存缓存，那就实现缓存抽象接口，在init时传入即可，假设我需要磁盘和内存缓存，那就实现缓存接口，定义一个两个缓存都有的缓存类，使用时也是在init传入，这样一来，即使后面有三级缓存，四级缓存，那原来的类都不用改，只需要加一个实现缓存接口的类，使用时在处理了的init方法传入即可。

压缩的格式，压缩算法不同，那没关系，实现压缩接口自己写一个类，使用时也动态注入，。这就是单一职责的好处，各司其职，互不干扰。维护起来也是特别的简单，缓存出问题直接找缓存相关类，压缩出问题找处理压缩的类。

其实具体怎样去区分是不是单一职责需要根据实际情况，那你说加载图片是一个功能，在整个项目里面来说他就是只做加载图片的功能，他也是单一职责，完全没有问题的，所以说遵循单一职责原则，第一步就是拆！！！把代码拆开，细分！！

## 