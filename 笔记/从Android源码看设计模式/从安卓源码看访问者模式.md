[TOC]

# 从安卓源码看访问者模式

访问者模式最大的特点我觉得就两个：

+ 假设你的函数参数是对象，而该函数由于对象不一样执行的代码也不一样，一般会选择Runnable，又或者是选择重载函数。这样可以减少if..else..的结构
+ 你不想你的数据被结构所污染，什么意思呢？数据就是数据，他不需要去管别人怎么去访问，操作，存储，一般都是加个中介者来处理，就比如迭代器模式

## 从注解说起

注解的原理和使用的非常简单，但是他的设计呢?其实也简单，一开始我是觉得他是使用策略模式，为什么这么说？因为需要根据注解种类来处理注解吧？那策略模式不就是选择不同的方式？嗯。。不对，策略模式针对的是算法等这一类的东西，那工厂呢?选择不同的对像去处理这些注解。嗯这里针对的东西不一样，他是根据不同的注解去选择对象，生成对象。我们这里的就是怎么去处理不同注解。一种是创建，一种是行为。确实不一样

但是我们看看：

注解是固定的吧？他代表了解释某些字段，函数，类是干嘛的，那怎么去处理注解是不是处理注解的对象去决定的？这样一来注解就是注解，他没有别的意思，爱怎么处理是处理类该做的，对吧？这是不是就防止污染了？

我们写写注解的时候不一定是针对某个注解，你可以随便选择注解，这意味我们处理的不是注解，而是一个被注解的模块，如果你自己写过注解就知道我在说什么了。

那不就是和访问者一样？访问者拿到被访问对象后他爱怎么访问就怎么访问

~~~java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.CLASS)
@interface Test{
    String value();
}
~~~

我们平时会像上面一样定义一个我们自定义的注解，然后写一个注解反射类

当

