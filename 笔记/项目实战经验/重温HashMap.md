[TOC]

# 重温HashMap

## 先说两句

​	在以前学习java的时候，对集合方面的知识可是掌握的很好，无奈很多东西都无法躲过岁月这把杀猪刀啊，就来回顾一下HashMap，这是一种专门存键值对key-values的集合，而且要求是，不能重复存储同一个Key！！不能重复！！！值肯定能重复啊

---

## 必备知识

​	先了解什么叫Hash，英文原意叫哈希函数，什么鬼？？？哈希函数就是一个固定的计算函数，你传入一个数据(不管这个数据长度啊，值是多少)，得出的结果一定是一个固定长度的值。这个值就叫做hash值。

​	这个值最大的特点就是，数据内容要是改变了，这个值也会改变，最常用的地方就是MD5校验。这里就要讲讲以前的经历了，这个MD5校验特别的有意思，我以前一值不明白有什么卵用，尤其是在刷机的时候，有时候开了刷机包对MD5校验，就一直出错，那时候网络又慢哦，将刷机包从电脑拉到手机也慢，而且一般刷机之前要双清，XXX。一开始并不知道什么鬼MD5校验失败，不能刷入，我以为刷机包有问题，就一直重新下载刷机包，刷个机搞了一天，后来知道，关闭MD5校验就好了。

这个MD5和hash值有什么关系？MD5校验，其实校验的就是hash值，刷机包里存了一个MD5，你在进行MD5校验的时候，会根据当前刷机包里面的数据重新算出Hash值，然后和刷机包里面存的MD5进行比较，如果不相等。说明这个刷机包被更改过，有可能被加入了木马啊什么的，就是为了安全啊。最坑爹的地方来了，我自己上传的刷机包，自己下载刷也会校验不成功，后来才知道，可能是在多线程下载时刷机包被改了点数据，但是有时根本不影响的。

java中的普通的hash值一般是存储的物理地址

---

## HashMap不允许重复存储同一个相同数据的原理

​	就是通过Hash函数来计算出hash值，然后比较嘛，你就很好奇了，为什么？不是有equals()方法吗？说是这样说，你要知道默认的equals()方法是默认比两个数据是不是同一个对象的引用而已。比如两个Student实例，我要判断是不是都是北京的，用默认的equals()肯定是不行的啦，所以你要复写equlas方法，进行深一步的判断，判断对象里面的 ”地区“ 字段是否都是北京。就可以区别两个不同的对象啦！！

​	问题又来了，那我直接复写equals()方法不就解决了吗？哈希函数是不是就没有存在的必要了呢？事实上不是的，哈希值相当于一个人的身份证号码，equals()比较的是这个人的身高体重，外貌。你想想，集合中有1000个人，你准备再加一个人，你是直接先比身份证号码好，还是比较这个人和里面的1000个人的身高，体重，外貌好？傻子都知道效率最高的是比较身份证。

​	又有问题了，那我直接写hash函数不就好了，我写个屁equals()？这也不对哦！如果你拿到的两份身份证号，要你判断是不是同一个人，你能直接就根据身份证号相等就判断是同一个人吗？绝对是不行的，要是其中有一个人搞错了自己的身份证号，搞错后的号码恰好和你另一份一样呢？

如果给你两张人像，并且很明确的告诉你，就是同一个人，要你判断身份证号是不是一致，那你都不用想，都是同一个人，身份证号肯定就只有一个啊！！

所以就hash值就有原则了

> 1、如果两个对象相同，那么它们的hashCode值一定要相同；
>
> 2、如果两个对象的hashCode相同，它们并不一定相同

---

## 代码实例(我copy网上一个感觉比较好的例子)

+ 假设需要记录学生的成绩，每个学生本身有姓名，年龄，性别几个属性，把姓名、性别、年龄都一样的当成是同一个人（虽然不严谨）。学生对象自然就是key，成绩是Value，存储时比较的是Key

~~~java
class Student {
    String name;
    int age;
    //true表示男，false表示女
    boolean sex;

  //来说说为什么要乘一个数字啊，说白了就是为了减少重复的hashCode，这样可以最大的避免错误
  //前面说的，根据数据地址来计算的hash值，要是两个不同对象，
  //一个对象里面的两个字段的地址分别是4，和6
  //另一个分别是2，12
  //这两个不同的对象的hash值是不是都是24？所以就有问题啦！！！！
  //奇奇和偶偶出现问题的概率是一样的，奇偶出现问题的概率是最大的
  //意思是都会有问题，那就把发生问题的概率尽可能的降低，说白了就是加上一点层级啊，递进啊的关系，反正你就按照下面的写法就好了
    @Override
    public int hashCode() {
        int result = 17;
        result = 37*result+name.hashCode();
        result = 37*result+age;
        result = 37*result+(sex ? 0 : 1);
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        return obj instanceof Student &&
                this.name.equals(((Student)obj).name) &&
                this.age ==  ((Student)obj).age &&
                this.sex == ((Student)obj).sex;
    }
}
~~~



## 小总结

+ 一般复写equals()方法就必须复写hashCode()方法，原因看下一个点
+ 使用Set类型的集合时，自动会先调用hashCode()方法，如果hashCode相同再调用equals()，说白了就是为了提高效率
+ 我们一般手动调用的都是equals()方法，hashCode()方法一般是使用Set集合时自动调用
+ 使用Set集合时比较的其实是Key，因为存储时说的不能重复说的就是Key不能重复

