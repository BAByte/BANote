[TOC]



# 6.深入理解常用类

前面我们虽然讲到了程序入口：ActivityThread:main（），但是为了后面能更好的去理解，我们先学习一些常见的类和工具。

## 智能指针

在java里面，有一套完整的垃圾回收机制，所以java开发人员并不用担心如何去释放对象，等着jvm去回收。但是c++可没这套垃圾回收机制，Google工程师为了方便，设计了一套智能指针。我们就来看看是怎么个智能法！

## 栈引用和堆引用

来源：

> <https://blog.csdn.net/xuqiqiang1993/article/details/68923160>

在c++里面，引用分为栈引用和堆引用，从作用域上来看，可以将对象分为全局对象、局部对象、静态全局对象和静态局部对象。

一般来说，局部变量的有效作用域从它的定义点开始，到和定义变量之前最邻近的开括号配对的第一个闭括号，也就是说，作用域由变量所在的最近一对{}括号确定。

~~~java
void testScope() {
       SheepbigSheep; //局部对象
       {
              SheepsmallSheep; // 局部对象
       } // smallSheep的作用域结束
} // bigSheep的作用域结束
~~~

从内存分配空间来看，可将对象分为栈对象和堆对象。栈对象在作用域结束后会自动释放，而堆对象需要手动显示的释放。

~~~java

void testMemoryMap() {
       Sheepsheep; // 栈对象，testMemoryMap调用结束后自动释放
       Sheep*pSheep; // 堆对象，需要手动释放
       deletepSheep; // 释放pSheep指向的对象
       pSheep= 0; //将pSheep指向NULL，防止造成野指针

}
~~~

所以说，在开发人员使用的时候，就需要手动去释放堆对象，这是多么大的一项工程啊！！稍有遗漏就会出一些奇奇怪怪的问题，所以谷歌工程师设计了一套智能指针！

## 初见sp

我们看看下面的代码

```java
//frameworks/av/media/mediaserver/main_mediaserver.cpp
using namespace android;

//先不管这个类是干嘛的，我们在里面看到有个sp！！！
int main(int argc __unused, char **argv __unused)
{
    signal(SIGPIPE, SIG_IGN);

    //就是这里，这个sp就像一个容器一样，直接把ProcessState传进去了！
    sp<ProcessState> proc(ProcessState::self());
    sp<IServiceManager> sm(defaultServiceManager());
    ALOGI("ServiceManager: %p", sm.get());
    InitializeIcuOrDie();
    MediaPlayerService::instantiate();
    ResourceManagerService::instantiate();
    registerExtensions();
    ProcessState::self()->startThreadPool();
    IPCThreadState::self()->joinThreadPool();
}
```

这里就很奇怪了，要用ProcessState实例，直接new出来直接用不就好了，为什么要放在sp里面。假设我们直接new，那么就会产生一个堆引用，在使用完后就要去清除他。那把他放到sp里面到底有什么作用呢？

## RefBase

上面说到的sp就和这个RefBase有关，在java里面，回收机制是根据引用计数来判断是否要回收这个对象的，栈对象在生命周期，即作用域结束后自动释放，所以我们这里讨论的是堆对象的引用，也就是指针对象。

图1-2是指针引用时，利用引用数管理实际对象释放的原理图。

![image](https://img-blog.csdn.net/20170331112844610?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHVxaXFpYW5nMTk5Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

由图片可以看到，在引用一次堆对象就会使得引用数加1，引用结束就会减一，然后根据引用数来回收对象，在jvm里面是当内存不够了或者手动控制等情况下，才会引发系统的gc操作去根据对象引用计数来决定是否释放对象。但是在谷歌的这一套智能指针中，并没有去判断内存是否足够，而是用完就回收，主要解决了需要手动回收对象的难题。

但是有个问题，我们如何去统计引用数？你不能要求每个类都写一套统计引用方法吧？那就继承吧！！安卓定义了一个基类：RefBase。他是安卓世界里面很多常用c++对象的基类。类似于java的所有对象都是object一样！

我们只需要在这个RefBase里面实现统计不就好了？是的！！我们看看一套统引用计数和自动释放对象的功能的代码结构：

![image](https://img-blog.csdn.net/20170331112907439?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHVxaXFpYW5nMTk5Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

+ RefBase

  ~~~java
  有个内部类weakref_type，这个内部类其实是一个抽象类，他定义了很多操作引用计数的方法
  ~~~

+ Weakref_impl

  ~~~java
  这个是RefBase的内部类，继承自weakref_type，实现了weakref_type定义的方法
  ~~~

这里我们先打住。所以说实现引用计数方法，释放对象的方法是由weakref_impl实现的，只要你写的c++类去继承RefBase就有这些功能了！但是！！引用分为强引用和弱引用，你直接new出来，RefBase怎么知道你需要强引用还是弱引用？而且，RefBase的weakref_impl只是给了两个值：弱引用计数，强引用计数，给了几个方法去加加减减这个两个数而已。他并不知道你什么时候引用对象，也并不知道你什么时候加强引用计数还是弱引用计数！

所以这里总结一些就是：RefBase只是实现了计数方法，但是没有实现统计过程，我们需要在引用对象的时候去调用RefBase的方法去给强引用（弱引用）计数。但是不可能我引用一下就去调用对应的统计方法给计数加加一下吧？所以设计了两个模板类：sp和wp让他们去统计！！！

+ sp（强引用类型）

  ~~~java
  他是一个模板类，里面重载了很多运算符，有个字段为泛型，其实就是你的具体对象类型
  ~~~

+ wp（弱引用类型）

  ~~~java
  他是一个模板类，里面重载了很多运算符，有个字段为泛型，其实就是你的具体对象类型
  ~~~

我们看sp的代码

~~~java
//aosp/system/core/include/utils/StrongPointer.h
// ---------------------------------------------------------------------------
namespace android {

template<typename T> class wp;

// ---------------------------------------------------------------------------


// ---------------------------------------------------------------------------

template<typename T>
class sp {
public:
    inline sp() : m_ptr(0) { }

    sp(T* other);
    sp(const sp<T>& other);
    sp(sp<T>&& other);
    template<typename U> sp(U* other);
    template<typename U> sp(const sp<U>& other);
    template<typename U> sp(sp<U>&& other);

    ~sp();

    // Assignment

    sp& operator = (T* other);
    sp& operator = (const sp<T>& other);
    sp& operator = (sp<T>&& other);

    template<typename U> sp& operator = (const sp<U>& other);
    template<typename U> sp& operator = (sp<U>&& other);
    template<typename U> sp& operator = (U* other);

    //! Special optimization for use by ProcessState (and nobody else).
    void force_set(T* other);

    // Reset

    void clear();

    // Accessors,看这里！这里很重要，他重载了运算符，m_ptr就是具体实现，构造函数传进来的是什么就是什么
    //重载运算符的好处是，用sp指针使用这些运算符时其实就是使用具体的实现去使用这些运算符，这样一来就兼容了
    //所有类型的对象

    inline  T&      operator* () const  { return *m_ptr; }
    inline  T*      operator-> () const { return m_ptr;  }
    inline  T*      get() const         { return m_ptr; }

    // Operators

    COMPARE(==)
    COMPARE(!=)
    COMPARE(>)
    COMPARE(<)
    COMPARE(<=)
    COMPARE(>=)

private:    
    template<typename Y> friend class sp;
    template<typename Y> friend class wp;
    void set_pointer(T* ptr);
    T* m_ptr;
};

#undef COMPARE

// ---------------------------------------------------------------------------
// No user serviceable parts below here.

template<typename T>
sp<T>::sp(T* other)
        : m_ptr(other) {
    if (other)
        other->incStrong(this);
}

template<typename T>
sp<T>::sp(const sp<T>& other)
        : m_ptr(other.m_ptr) {
    if (m_ptr)
        m_ptr->incStrong(this);
}

template<typename T>
sp<T>::sp(sp<T>&& other)
        : m_ptr(other.m_ptr) {
    other.m_ptr = nullptr;
}

template<typename T> template<typename U>
sp<T>::sp(U* other)
        : m_ptr(other) {
    if (other)
        ((T*) other)->incStrong(this);
}

template<typename T> template<typename U>
sp<T>::sp(const sp<U>& other)
        : m_ptr(other.m_ptr) {
    if (m_ptr)
        m_ptr->incStrong(this);
}

template<typename T> template<typename U>
sp<T>::sp(sp<U>&& other)
        : m_ptr(other.m_ptr) {
    other.m_ptr = nullptr;
}

//看到析构函数，当sp出了作用域被回收的时候，具体实现的引用计数也会减一
template<typename T>
sp<T>::~sp() {
    if (m_ptr)
        m_ptr->decStrong(this);
}
    
 //当引用时，引用会增加，原来的具体实现引用计数减少，引用已经发生了变化了
template<typename T>
sp<T>& sp<T>::operator =(const sp<T>& other) {
    T* otherPtr(other.m_ptr);
    if (otherPtr)
        otherPtr->incStrong(this);
    if (m_ptr)
        m_ptr->decStrong(this);
    m_ptr = otherPtr;
    return *this;
}

template<typename T>
sp<T>& sp<T>::operator =(sp<T>&& other) {
    if (m_ptr)
        m_ptr->decStrong(this);
    m_ptr = other.m_ptr;
    other.m_ptr = nullptr;
    return *this;
}

template<typename T>
sp<T>& sp<T>::operator =(T* other) {
    if (other)
        other->incStrong(this);
    if (m_ptr)
        m_ptr->decStrong(this);
    m_ptr = other;
    return *this;
}

template<typename T> template<typename U>
sp<T>& sp<T>::operator =(const sp<U>& other) {
    T* otherPtr(other.m_ptr);
    if (otherPtr)
        otherPtr->incStrong(this);
    if (m_ptr)
        m_ptr->decStrong(this);
    m_ptr = otherPtr;
    return *this;
}

template<typename T> template<typename U>
sp<T>& sp<T>::operator =(sp<U>&& other) {
    if (m_ptr)
        m_ptr->decStrong(this);
    m_ptr = other.m_ptr;
    other.m_ptr = nullptr;
    return *this;
}

template<typename T> template<typename U>
sp<T>& sp<T>::operator =(U* other) {
    if (other)
        ((T*) other)->incStrong(this);
    if (m_ptr)
        m_ptr->decStrong(this);
    m_ptr = other;
    return *this;
}

template<typename T>
void sp<T>::force_set(T* other) {
    other->forceIncStrong(this);
    m_ptr = other;
}

template<typename T>
void sp<T>::clear() {
    if (m_ptr) {
        m_ptr->decStrong(this);
        m_ptr = 0;
    }
}

template<typename T>
void sp<T>::set_pointer(T* ptr) {
    m_ptr = ptr;
}

}; // namespace android

// ---------------------------------------------------------------------------

#endif // ANDROID_STRONG_POINTER_H
~~~

可以看到并没有什么难点：我们模拟一下：

~~~java

class Sheep: public RefBase { //定义Sheep从RefBase派生
public:
       Sheep(): RefBase() { }// 可显示调用RefBase的构造，也可以不用
       virtual~Sheep() { }// 最好声明为virtual，以便从Sheep派生
};


void testSheep() {
       Sheep*pSheep = new Sheep(); // new一个Sheep对象，这个是一个堆对象
       { // 限定sp的作用域
              sp<Sheep>spSheep(pSheep); // spSheep是一个栈对象
              {// 限定wp的作用域
                     wp<Sheep>wpSheep(pSheep);
              }//调用wp的析构函数
           
           	  {
           		sp<Sheep> spSheep2=spSheep; //将引用赋给另一个sp
              }
           
       } // 调用sp的析构函数，实际对象pSheep已释放，若再使用pSheep将会出错
~~~

那一开始应该走他父类的构造函数

~~~java
RefBase::RefBase()
    :mRefs(new weakref_impl(this)) // 真正管理引用计数的实现
{}
weakref_impl(RefBase* base)
    :mStrong(INITIAL_STRONG_VALUE) // 1<<28（268435456）强引用默认值
    ,mWeak(0)
    ,mBase(base) // mBase指向实际对象
    ,mFlags(0) // 这个标识很重要，指定是强应用控制还是弱引用控制
{}

~~~

注意！这时候我们new出来的pSheep对象由于经过了父类的构造函数，现在内部是有个对象为weakref_impl,这个对象保存了pSheep的指针base，base的用处：当计数为0时用来调用析构函数。

请注意这里的mFlags，默认值为0，可通过修改这个标志来设置是强引用控制，还是弱引用控制，代码如下：

~~~java
 enum {
       OBJECT_LIFETIME_STRONG  = 0x0000,
       OBJECT_LIFETIME_WEAK    = 0x0001,
       OBJECT_LIFETIME_MASK    = 0x0001
    };
~~~

mFlags默认为0，即OBJECT_LIFETIME_STRONG，强引用控制。设置为OBJECT_LIFETIME_WEAK时，为弱引用控制。可以通过extendObjectLifetime函数修改，代码如下：

~~~java
void RefBase::extendObjectLifetime(int32_t mode)
{
   android_atomic_or(mode, &mRefs->mFlags);
}
~~~

说明引用是可以由弱变强的！走完weakref_impl的构造函数时。引用值都是为1的，

~~~java
void testSheep() {
       Sheep*pSheep = new Sheep(); // new一个Sheep对象，这个是一个堆对象
       { // 限定sp的作用域,代码现在走到这里！
              sp<Sheep>spSheep(pSheep); // spSheep是一个栈对象
              {// 限定wp的作用域
                     wp<Sheep>wpSheep(pSheep);
              }//调用wp的析构函数
           
           	  {
           		sp<Sheep> spSheep2=spSheep; //将引用赋给另一个sp
              }
           
       } // 调用sp的析构函数，实际对象pSheep已释放，若再使用pSheep将会出错
~~~

接下来我们看看sp的构造函数

~~~java

template<typename T>
sp<T>::sp(T* other)
        :m_ptr(other) {
    if(other)
       other->incStrong(this);
}
~~~

调用了我们具体实现：pSheep的incStrong方法，这个方法在基类：

~~~java
void RefBase::incStrong(const void* id) const
{
   weakref_impl* const refs = mRefs;
   refs->incWeak(id); // 调用incWeak函数
   
   refs->addStrongRef(id); // 由DEBUG_REFS控制，release版本什么也不做
    constint32_t c = android_atomic_inc(&refs->mStrong); // 强引用数+1，c为旧值，假设是第一次，c为0
   ALOG_ASSERT(c > 0, "incStrong() called on %p after last strongref", refs);
    if (c !=INITIAL_STRONG_VALUE)  { //判断是否是第一次引用
       return;
    }
    // 第一次引用，refs->mStrong为1<<28 +1 (268435457）
    int32_t old = refs->mStrong.fetch_sub(INITIAL_STRONG_VALUE,
            std::memory_order_relaxed);
    // A decStrong() must still happen after us.
    ALOG_ASSERT(old > INITIAL_STRONG_VALUE, "0x%x too small", old);
    refs->mBase->onFirstRef();
}
~~~

可以看到在增加强引用计数的地方先增加了弱引用计数

~~~java
void RefBase::weakref_type::incWeak(const void*id)
{
   weakref_impl* const impl = static_cast<weakref_impl*>(this);
   impl->addWeakRef(id); // 由DEBUG_REFS控制，release版本什么也不做
    constint32_t c __unused = android_atomic_inc(&impl->mWeak); //弱引用数+1
   ALOG_ASSERT(c >= 0, "incWeak called on %p after last weakref", this);
}
~~~



然后他是调用了原子函数去给强引用计数加1，所以现在强引用计数为2，弱引用为1。



~~~java
void testSheep() {
       Sheep*pSheep = new Sheep(); // new一个Sheep对象，这个是一个堆对象
       { // 限定sp的作用域
              sp<Sheep>spSheep(pSheep); // spSheep是一个栈对象
              {// 限定wp的作用域 代码现在走到这里！
                     wp<Sheep>wpSheep(pSheep);
              }//调用wp的析构函数
           
           	  {
           		sp<Sheep> spSheep2=spSheep; //将引用赋给另一个sp
              }
           
       } // 调用sp的析构函数，实际对象pSheep已释放，若再使用pSheep将会出错
~~~

那就看看弱引用的构造函数

~~~java

template<typename T>
wp<T>::wp(T* other)
    :m_ptr(other)
{
    //可以看到，弱引用和强引用的还是有差别的，弱引用是把实例的weakref_impl给保存下来！！这样就不用经过基类
    //强引用是直接使用具体实现去调用具体的统计计数方法，要经过基类
    //因为基类是没有写减少弱引用的方法的，所以弱引用这个概念可能是后面加的
    if(other) m_refs = other->createWeak(this);
}
~~~

看看基类的createWeak

~~~java
RefBase::weakref_type* RefBase::createWeak(constvoid* id) const
{
   mRefs->incWeak(id); // incWeak函数前面分析过，最终的结果就是弱引用数+1
    return mRefs;
}
~~~

所以现在是强引用数为2，弱引用为2,

~~~java
void testSheep() {
       Sheep*pSheep = new Sheep(); // new一个Sheep对象，这个是一个堆对象
       { // 限定sp的作用域
              sp<Sheep>spSheep(pSheep); // spSheep是一个栈对象
              {// 限定wp的作用域 
                     wp<Sheep>wpSheep(pSheep);
              }//调用wp的析构函数   //代码现在走到这里
           
           	  {
              
           		sp<Sheep> spSheep2=spSheep; //将引用赋给另一个sp
              }
           
       } // 调用sp的析构函数，实际对象pSheep已释放，若再使用pSheep将会出错
~~~

调用wp的析构函数

~~~java

template<typename T>
wp<T>::~wp()
{
    if(m_ptr) 
        m_refs->decWeak(this); // 调用decWeak函数
}
~~~

要看weakref_impl的decWeak()方法

~~~java

void RefBase::weakref_type::decWeak(const void*id)
{
   weakref_impl* const impl = static_cast<weakref_impl*>(this);
   impl->removeWeakRef(id);
    constint32_t c = android_atomic_dec(&impl->mWeak); // 弱引用数-1，c为旧值
   ALOG_ASSERT(c >= 1, "decWeak called on %p too many times",this);
    if (c !=1) return; //c为旧值，判断是否是最后一次弱引用
    // 记得前面我们说的，mFlags为0，我们并没有改变它
    if((impl->mFlags&OBJECT_LIFETIME_WEAK) ==
            OBJECT_LIFETIME_STRONG){
        // 强引用控制，是否释放实际对象是根据强引用数
        if(impl->mStrong == INITIAL_STRONG_VALUE) {
           delete impl->mBase; // 根本就没有强引用引用实际对象，释放实际对象
        }else {
           delete impl; // 释放mRefs
        }
    } else {
       impl->mBase->onLastWeakRef(id); //最后一次弱引用时调用
        if((impl->mFlags&OBJECT_LIFETIME_MASK) ==
                        OBJECT_LIFETIME_WEAK) {
           delete impl->mBase; //弱引用控制，释放实际对象
        }
    }
} 

~~~

现在强引用为2，弱引用为1

~~~java
void testSheep() {
       Sheep*pSheep = new Sheep(); // new一个Sheep对象，这个是一个堆对象
       { // 限定sp的作用域
              sp<Sheep>spSheep(pSheep); // spSheep是一个栈对象
              {// 限定wp的作用域 
                     wp<Sheep>wpSheep(pSheep);
              }//调用wp的析构函数   
           
           	  {
              	//代码现在走到这里
           		sp<Sheep> spSheep2=spSheep; //将引用赋给另一个sp
              }
           
       } // 调用sp的析构函数，实际对象pSheep已释放，若再使用pSheep将会出错
~~~

我们看看sp的重载运算代码

~~~java
template<typename T>
sp<T>& sp<T>::operator =(T* other) {
    if (other)
        //这里我们上面已经看了，强引用加1，弱引用加1
        other->incStrong(this);
    if (m_ptr)
        //
        m_ptr->decStrong(this);
    m_ptr = other;
    return *this;
}
~~~

