[TOC]

# 10. Android 显示系统

安卓的显示系统！这可是非常复杂的一个系统，我们在以前有关于GUI的顶多就玩了下自定义VIew，而且在自定义VIew就学的够呛的了，今天我们不玩自定义View了！研究一下安卓系统是怎么管理和绘制Gui的！

## 从Activity的显示说起

一个应用的GUI的开始，当然是在第一个Activity(假设应用只有一个Activity)创建的时候，从创建进程到ActivityThread的handleLaunchActivity

~~~java
///media/ba/sd/aosp/frameworks/base/core/java/android/app/ActivityThread.java   
private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) {
       ...
        //这里就是去生成Activity，并且调用onCreate()方法
        Activity a = performLaunchActivity(r, customIntent);

        if (a != null) {
           ..
            //这里是调用Acitivty的onResume方法，我们等下再讲这里,
            handleResumeActivity(r.token, false, r.isForward,
                    !r.activity.mFinished && !r.startsNotResumed, r.lastProcessedSeq, reason);
        }

          ...
    }
~~~

看看performLaunchActivity方法

### 标记A

~~~java
///media/ba/sd/aosp/frameworks/base/core/java/android/app/ActivityThread.java

    private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
        
        Activity activity = null;
        try {
            //通过反射生成对应的Activity
            java.lang.ClassLoader cl = r.packageInfo.getClassLoader();
            activity = mInstrumentation.newActivity(
                    cl, component.getClassName(), r.intent);
            StrictMode.incrementExpectedActivityCount(activity.getClass());
            r.intent.setExtrasClassLoader(cl);
            r.intent.prepareToEnterProcess();
            if (r.state != null) {
                r.state.setClassLoader(cl);
            }
        } catch (Exception e) {
            if (!mInstrumentation.onException(activity, e)) {
                throw new RuntimeException(
                    "Unable to instantiate activity " + component
                    + ": " + e.toString(), e);
            }
        }

        try {
            //生成Application
            Application app = r.packageInfo.makeApplication(false, mInstrumentation);

            if (localLOGV) Slog.v(TAG, "Performing launch of " + r);
            if (localLOGV) Slog.v(
                    TAG, r + ": app=" + app
                    + ", appName=" + app.getPackageName()
                    + ", pkg=" + r.packageInfo.getPackageName()
                    + ", comp=" + r.intent.getComponent().toShortString()
                    + ", dir=" + r.packageInfo.getAppDir());

            if (activity != null) {
                //生成BaseContext
                Context appContext = createBaseContextForActivity(r, activity);
                CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());
                Configuration config = new Configuration(mCompatConfiguration);
                if (r.overrideConfig != null) {
                    config.updateFrom(r.overrideConfig);
                }
                if (DEBUG_CONFIGURATION) Slog.v(TAG, "Launching activity "
                        + r.activityInfo.name + " with config " + config);
                Window window = null;
                if (r.mPendingRemoveWindow != null && r.mPreserveWindow) {
                    window = r.mPendingRemoveWindow;
                    r.mPendingRemoveWindow = null;
                    r.mPendingRemoveWindowManager = null;
                }
                
                //给这个Acitivity初始化一些该有的信息，这里很重要，标记为A
                activity.attach(appContext, this, getInstrumentation(), r.token,
                        r.ident, app, r.intent, r.activityInfo, title, r.parent,
                        r.embeddedID, r.lastNonConfigurationInstances, config,
                        r.referrer, r.voiceInteractor, window);
                ...
                
                 //下面就是回调Activity的的onCreate方法
                if (r.isPersistable()) {
                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);
                } else {
                    mInstrumentation.callActivityOnCreate(activity, r.state);
                }
                if (!activity.mCalled) {
                    throw new SuperNotCalledException(
                        "Activity " + r.intent.getComponent().toShortString() +
                        " did not call through to super.onCreate()");
                }
              ...

        return activity;
    }

~~~

我们知道onCreate方法里面最重要的就是setContentView！！！这里我们还知道，Activity的生命周期的onCreate方法并不是把界面显示出来，而是去生成属于这个Activity的所有View对象并且设置一个标题栏，这里是装饰模式，我们看下去（在以前的笔记中是有说过这个东西的，本来不打算说下去的，但是没有办法。不说怕你想不通）。

~~~java
///home/ba/Android/Sdk/sources/android-25/android/app/Activity.java 
public void setContentView(@LayoutRes int layoutResID) {
        getWindow().setContentView(layoutResID);
        initWindowDecorActionBar();
    }

 public Window getWindow() {
        return mWindow;
    }
~~~

可以看到我们的给Activity设置的VIew是设置在了这个mWindow中，这个mWindow是什么？以前就说过他具体实现是：PhoneWindow！

鉴于有些人可能搞不懂window和VIew的关系：

+ window是一个抽象基类，用于控制顶层窗口的外观和行为。外观指的是我们setContentView进去后是没有actionBar的，window会帮我们搞定。行为是指：我们的View虽然都有分发触摸事件的方法，但在以前我们一直说是系统调用这些方法，那里面的事件哪里来的？触摸事件肯定是来自系统的其他进程：WMS，WMS是去找符合触摸位置等条件的window，然后给对应的window，然后给window里面的ViewRootImp，然后VIewRootImp再分发到对应的view上的。
+ ViewRootImp以前也讲过，他不是View的子类，他是用来管理一个Window下的所有View。一个WIndow的所有VIew的生命周期都是由ViewRootImp管理的
+ view是一个视图单位，占据着屏幕的一块区域，用来绘制对应的内容。

我们看看这个Window是怎么生成的,不好找，全局搜索后发现在attach方法中，我们回到上面的标记A，也就是Acitivity生成的地方，在这里调用了attach：

~~~java
//home/ba/Android/Sdk/sources/android-25/android/app/Activity.java 
    private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
    ...
          
                //给这个Acitivity初始化一些该有的信息，这里很重要
                activity.attach(appContext, this, getInstrumentation(), r.token,
                        r.ident, app, r.intent, r.activityInfo, title, r.parent,
                        r.embeddedID, r.lastNonConfigurationInstances, config,
                        r.referrer, r.voiceInteractor, window);
    ...
    }
~~~

看看这个attach方法里面有什么

~~~java
//home/ba/Android/Sdk/sources/android-25/android/app/Activity.java、
final void attach(Context context, ActivityThread aThread,
            Instrumentation instr, IBinder token, int ident,
            Application application, Intent intent, ActivityInfo info,
            CharSequence title, Activity parent, String id,
            NonConfigurationInstances lastNonConfigurationInstances,
            Configuration config, String referrer, IVoiceInteractor voiceInteractor,
            Window window) {
        attachBaseContext(context);

        mFragments.attachHost(null /*parent*/);

    ///看这里！！
        mWindow = new PhoneWindow(this, window);
    ...
            mWindow.setWindowManager(
                (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),
                mToken, mComponent.flattenToString(),
                (info.flags & ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);
        if (mParent != null) {
            mWindow.setContainer(mParent.getWindow());
        }
        mWindowManager = mWindow.getWindowManager();
        mCurrentConfig = config;
}
~~~

是PhoneWindow吧！但是他还生成了一个WindowManage,然后set进去了？？

~~~java
 public void setWindowManager(WindowManager wm, IBinder appToken, String appName,
            boolean hardwareAccelerated) {
        mAppToken = appToken;
        mAppName = appName;
        mHardwareAccelerated = hardwareAccelerated
                || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, false);
        if (wm == null) {
            wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
        }
        mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this);
    }
~~~

### 标记B

哦！可以看到生成了一个WindowManagerImpl，然后就结束了！！但是这个名字一看就很重要啊！说不定后面有大用，我们先标记为B，我们回到SetContentVIew，现在应该看PhoneWindow的setContentVIew了

~~~java
///media/ba/sd/aosp/frameworks/base/core/java/com/android/internal/policy/PhoneWindow.java 
public void setContentView(int layoutResID) {
        // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window
        // decor, when theme attributes and the like are crystalized. Do not check the feature
        // before this happens.mContentParent是null，为什么叫setContentVIew现在明白了吗？
        if (mContentParent == null) {
            //看这里！！！！
            installDecor();
        } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
            mContentParent.removeAllViews();
        }

       ...
    }


 private void installDecor() {
        mForceDecorInstall = false;
        if (mDecor == null) {
            //生成DecorVIew，基类是FramLayout！！！
            mDecor = generateDecor(-1);
            mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);
            mDecor.setIsRootNamespace(true);
            if (!mInvalidatePanelMenuPosted && mInvalidatePanelMenuFeatures != 0) {
                mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);
            }
        } else {
            mDecor.setWindow(this);
        }
        if (mContentParent == null) {
            //然后生成ContentParent，这里其实就是去设置actionBar和WIndow的Style!!
            //具体代码我就不给了。
            mContentParent = generateLayout(mDecor);
    ...
  }
     
     
~~~

我们现在先总结一下：

![image](http://wiki.jikexueyuan.com/project/deep-android-v1/images/chapter8/image004.png)

这张图很完美的看出我们前面在讲的是什么：

+ 我们调用了Activity的setContentVIew后会生成PhoneWindow，和WindowManagerImpl，
+ 然后PhoneWindow会去生成DecorVIew。
+ DecorVIew就是包括了标题栏和我们设置的View！

到这里，Acitivity的onCreate就结束了，我们只是生成了DecorView，我们并没有去绘制这些VIew，这里的所有VIew都是用LayoutInflator生成的！按照Activity的生命周期，我们应该到onResume这个过程了！回到ActivityThread

~~~java
///media/ba/sd/aosp/frameworks/base/core/java/android/app/ActivityThread.java   
private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) {
       ...
        //这里就是去生成Activity，并且调用onCreate()方法
        Activity a = performLaunchActivity(r, customIntent);

        if (a != null) {
           ..
            //这里是调用Acitivty的onResume方法，我们等下再讲这里,我们现在走到了这里！
            handleResumeActivity(r.token, false, r.isForward,
                    !r.activity.mFinished && !r.startsNotResumed, r.lastProcessedSeq, reason);
        }

          ...
    }
~~~

~~~java
///media/ba/sd/aosp/frameworks/base/core/java/android/app/ActivityThread.java   
    final void handleResumeActivity(IBinder token,
            boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) {
        ActivityClientRecord r = mActivities.get(token);
        if (!checkAndUpdateLifecycleSeq(seq, r, "resumeActivity")) {
            return;
        }

        // If we are getting ready to gc after going to the background, well
        // we are back active so skip it.
        unscheduleGcIdler();
        mSomeActivitiesChanged = true;

        //调用Activity的onResume方法
        r = performResumeActivity(token, clearHide, reason);

        if (r != null) {
            //拿到Activity
            final Activity a = r.activity;

       ...

            final int forwardBit = isForward ?
                    WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;

        
            if (r.window == null && !a.mFinished && willBeVisible) {
                //这个Window就是前面生成的PhoneWindow
                r.window = r.activity.getWindow();
                //这里就是我们前面生成的DecorVIew
                View decor = r.window.getDecorView();
                decor.setVisibility(View.INVISIBLE);
                //这个就是我们前面生成的WindowManagerImpl
                ViewManager wm = a.getWindowManager();
               
                
               ....
                   
                 //看这里！！是调用我们的WindowManagerImpl，然后addView！！！
                if (a.mVisibleFromClient && !a.mWindowAdded) {
                    a.mWindowAdded = true;
                    wm.addView(decor, l);
                }
                ...

            }
~~~

在标记B处，就出现了WindowManagerImpl！就说他很重要吧！！终于用到了！！我们看看他的addVIew方法

~~~java
///home/ba/Android/Sdk/sources/android-25/android/view/WindowManagerImpl.java 
@Override
    public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {
        applyDefaultToken(params);
        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);
    }

~~~

跑到了这个mGlobal去了。。。。

~~~java
///home/ba/Android/Sdk/sources/android-25/android/view/WindowManagerImpl.java   
/*

提供与系统窗口管理器的低级通信
  与任何特定上下文无关的操作。
 
  该类仅在内部用于实现全局函数
  调用者已经知道显示和相关的兼容性信息
  为了操作。在大多数情况下，您应该使用{@link WindowManager}
  因为它受到上下文的约束。
*/
private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();
~~~

还是个单例！那就看他的addVIew方法！

~~~java

///home/ba/Android/Sdk/sources/android-25/android/view/WindowManagerGlobal.java
    public void addView(View view, ViewGroup.LayoutParams params,
            Display display, Window parentWindow) {
      ...


        ViewRootImpl root;
        View panelParentView = null;

     /...

         //这里出现了VIewRootImp！！
            root = new ViewRootImpl(view.getContext(), display);

            view.setLayoutParams(wparams);

        
    
            mViews.add(view);
            mRoots.add(root);
            mParams.add(wparams);
        }

        // do this last because it fires off messages to start doing things
        try {
            //重点来了！！！这里把我们前面生成的DecorView设置进VIewRootImp了！！
            root.setView(view, wparams, panelParentView);
        } 
...
    }
~~~

分析到这里，我们终于到了要调用VIew的生命周期的方法了,我们看看ViewRootImp的setView方法

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java
public void setView(View view, WindowManager.LayoutParamsattrs,

                        View panelParentView){//第一个参数view是DecorView

      ......

       mView= view;//保存这个view

       synchronized (this) {

           requestLayout(); //待会先看看这个。

               try {

                    //调用IWindowSession的addToDisplay函数，第一个参数是mWindow

                 res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,
                            getHostVisibility(), mDisplay.getDisplayId(),
                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,
                            mAttachInfo.mOutsets, mInputChannel);

               }
           
          ......

}
~~~

ViewRoot的setView函数做了三件事：

·  保存传入的view参数为mView，这个mView指向PhoneWindow的DecorView。

·  调用requestLayout。

·  调用IWindowSession的addToDisplay函数，这是一个跨进程的Binder通信，第一个参数是mWindow，它是W类型，从IWindow.stub派生。

## 熟悉的绘制流程

### 标记C

我们先看看requestLayout做了什么

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java  
@Override
    public void requestLayout() {
        if (!mHandlingLayoutInLayoutRequest) {
            //检查当前线程是否是UI线程！！！
            checkThread();
            mLayoutRequested = true;
            //是不是就去绘制了？？
            scheduleTraversals();
        }
    }


    void scheduleTraversals() {
        if (!mTraversalScheduled) {
            mTraversalScheduled = true;
            //发了个消息,所以我们看看mTraversalRunnable写了什么
            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();
            mChoreographer.postCallback(
                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);
            ...
        }
    }

 final class TraversalRunnable implements Runnable {
        @Override
        public void run() {
            //继续
            doTraversal();
        }
    }

   void doTraversal() {
        if (mTraversalScheduled) {
            mTraversalScheduled = false;
            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);

            if (mProfile) {
                Debug.startMethodTracing("ViewAncestor");
            }

            //看这个！！！这是我们熟悉的方法啊！！这能触发绘制！！！
            performTraversals();

            if (mProfile) {
                Debug.stopMethodTracing();
                mProfile = false;
            }
        }
    }

 private void performTraversals() {      
     //这就是我们的DecorVIew
        final View host = mView;
     
     try {

    	relayoutResult= //①关键函数relayoutWindow，标记为C

		relayoutWindow(params, viewVisibility,insetsPending);
   }

......

		performDraw()// ②开始绘制
 }

~~~

我们先看performDraw方法做了什么

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java  
 private void performDraw() {
          ....
        try {
           //这个！！！
            draw(fullRedrawNeeded);
        } finally {
            mIsDrawing = false;
            Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        }
     ...
 }


private void draw(boolean fullRedrawNeeded) {
    	//surface????
        Surface surface = mSurface;
        if (!surface.isValid()) {
            return;
        }
    ...

        //这个！！！
          if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) {
                    return;
         }
    ...

     }


   private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff,
            boolean scalingRequired, Rect dirty) {

        // 看到这个的时候，虎躯一震！这不就是画布吗！！！！
        final Canvas canvas;
        try {
         
            ...

            //锁住
            canvas = mSurface.lockCanvas(dirty);

      ....
          		//绘制！！！
                mView.draw(canvas);

       ...
            
        } finally {
            try {
                //解锁
                surface.unlockCanvasAndPost(canvas);
            }
            ...
        }
        return true;
    }

~~~

我们很清楚的知道view.draw（）方法里面做了些什么，不就是“四大金刚”相互合作，这四大金刚是：

·  Bitmap：用于存储像素，也就是画布。可把它当做一块数据存储区域。

·  Canvas：用于记载画图的动作，比如画一个圆，画一个矩形等。Canvas类提供了这些基本的绘图函数。

·  Drawing primitive：绘图基元，例如矩形、圆、弧线、文本、图片等。

·  Paint：它用来描述绘画时使用的颜色、风格（如实线、虚线等）等。

在一般情况下，Canvas会封装一块Bitmap，而作图就是基于这块Bitmap的。前面说的画布，其实指的就是Canvas中的这块Bitmap。动动脑子想想，显示器这个硬件设备肯定不是java层去直接控制的，我们现在要研究的不是java层的那些个抽象方法调来调去，具体的绘制实现肯定在native层，一定要把它揪出来。

## Surface初现！

我们可以看到在调用view的draw之前，跑出来了一个surface！他的值来源于mSurface字段！！那这块Bitmap是不是就是由这个surface准备的？我们看看他的初始化

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java  
final Surface mSurface = new Surface();
~~~

看看surface的构造函数

~~~java
//home/ba/Android/Sdk/sources/android-25/android/view/Surface.java
//注意这个
 private final Canvas mCanvas = new CompatibleCanvas();
public Surface() {
    }
~~~

空的！！那还能咋办呀？只能看看他的lockCanvas方法干了些什么

~~~java
//home/ba/Android/Sdk/sources/android-25/android/view/Surface.java
public Canvas lockCanvas(Rect inOutDirty)
            throws Surface.OutOfResourcesException, IllegalArgumentException {
        synchronized (mLock) {
            checkNotReleasedLocked();
            if (mLockedObject != 0) {
                // Ideally, nativeLockCanvas() would throw in this situation and prevent the
                // double-lock, but that won't happen if mNativeObject was updated.  We can't
                // abandon the old mLockedObject because it might still be in use, so instead
                // we just refuse to re-lock the Surface.
                throw new IllegalArgumentException("Surface was already locked");
            }
            //是个JNI方法
            mLockedObject = nativeLockCanvas(mNativeObject, mCanvas, inOutDirty);
            //返回了CompatibleCanvas
            return mCanvas;
        }
    }
~~~

这个mCanvas的实际类型为CompatibleCanvas，可以看到调了个JNI函数，很激动吧！！终于看到有native的影子了！所以我们要找到注册的地方，但是我搜索了Serface类，没有调用init方法。但是！！注意看nativeLockCanvas方法传入的参数！mNativeObject！！这是什么？？

~~~java
//home/ba/Android/Sdk/sources/android-25/android/view/Surface.java
long mNativeObject; 
~~~

指针耶！说明这个东西的具体对象其实是在c++层！我们使用surfece的函数时候mNativeObject;都要作为参数传进去，那他是怎么来的?他的真正类型是什么？那就找他的来源吧！

~~~java
//home/ba/Android/Sdk/sources/android-25/android/view/Surface.java
public void copyFrom(SurfaceControl other) {
        if (other == null) {
            throw new IllegalArgumentException("other must not be null");
        }

     	//这里！！！！
        long surfaceControlPtr = other.mNativeObject;
        if (surfaceControlPtr == 0) {
            throw new NullPointerException(
                    "SurfaceControl native object is null. Are you using a released SurfaceControl?");
        }
        long newNativeObject = nativeCreateFromSurfaceControl(surfaceControlPtr);

        synchronized (mLock) {
            if (mNativeObject != 0) {
                nativeRelease(mNativeObject);
            }
            setNativeObjectLocked(newNativeObject);
        }
    }
~~~

这个copyFrom什么时候调用的？？我们在绘制之前，还调用了一个方法在标记C处：relayoutWindow()，他会不会就是去准备SurfaceControl这个对象？

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java   
private int relayoutWindow(WindowManager.LayoutParams params, int viewVisibility,
            boolean insetsPending) throws RemoteException {

       ...
         //注意看最后一个参数，mSurface！！！传进去的原因可能就是去方便调用Surface的方法，说不定就是copyFrom方法！
        int relayoutResult = mWindowSession.relayout(
                mWindow, mSeq, params,
                (int) (mView.getMeasuredWidth() * appScale + 0.5f),
                (int) (mView.getMeasuredHeight() * appScale + 0.5f),
                viewVisibility, insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : 0,
                mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets,
                mPendingStableInsets, mPendingOutsets, mPendingBackDropFrame, mPendingConfiguration,
                mSurface);

        mPendingAlwaysConsumeNavBar =
                (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_CONSUME_ALWAYS_NAV_BAR) != 0;

      ...
        return relayoutResult;
    }
~~~

这个mWindowSession又是什么东西？？到目前为止已经出现了两次进程通信了！！!在VIewRootImp的setVIew方法出现了一次，在relayoutWindow又出现了一次。

## 蛛丝马迹

我们回到ViewRootImp的构造函数仔细看看

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java    
public ViewRootImpl(Context context, Display display) {
      ...
        mWindowSession = WindowManagerGlobal.getWindowSession();
      ...
        mWindow = new W(this);
      
        ...
     
    }

~~~

我们先看getWindowSession

~~~java
//home/ba/Android/Sdk/sources/android-25/android/view/WindowManagerGlobal.java    
public static IWindowSession getWindowSession() {
        synchronized (WindowManagerGlobal.class) {
            if (sWindowSession == null) {
                try {
                    InputMethodManager imm = InputMethodManager.getInstance();
                    IWindowManager windowManager = getWindowManagerService();
                    sWindowSession = windowManager.openSession(
                            new IWindowSessionCallback.Stub() {
                                @Override
                                public void onAnimatorScaleChanged(float scale) {
                                    ValueAnimator.setDurationScale(scale);
                                }
                            },
                            imm.getClient(), imm.getInputContext());
                } catch (RemoteException e) {
                    throw e.rethrowFromSystemServer();
                }
            }
            return sWindowSession;
        }
    }
~~~

可以看到这一次openSession的进程通信的目的端是WMS！我们看看这个openSession干了什么

~~~java
//media/ba/sd/aosp/frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java   
@Override
    public IWindowSession openSession(IWindowSessionCallback callback, IInputMethodClient client,
            IInputContext inputContext) {
        if (client == null) throw new IllegalArgumentException("null client");
        if (inputContext == null) throw new IllegalArgumentException("null inputContext");
        Session session = new Session(this, callback, client, inputContext);
        return session;
    }
~~~

说明了IWindowSession对象是WMS的Bn代理！！！那W类型的mWindow是什么？

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java    
static class W extends IWindow.Stub {
        private final WeakReference<ViewRootImpl> mViewAncestor;
        private final IWindowSession mWindowSession;

        W(ViewRootImpl viewAncestor) {
            mViewAncestor = new WeakReference<ViewRootImpl>(viewAncestor);
            mWindowSession = viewAncestor.mWindowSession;
        }
        
        ...
    }
~~~

嗯，他也是用来进程通信的！他的类型是IWindow，我们后面再讲这个IWindow。我们回到ViewRootImp的setVIew方法

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java
public void setView(View view, WindowManager.LayoutParamsattrs,

                        View panelParentView){//第一个参数view是DecorView

      ......

       mView= view;//保存这个view

       synchronized (this) {

           requestLayout(); 

               try {

                    //调用IWindowSession的add函数，第一个参数是mWindow

                       res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,
                            getHostVisibility(), mDisplay.getDisplayId(),
                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,
                            mAttachInfo.mOutsets, mInputChannel);

               }

          ......

}
~~~

我们先小结一下：

+ 我们在Activity的onCreate阶段进行了装饰我们通过setCotentView方法设置进去的VIew，生成DecorVIew
+ 然后为这个Activity绑定了一个PhoneWindow和WindowMananger
+ 然后在Activity的onResume阶段通过WindowMananger生成了一个ViewRootImp，用来管理我们的DecorVIew

- 我们new了ViewRootImp后就去和WMS进行了进程通信，其实就是先和WMS建立起联系，也算是初始化Binder通信
- 然后调用了VIewRootImp的setVIew方法，这里面做了两件事
- 从requestLayout走到了VIew的draw方法，但是在draw前，进行了一次进程通信，因为有个surface对象和绘制有着莫大的联系，但是我们查看Surface的代码发现他在里面就是一直调用native层的方法，这点我们知道绘制肯定是在native层，有意思的是，在Surface对象里面保存了一个叫做nativeObject的指针，他的类型不是对象，而是long。所以他的真实对象类型我们不清楚，当我们找他的来源时，停在了copyFrom方法，我们不知道谁去调用了这个方法，所以我们猜想是在draw前的进程通信那里做了手脚！！
- 在requestLayout()方法里面绘制完后我们又进行了一次进程通信sWindowSession.addToDisplay（）
- 所以我们现在卡在了两次进程通信！！只要搞明白这两次进程通信就能搞明白Surface到底和绘制有着什么关系。

## 两次进程通信

一个WIndow的作用就两个：行为和外观！  requestLayout(); 方法里面进行了VIew的draw，这里虽然进行了一次进程通信，但是我们相信这一次进程通信是绘制前的准备工作，毕竟他传入了个mSurface对象，所以我觉得requestLayout这里负责外观。

但是走完requestLayout的时候，就又进行了一次进程通信sWindowSession.add，这一次，我觉得是负责行为（也就是按键事件），因为他传入了个mWindow，要知道这个可是一个BInder对象，鉴于IWindowSession是WMS的BInder，所以类型为IWindow的mWindow很有可能就是给WMS回调的Bn端，为什么要回调？按键事件肯定是从WMS来的，WIndow只能等WMS告诉你！！！；

我们先分析sWindowSession.addToDisplay（）因为Surface才是重头戏，我们要放后面讲IWindowSession.aidl的具体实现是Session

~~~java
    //media/ba/sd/aosp/frameworks/base/services/core/java/com/android/server/wm/Session.java
   

    @Override
    public int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs,
            int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets,
            Rect outOutsets, InputChannel outInputChannel) {
        return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId,
                outContentInsets, outStableInsets, outOutsets, outInputChannel);
    }

~~~

可以看到，调用的是服务端的addWindow方法，也就是WMS的addWindow方法

~~~java
//media/ba/sd/aosp/frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java   
public int addWindow(Session session, IWindow client, int seq,
            WindowManager.LayoutParams attrs, int viewVisibility, int displayId,
            Rect outContentInsets, Rect outStableInsets, Rect outOutsets,
            InputChannel outInputChannel) {
      ...
        //创建一个WindowState
            WindowState win = new WindowState(this, session, client, token,
                    attachedWindow, appOp[0], seq, attrs, viewVisibility, displayContent);
           
           ...
        //这个很重要
            win.attach();
        ...

        return res;
    }
~~~



~~~java
//media/ba/sd/aosp/frameworks/base/services/core/java/com/android/server/wm/WindowState.java
void attach() {
        if (WindowManagerService.localLOGV) Slog.v(
            TAG, "Attaching " + this + " token=" + mToken
            + ", list=" + mToken.windows);
        mSession.windowAddedLocked();
    }
~~~

其实就是Session的windowAddedLocked方法

~~~java
//media/ba/sd/aosp/frameworks/base/services/core/java/com/android/server/wm/Session.java 
void windowAddedLocked() {
    //做了一个判断，说明WMS只会为一个进程打开一个SurfaceSession
        if (mSurfaceSession == null) {
            if (WindowManagerService.localLOGV) Slog.v(
                TAG_WM, "First window added to " + this + ", creating SurfaceSession");
            //注意！！！这里
            mSurfaceSession = new SurfaceSession();
            if (SHOW_TRANSACTIONS) Slog.i(
                    TAG_WM, "  NEW SURFACE SESSION " + mSurfaceSession);
            mService.mSessions.add(this);
            if (mLastReportedAnimatorScale != mService.getCurrentAnimatorScale()) {
                mService.dispatchNewAnimatorScaleLocked(this);
            }
        }
        mNumWindow++;
    }
~~~

这里居然生成了个SurfaceSession？？？懵逼！难道我们猜错了？？？这里不是按键处理？？不信这个邪，我们先把这个SurfaceSession放一边，现在我们代码走到了这里，把IWindow放进了WindowState里面，我觉得这样太麻烦了，我们直接看IWIndow的具体代码不就好了！！

~~~java
oneway interface IWindow {
    /**
     * ===== NOTICE =====
     * The first method must remain the first method. Scripts
     * and tools rely on their transaction number to work properly.
     */

    /**
     * Called for wallpaper windows when their offsets change.
     */
    void dispatchWallpaperOffsets(float x, float y, float xStep, float yStep, boolean sync);
    
    void dispatchWallpaperCommand(String action, int x, int y,
            int z, in Bundle extras, boolean sync);

    /**
     * Drag/drop events
     */
    void dispatchDragEvent(in DragEvent event);

    /**
     * Pointer icon events
     */
    void updatePointerIcon(float x, float y);

    /**
     * System chrome visibility changes
     */
    void dispatchSystemUiVisibilityChanged(int seq, int globalVisibility,
            int localValue, int localChanges);

    /**
     * Called for non-application windows when the enter animation has completed.
     */
    void dispatchWindowShown();
}

~~~

明白了？这里的事件指的就是按键、触屏等事件。那么，一个按键事件是如何被分发的呢？下面是它大致的流程：

·  WMS所在的SystemServer进程接收到按键事件。

·  WMS找到UI位于屏幕顶端的进程所对应的IWindow对象，这是一个Bp端对象。

·  调用这个IWindow对象的dispatchKey。IWindow对象的Bn端位于ViewRoot中，ViewRoot再根据内部View的位置信息找到真正处理这个事件的View，最后调用dispatchKey函数完成按键的处理。

其实这些按键事件的分发机制可以拿Windows的UI编程来做类比，在Windows中应用程序的按键处理流程是：

·  每一个按键事件都会转化成一个消息，这个消息将由系统加入到对应进程的消息队列中。该进程的消息在派发处理时，会根据消息的句柄找到对应的Window（窗口），继而该消息就由这个Window处理了。

注意：上面的描述实际上大大简化了真实的处理流程，读者可在了解大体知识后进行更深入的研究。

所以可以看出，这次通信的目的之一就是去注册这个按键，但是我们看到创建了一个SurfaceSession！！说明这次进程通信还进行了一些动西的初始化，但是现在问题来了，我们这次分析的进程通信是在addToDisplay，我们看看下面的代码

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java
public void setView(View view, WindowManager.LayoutParamsattrs,

                        View panelParentView){//第一个参数view是DecorView

      ......

       mView= view;//保存这个view

       synchronized (this) {

           //这里面会有一个进程通信
           requestLayout(); 

               try {

                    //刚刚我们分析的是这个进程通信

                       res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,
                            getHostVisibility(), mDisplay.getDisplayId(),
                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,
                            mAttachInfo.mOutsets, mInputChannel);

               }

          ......

}
~~~

所以问题就很大了，为什么初始化的过程居然在requestLayout方法的后面？？我们知道requestLayout方法就是去绘制界面了，都绘制了后才来初始化，有什么用？？所以我们肯定漏了什么东西，我们回到绘制的方法里面

~~~java
    void scheduleTraversals() {
        if (!mTraversalScheduled) {
            mTraversalScheduled = true;
            //发了个消息
            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();
            mChoreographer.postCallback(
                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);
            ...
        }
    }
~~~

我们刚刚是直接分析一发消息就去执行mTraversalRunnable的方法，但是现在看来并不是这样的，这个事件发送出去后，requestLayout方法就结束了！就到addToDisplay了，真正绘制的过程还没有发生！！因为mTraversalRunnable，还没被执行，这样似乎就说的通了，所以说这个mTraversalRunnable是会在合适的时候被调用，我们先看一下时序图

![image](http://wiki.jikexueyuan.com/project/deep-android-v1/images/chapter8/image007.png)

看到5和6，5的add在安卓7.0代码中对应的是addToDisplay()，我们上面分析代码是requestlayout()先，6的relayout()是在mTraversalRunnable里面的，而mTraversalRunnable是在requestlayout()方法被发送出去的，但是还没被执行就到了addToDisplay()方法，所以上面的时序图是正确的，第五步我们生成了一个SurfaceSession，这个可以看出是在第二次进程通信里面要用到，我们先不管mTraversalRunnable是被什么条件触发后执行，现在只需要知道他是在addToDisplay方法后被执行就好了，我们现在就看看mTraversalRunnable被执行后进行的第二次进程通信做了什么！！！

第二次进程通信是在

~~~java
 private void performTraversals() {      
     //这就是我们的DecorVIew
        final View host = mView;
     
     try {

         //这里！！！
    	relayoutResult= 

		relayoutWindow(params, viewVisibility,insetsPending);
   }

......

		performDraw()// ②开始绘制
 }
~~~

在这里我们是有疑惑的，Surface的nativeObject到底是什么？那就要看是谁调用了copyFrom方法？relayoutWindow肯定是对Surface对象进行初始化设置的，一起解密吧！！！

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java   
private int relayoutWindow(WindowManager.LayoutParams params, int viewVisibility,
            boolean insetsPending) throws RemoteException {

       ...
         //注意看最后一个参数，mSurface！！！传进去的原因可能就是去方便调用Surface的方法，说不定就是copyFrom方法！
        int relayoutResult = mWindowSession.relayout(
                mWindow, mSeq, params,
                (int) (mView.getMeasuredWidth() * appScale + 0.5f),
                (int) (mView.getMeasuredHeight() * appScale + 0.5f),
                viewVisibility, insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : 0,
                mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets,
                mPendingStableInsets, mPendingOutsets, mPendingBackDropFrame, mPendingConfiguration,
                mSurface);

        mPendingAlwaysConsumeNavBar =
                (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_CONSUME_ALWAYS_NAV_BAR) != 0;

      ...
        return relayoutResult;
    }
~~~

这里就是时序图中的第6步，relayout！！按照Binder的设计，我们应该找到IWindowSession的具体实现：也就是我们说的Bp，我找不到，按照书上说的，就应该去编译这个AIDL文件，就能得到了。

### 标记Ｄ

~~~java
//这个类应该叫BpWindowSession.java
public int relayout(android.view.IWindow window,

                 android.view.WindowManager.LayoutParams attrs,

                  int requestedWidth, intrequestedHeight,

                 int viewVisibility, boolean insetsPending,

                 android.graphics.Rect outFrame,

                 android.graphics.Rect outContentInsets,

                 android.graphics.Rect outVisibleInsets,

                 android.content.res.Configuration outConfig,

                 android.view.Surface outSurface)//outSurface是第11个参数

                                    throwsandroid.os.RemoteException

{

   android.os.Parcel_data = android.os.Parcel.obtain();

   android.os.Parcel_reply = android.os.Parcel.obtain();

   int_result;

   try {

      _data.writeInterfaceToken(DESCRIPTOR);

     _data.writeStrongBinder((((window!=null))?(window.asBinder()):(null)));

     if((attrs!=null)) {

       _data.writeInt(1);

       attrs.writeToParcel(_data,0);

     }

    else {

    _data.writeInt(0);

   }

  _data.writeInt(requestedWidth);

  _data.writeInt(requestedHeight);

  _data.writeInt(viewVisibility);

  _data.writeInt(((insetsPending)?(1):(0)));

 //奇怪，outSurface的信息没有写到请求包_data中，就直接发送请求消息了，我们先研究这里

  mRemote.transact(Stub.TRANSACTION_relayout,_data, _reply, 0);

  _reply.readException();

  _result= _reply.readInt();

  if((0!=_reply.readInt())) {

   outFrame.readFromParcel(_reply);

  }

  ....

  if((0!=_reply.readInt())) {

//从Parcel中读取信息来填充outSurface,这里等下我们再看，标记为D
     outSurface.readFromParcel(_reply);

    }

  }

  ......

  return_result;

}
~~~

可以看到上面是没有把ourSurface写到数据包就发送了，但是在等待答复的时候却对outSurface进行了操作，我们先去看看Bn端的接收端发生了什么(这个Bn端的代码按照谷歌的风格应该也是放在IWindowSession的具体实现类里面的)。

### 标记E

~~~java
public boolean onTransact(int code,android.os.Parcel data,

                               android.os.Parcelreply, int flags)

                    throwsandroid.os.RemoteException

{

  switch(code)

  {

    caseTRANSACTION_relayout:

    {

      data.enforceInterface(DESCRIPTOR);

      android.view.IWindow_arg0;

      android.view.Surface_arg10;

      //刚才讲了，Surface信息并没有传过来，那么在relayOut中看到的outSurface是怎么

      //出来的呢？看下面这句可知，原来在服务端这边竟然new了一个新的Surface!!!这个new出来的Surface只是一个中转而已。

      _arg10= new android.view.Surface();
      
      //然后去调用了具体实现的relayout方法，我们等下先讲这个

      int_result = this.relayout(_arg0, _arg1, _arg2, _arg3, _arg4,

      _arg5,_arg6, _arg7, _arg8, _arg9, _arg10);
      
      
      //下面是回复应用进程的代码，我们等下再看，标记为Ｅ

      reply.writeNoException();

      reply.writeInt(_result);

      //_arg10就是调用copyFrom的那个outSurface，那怎么传到客户端呢？

      if((_arg10!=null)) {

           reply.writeInt(1);

           //调用Surface的writeToParcel，把信息写到reply包中。

           _arg10.writeToParcel(reply,

                 android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);

        }

    }

    ......

   return true;

}
~~~

具体实现应该就是Session里面的代码

~~~java
///media/ba/sd/aosp/frameworks/base/services/core/java/com/android/server/wm/Session.java    
public int relayout(IWindow window, int seq, WindowManager.LayoutParams attrs,
            int requestedWidth, int requestedHeight, int viewFlags,
            int flags, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,
            Rect outVisibleInsets, Rect outStableInsets, Rect outsets, Rect outBackdropFrame,
            Configuration outConfig, Surface outSurface) {
        if (false) Slog.d(TAG_WM, ">>>>>> ENTERED relayout from "
                + Binder.getCallingPid());
        //看这里
        int res = mService.relayoutWindow(this, window, seq, attrs,
                requestedWidth, requestedHeight, viewFlags, flags,
                outFrame, outOverscanInsets, outContentInsets, outVisibleInsets,
                outStableInsets, outsets, outBackdropFrame, outConfig, outSurface);
        if (false) Slog.d(TAG_WM, "<<<<<< EXITING relayout to "
                + Binder.getCallingPid());
        return res;
    }
~~~

这里要注意这个outSurface并不是我们从ViewRootImp传过来的！

~~~java
//media/ba/sd/aosp/frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java   
public int relayoutWindow(Session session, IWindow client, int seq,
            WindowManager.LayoutParams attrs, int requestedWidth,
            int requestedHeight, int viewVisibility, int flags,
            Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,
            Rect outVisibleInsets, Rect outStableInsets, Rect outOutsets, Rect outBackdropFrame,
            Configuration outConfig, Surface outSurface) {
        int result = 0;
        boolean configChanged;
        boolean hasStatusBarPermission =
                mContext.checkCallingOrSelfPermission(android.Manifest.permission.STATUS_BAR)
                        == PackageManager.PERMISSION_GRANTED;

        long origId = Binder.clearCallingIdentity();
        synchronized(mWindowMap) {
            //注意看这个，去查找WIndowState！这个WindowState在上一次进程通信的时候就生成了！
            WindowState win = windowForClientLocked(session, client, false);
            if (win == null) {
                return 0;
            }

           ...

    
   
              if (viewVisibility == View.VISIBLE &&
                    (win.mAppToken == null || !win.mAppToken.clientHidden)) {
                result = relayoutVisibleWindow(outConfig, result, win, winAnimator, attrChanges,
                        oldVisibility);
                try {
                    //我们看这一句，虽然下面的代码也有getSession，但是我觉得从这里入手比较好
                    result = createSurfaceControl(outSurface, result, win, winAnimator);
                } catch (Exception e) {
                    mInputMonitor.updateInputWindowsLw(true /*force*/);

                    Slog.w(TAG_WM, "Exception thrown when creating surface for client "
                             + client + " (" + win.mAttrs.getTitle() + ")",
                             e);
                    Binder.restoreCallingIdentity(origId);
                    return 0;
                }
        
                  //这里有用到，但是上面的方法可以看到surfaceController的创建，所以我们还是分析上面的方法吧
                final WindowSurfaceController surfaceController = winAnimator.mSurfaceController;
                if (viewVisibility == View.VISIBLE && surfaceController != null) {
                    // We already told the client to go invisible, but the message may not be
                    // handled yet, or it might want to draw a last frame. If we already have a
                    // surface, let the client use that, but don't create new surface at this point.
                    surfaceController.getSurface(outSurface);
                } else {
                   ...
        return result;
    }
                  
                  
 private int createSurfaceControl(Surface outSurface, int result, WindowState win,
            WindowStateAnimator winAnimator) {
        if (!win.mHasSurface) {
            result |= RELAYOUT_RES_SURFACE_CHANGED;
        }
     	//先看这个
        WindowSurfaceController surfaceController = winAnimator.createSurfaceLocked();
        if (surfaceController != null) {
            //这个等再看
            surfaceController.getSurface(outSurface);
            if (SHOW_TRANSACTIONS) Slog.i(TAG_WM, "  OUT SURFACE " + outSurface + ": copied");
        } else {
            // For some reason there isn't a surface.  Clear the
            // caller's object so they see the same state.
            Slog.w(TAG_WM, "Failed to create surface control for " + win);
            outSurface.release();
        }
        return result;
    }
~~~

~~~~java
//media/ba/sd/aosp/frameworks/base/services/core/java/com/android/server/wm/WindowStateAnimator.java  
WindowSurfaceController createSurfaceLocked() {
        final WindowState w = mWin;
      
...
      	//这里！！可以看到他把SurfaceSession传了进去！我还一直纳闷前面生成的这个东西没有用呢!原来用在这里了！！！！
        mSurfaceController = new WindowSurfaceController(mSession.mSurfaceSession,
                    attrs.getTitle().toString(),
                    width, height, format, flags, this);

            w.setHasSurface(true);

           ...
        return mSurfaceController;
    }

~~~~

现在只能看WindowSurfaceController的构造函数了！！

~~~java
//media/ba/sd/aosp/frameworks/base/services/core/java/com/android/server/wm/WindowSurfaceController.java   
public WindowSurfaceController(SurfaceSession s,
            String name, int w, int h, int format, int flags, WindowStateAnimator animator) {
        mAnimator = animator;

        mSurfaceW = w;
        mSurfaceH = h;

        title = name;

  
        // For opaque child windows placed under parent windows,
        // we use a special SurfaceControl which mirrors commands
        // to a black-out layer placed one Z-layer below the surface.
        // This prevents holes to whatever app/wallpaper is underneath.
        if (animator.mWin.isChildWindow() &&
                animator.mWin.mSubLayer < 0 &&
                animator.mWin.mAppToken != null) {
            mSurfaceControl = new SurfaceControlWithBackground(s,
                    name, w, h, format, flags, animator.mWin.mAppToken);
        } else if (DEBUG_SURFACE_TRACE) {
            mSurfaceControl = new SurfaceTrace(
                    s, name, w, h, format, flags);
        } else {
            //这个
            mSurfaceControl = new SurfaceControl(
                    s, name, w, h, format, flags);
        }
    }
~~~

wtf。。。服了，，我们看最后一个

~~~java
///media/ba/sd/aosp/frameworks/base/core/java/android/view/SurfaceControl.java   
public SurfaceControl(SurfaceSession session,
            String name, int w, int h, int format, int flags)
                    throws OutOfResourcesException {
        if (session == null) {
            throw new IllegalArgumentException("session must not be null");
        }
        if (name == null) {
            throw new IllegalArgumentException("name must not be null");
        }

        if ((flags & SurfaceControl.HIDDEN) == 0) {
            Log.w(TAG, "Surfaces should always be created with the HIDDEN flag set "
                    + "to ensure that they are not made visible prematurely before "
                    + "all of the surface's properties have been configured.  "
                    + "Set the other properties and make the surface visible within "
                    + "a transaction.  New surface name: " + name,
                    new Throwable());
        }

        mName = name;
    	//看这里！怎么又多了一个mNativeObject，说明SurfaceConteol也有一个native层对应的对象！！！
        mNativeObject = nativeCreate(session, name, w, h, format, flags);
        if (mNativeObject == 0) {
            throw new OutOfResourcesException(
                    "Couldn't allocate SurfaceControl native object");
        }

        mCloseGuard.open("release");
    }

~~~

现在让我们回到surfaceController.getSurface(outSurface);方法

~~~java
//media/ba/sd/aosp/frameworks/base/services/core/java/com/android/server/wm/WindowSurfaceController.java 
void getSurface(Surface outSurface) {
        outSurface.copyFrom(mSurfaceControl);
    }
~~~

这里需要注意！！这个outSurface不是我们VIewRootImp里面的Surface对象，而是在Bn端直接new出来的，但是我们知道这个copyFrom对象就是把mSurfaceControl配置好的一些东西设置到outSurface里面去，尤其是那两个nativeObject！但是里面还是会调用到JNI的方法，我们先不管JNI层的调用！现在我们回到标记E

~~~java
public boolean onTransact(int code,android.os.Parcel data,

                               android.os.Parcelreply, int flags)

                    throwsandroid.os.RemoteException

{      
...
    
      reply.writeNoException();

      reply.writeInt(_result);

      //_arg10就是调用copyFrom的那个outSurface，那怎么传到客户端呢？

      if((_arg10!=null)) {

           reply.writeInt(1);

           //调用Surface的writeToParcel，把信息写到reply包中。

           //注意最后一个参数为PARCELABLE_WRITE_RETURN_VALUE

           _arg10.writeToParcel(reply,

                 android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);

        }

    }

    ......

   return true;

}
~~~

我们看看Surface的writeToParcel方法

~~~java
//home/ba/Android/Sdk/sources/android-25/android/view/Surface.java    
@Override
    public void writeToParcel(Parcel dest, int flags) {
        if (dest == null) {
            throw new IllegalArgumentException("dest must not be null");
        }
        synchronized (mLock) {
            // NOTE: This must be kept synchronized with the native parceling code
            // in frameworks/native/libs/Surface.cpp
            dest.writeString(mName);
            dest.writeInt(mIsSingleBuffered ? 1 : 0);
            nativeWriteToParcel(mNativeObject, dest);
        }
        if ((flags & Parcelable.PARCELABLE_WRITE_RETURN_VALUE) != 0) {
            release();
        }
    }
~~~

又是跑到JNI调用，okok，我们先不分析JNI的东西，这一步无非就是把信息写过去而已，现在回到Bp端,就是标记D处

~~~java
//这个类应该叫BpWindowSession.java
public int relayout(android.view.IWindow window,

                 android.view.WindowManager.LayoutParams attrs,

                  int requestedWidth, intrequestedHeight,

                 int viewVisibility, boolean insetsPending,

                 android.graphics.Rect outFrame,

                 android.graphics.Rect outContentInsets,

                 android.graphics.Rect outVisibleInsets,

                 android.content.res.Configuration outConfig,

                 android.view.Surface outSurface)//outSurface是第11个参数

                                    throwsandroid.os.RemoteException

{

  ...
  if((0!=_reply.readInt())) {

//这里！！
     outSurface.readFromParcel(_reply);

    }

  }

  ......

  return_result;

}
~~~

标记E处的readFromParcel里面肯定也是jni层的调用，其实就是把Bn端的数据搞过来，现在我们小结一下再进行JNI层的分析

+ 这次进程通信，经历了步骤如下
+ IWindowSession的Bp，进行打包数据，但是没有把我们当前进程VIewRootImp的surface打包进去
+ 然后调用了transact方法和WMS进行通信
+ Bn端收到请求后先是生成了一个新的surface，然后再传到具体的实现方法，Session的relayout（），Session的relayout方法里面又会把处理交给WMS的relayoutWindow()方法处理。
+ WMS的relayoutWindow()方法会先生成SurfaceControl
+ 然后调用SurfaceControl的nativeCreate方法（SurfaceSession作为参数），通过JNI函数生成一个native的SurfaceControl。
+ 然后SurfaceControl的getSurface方法，实际是调用我们新生成的java层的surface对象的copyFrom方法
+ 这个copyFrom会通过SurfaceControl，从native层里面拿到我们native对应的Surface
+ 现在所有的数据，都放在了新生成的surface对象中，Bn端通过该surface的WriteToParcel()打包数据到reply（就是我们的标记D），再通过Binder把数据返回给我们进程的Bp端
+ Bp端收到结果和数据包后，通过我们进程的VIewRootImp生成的Surface的readFromParcel()方法把内容读出来（就是我们的标记E），填充自己

+ 我们现在知道了Surface里面的NativeObject就是Native层的Surface对象，但是SurfaceSession作为参数WMS生成这个NativeObject是SurfaceControl的nativeObject对象，参照java层的设计，native层也是把Surface对象放在了SurfaceControl里面

下面我们开始看JNI层的代码，下面是我们分析的步骤

+ 分析SurfaceControl生成对应native层的NativeObject的代码
+ 分析在WMS所处进程的Surface的copyFrom函数做了什么
+ 分析在WMS所处进程的Surface的WriteToParcel函数做了什么
+ 分析在我们进程VIewRootImp的Surface的readFromParcel函数做了什么

一步一步来，我们先看创建SurfaceControl里面的NativeObject创建的方法

~~~java
public class SurfaceControl {
    private static final String TAG = "SurfaceControl";

    private static native long nativeCreate(SurfaceSession session, String name,
            int w, int h, int format, int flags);
}
~~~

按照JNI技术的命名，我们直接找native层对应的代码

~~~java
//media/ba/sd/aosp/frameworks/base/core/jni/android_view_SurfaceControl.cpp
static jlong nativeCreate(JNIEnv* env, jclass clazz, jobject sessionObj,
        jstring nameStr, jint w, jint h, jint format, jint flags) {
    ScopedUtfChars name(env, nameStr);
    
    //先看这，通过SurfaceSession对象获取一个SurfaceComposerClient，这就说明在SurfaceSession构造函数里面就有去创建这个native层的SurfaceComposerClient对象了，代码我就不给出来了
    sp<SurfaceComposerClient> client(android_view_SurfaceSession_getClient(env, sessionObj));
    
    //这里要注意！说是创建Surface，但是实际创建的是SurfaceControl,这个地方其实是跨进程调用，我们后面再讲，只需要知道当前就是实例化一个SurfaceControl
      sp<SurfaceControl> surface = client->createSurface(
            String8(name.c_str()), w, h, format, flags);
    if (surface == NULL) {
        jniThrowException(env, OutOfResourcesException, NULL);
        return 0;
    }
    surface->incStrong((void *)nativeCreate);
    
    //主要看这个，很熟悉吧！！！又是偷偷的转换指针
    //einterpret_cast是个很强大的运算符，因为它可以无视种族隔离，随便搞。但就像生物的准则，不符合自然规律的随意杂交只会得到不能长久生存的物种。随意在不同类型之间使用reinterpret_cast，也之后造成程序的破坏和不能使用。其实就是转成jlong类型
    return reinterpret_cast<jlong>(surface.get());
    
}
~~~

### 标记为G

~~~c
sp<SurfaceControl> SurfaceComposerClient::createSurface(
        const String8& name,
        uint32_t w,
        uint32_t h,
        PixelFormat format,
        uint32_t flags)
{
    sp<SurfaceControl> sur;
    if (mStatus == NO_ERROR) {
        sp<IBinder> handle;
        sp<IGraphicBufferProducer> gbp;
        //这里其实是跨进程通信，我们后面会讲，要很后面了！这里标记为G，你现在只需要知道这个就是创建SurfaceControl对象就好
        status_t err = mClient->createSurface(name, w, h, format, flags,
                &handle, &gbp);
        ALOGE_IF(err, "SurfaceComposerClient::createSurface error %s", strerror(-err));
        if (err == NO_ERROR) {
            sur = new SurfaceControl(this, handle, gbp);
        }
    }
    return sur;
}
~~~

这里就是创建WMS进程的SurfaceControl对象以及SurfaceControl的native对象的过程

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/Surface.java 
public void copyFrom(SurfaceControl other) {
        if (other == null) {
            throw new IllegalArgumentException("other must not be null");
        }

        long surfaceControlPtr = other.mNativeObject;
        if (surfaceControlPtr == 0) {
            throw new NullPointerException(
                    "SurfaceControl native object is null. Are you using a released SurfaceControl?");
        }
    
    //可以看到从native层的SurfaceControl创建native层的Surface！！！
        long newNativeObject = nativeCreateFromSurfaceControl(surfaceControlPtr);

        synchronized (mLock) {
            if (mNativeObject != 0) {
                nativeRelease(mNativeObject);
            }
            setNativeObjectLocked(newNativeObject);
        }
    }
~~~

这个方法是在native层jni的Surface类

~~~c
//media/ba/sd/aosp/frameworks/base/core/jni/android_view_Surface.cpp
static jlong nativeCreateFromSurfaceControl(JNIEnv* env, jclass clazz,
        jlong surfaceControlNativeObj) {
    /*
     * This is used by the WindowManagerService just after constructing
     * a Surface and is necessary for returning the Surface reference to
     * the caller. At this point, we should only have a SurfaceControl.
     */

    sp<SurfaceControl> ctrl(reinterpret_cast<SurfaceControl *>(surfaceControlNativeObj));
    //你看这里就生成了native的surface！！！！
    sp<Surface> surface(ctrl->getSurface());
    if (surface != NULL) {
        surface->incStrong(&sRefBaseOwner);
    }
    return reinterpret_cast<jlong>(surface.get());
}

~~~

看看这个getSurface,这个getSurface不是JNI的方法了！！！而是native层的SurfaceControl的方法

~~~c
///media/ba/sd/aosp/frameworks/native/libs/gui/SurfaceControl.cpp
sp<Surface> SurfaceControl::getSurface() const
{
    Mutex::Autolock _l(mLock);
    if (mSurfaceData == 0) {
        // This surface is always consumed by SurfaceFlinger, so the
        // producerControlledByApp value doesn't matter; using false.
        //生成一个native层的Surface
         mSurfaceData = new Surface(mGraphicBufferProducer, false);
    }
    return mSurfaceData;
}

~~~

到了这里，WMS临时生成的Surface对象，已经万事俱备了！！！接下来就是分析在WMS所处进程的Surface的WriteToParcel函数做了什么

### 标记F

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/Surface.java    
@Override
    public void writeToParcel(Parcel dest, int flags) {
        if (dest == null) {
            throw new IllegalArgumentException("dest must not be null");
        }
        synchronized (mLock) {
            dest.writeString(mName);
            //调用了jni的方法
            nativeWriteToParcel(mNativeObject, dest);
        }
        
        //注意这个方法！！等下会讲，标记为F
        if ((flags & Parcelable.PARCELABLE_WRITE_RETURN_VALUE) != 0) {
            release();
        }
    }
~~~

~~~c
//media/ba/sd/aosp/frameworks/base/core/jni/android_view_Surface.cpp
static void nativeWriteToParcel(JNIEnv* env, jclass clazz,
        jlong nativeObject, jobject parcelObj) {
    Parcel* parcel = parcelForJavaObject(env, parcelObj);
    if (parcel == NULL) {
        doThrowNPE(env);
        return;
    }
    sp<Surface> self(reinterpret_cast<Surface *>(nativeObject));
    android::view::Surface surfaceShim;
    if (self != nullptr) {
        surfaceShim.graphicBufferProducer = self->getIGraphicBufferProducer();
    }
    // Calling code in Surface.java has already written the name of the Surface
    // to the Parcel
    surfaceShim.writeToParcel(parcel, /*nameAlreadyWritten*/true);
}
~~~

可以看到调用了native层的Surface的方法

~~~c
//media/ba/sd/aosp/frameworks/native/libs/gui/Surface.cpp
status_t Surface::writeToParcel(Parcel* parcel, bool nameAlreadyWritten) const {
    if (parcel == nullptr) return BAD_VALUE;

    status_t res = OK;

    if (!nameAlreadyWritten) res = parcel->writeString16(name);

    if (res == OK) {
        res = parcel->writeStrongBinder(
                IGraphicBufferProducer::asBinder(graphicBufferProducer));
    }
    return res;
}
~~~

看吧！就是打包发送数据而已。我们先看看上面的标记F

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/Surface.java    
@Override
    public void writeToParcel(Parcel dest, int flags) {
        if (dest == null) {
            throw new IllegalArgumentException("dest must not be null");
        }
        synchronized (mLock) {
            dest.writeString(mName);
                     nativeWriteToParcel(mNativeObject, dest);
        }
        
  
        if ((flags & Parcelable.PARCELABLE_WRITE_RETURN_VALUE) != 0) {
            release();
        }
    }
~~~

这个方法就是去释放native层的Surface而已。我们看看代码

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/Surface.java  
/**
     * Release the local reference to the server-side surface.
     * Always call release() when you're done with a Surface.
     * This will make the surface invalid.
     */
    public void release() {
        synchronized (mLock) {
            if (mNativeObject != 0) {
                //这里
                nativeRelease(mNativeObject);
                setNativeObjectLocked(0);
            }
            if (mHwuiContext != null) {
                mHwuiContext.destroy();
                mHwuiContext = null;
            }
        }
    }
~~~

看看jni层

~~~c
static void nativeRelease(JNIEnv* env, jclass clazz, jlong nativeObject) {
    //干掉native层的Surface的强指针！！
    sp<Surface> sur(reinterpret_cast<Surface *>(nativeObject));
    sur->decStrong(&sRefBaseOwner);
}

~~~



接下来分析在我们进程VIewRootImp的Surface的readFromParcel函数做了什么

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/Surface.java    
public void readFromParcel(Parcel source) {
        if (source == null) {
            throw new IllegalArgumentException("source must not be null");
        }

        synchronized (mLock) {
            // nativeReadFromParcel() will either return mNativeObject, or
            // create a new native Surface and return it after reducing
            // the reference count on mNativeObject.  Either way, it is
            // not necessary to call nativeRelease() here.
            mName = source.readString();
            setNativeObjectLocked(nativeReadFromParcel(mNativeObject, source));
        }
    }
~~~

就是读数据，填充自己啦！！

## 小结

两次进程通信和我们猜想的是一样的，直接看时序图

![image](http://wiki.jikexueyuan.com/project/deep-android-v1/images/chapter8/image007.png)

经过这次分析，我们终于看到了JNI技术在安卓的使用！！可以说是实战了一次，在之前学习JNI技术的时候可是无聊的很呀！而且这里还涉及到智能指针，你可以看到无处不是，只是因为作用域的分析太困难，但是我们可以看到很多地方去增加计数！！释放sp的地方也有，我特地讲了，还记得吗？就是Surface的releass方法！在标记F。

我们看看这两次进程通信都生成了哪些重要的对象

+ SurfaceSession（这个上面我们并没有很详细的分析，因为他是重头戏，后面会慢慢分析，目前我们知道就是创建Surface的时候作为参数传进去）
+ SurfaceComposerClient（这个在创建SurfaceControl的时候用到）
+ SurfaceControl（创建Surface）
+ Surface（这个我目前就知道要创建他，知道他和画图有关）

上面的对象都有大用，而 我们现在对他们一无所知，也就是说我们才刚刚创建完他们，为他们初始化！！！！气吧！讲了1万多字才完成了初始化，继续看下去吧！！

## Surface和画图

经历了长长无趣的分析，我们终于知道VIewRootImp的Surface是怎么来的啦！！现在让我们回到绘制的代码

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java  
private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff,
            boolean scalingRequired, Rect dirty) {

        // 看到这个的时候，虎躯一震！这不就是画布吗！！！！
        final Canvas canvas;
        try {
         
            ...

            //锁住
            canvas = mSurface.lockCanvas(dirty);

      ....
          		//绘制！！！
                mView.draw(canvas);

       ...
            
        } finally {
            try {
                //解锁
                surface.unlockCanvasAndPost(canvas);
            }
            ...
        }
        return true;
    }

~~~

三步走：

+ lockCanvas
+ draw
+ unlockCanvasAndPost

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/Surface.java
//Rect代表要绘制的矩形区域
    public Canvas lockCanvas(Rect inOutDirty)
            throws Surface.OutOfResourcesException, IllegalArgumentException {
        synchronized (mLock) {
            checkNotReleasedLocked();
            if (mLockedObject != 0) {
                // Ideally, nativeLockCanvas() would throw in this situation and prevent the
                // double-lock, but that won't happen if mNativeObject was updated.  We can't
                // abandon the old mLockedObject because it might still be in use, so instead
                // we just refuse to re-lock the Surface.
                throw new IllegalArgumentException("Surface was already locked");
            }
            
            //native的方法
            mLockedObject = nativeLockCanvas(mNativeObject, mCanvas, inOutDirty);
            return mCanvas;
        }
    }

~~~

~~~c
//media/ba/sd/aosp/frameworks/base/core/jni/android_view_Surface.cpp
static jlong nativeLockCanvas(JNIEnv* env, jclass clazz,
        jlong nativeObject, jobject canvasObj, jobject dirtyRectObj) {
    //取出native层的surface对象
    sp<Surface> surface(reinterpret_cast<Surface *>(nativeObject));

    if (!isSurfaceValid(surface)) {
        doThrowIAE(env);
        return 0;
    }

    Rect dirtyRect(Rect::EMPTY_RECT);
    Rect* dirtyRectPtr = NULL;

    if (dirtyRectObj) {
        dirtyRect.left   = env->GetIntField(dirtyRectObj, gRectClassInfo.left);
        dirtyRect.top    = env->GetIntField(dirtyRectObj, gRectClassInfo.top);
        dirtyRect.right  = env->GetIntField(dirtyRectObj, gRectClassInfo.right);
        dirtyRect.bottom = env->GetIntField(dirtyRectObj, gRectClassInfo.bottom);
        dirtyRectPtr = &dirtyRect;
    }

    ANativeWindow_Buffer outBuffer;
    //看这个，调用这个native层的lock函数。
    status_t err = surface->lock(&outBuffer, dirtyRectPtr);
    if (err < 0) {
        const char* const exception = (err == NO_MEMORY) ?
                OutOfResourcesException :
                "java/lang/IllegalArgumentException";
        jniThrowException(env, exception, NULL);
        return 0;
    }

	//构建一个info用来存一些信息，这里和Skia二维图形引擎有关
    SkImageInfo info = SkImageInfo::Make(outBuffer.width, outBuffer.height,
                                         convertPixelFormat(outBuffer.format),
                                         outBuffer.format == PIXEL_FORMAT_RGBX_8888 ?
                                         kOpaque_SkAlphaType : kPremul_SkAlphaType);


    
    SkBitmap bitmap;
    ssize_t bpr = outBuffer.stride * bytesPerPixel(outBuffer.format);
    bitmap.setInfo(info, bpr);
    if (outBuffer.width > 0 && outBuffer.height > 0) {
        //在这个outBuffer设置一个存储区域
        bitmap.setPixels(outBuffer.bits);
    } else {
        // be safe with an empty bitmap.
        bitmap.setPixels(NULL);
    }

    //然后给Canvas设置好Bitmap，所以说接下来的绘制数据其实就是在这个Bitmap里面
    Canvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);
    nativeCanvas->setBitmap(bitmap);

...
    return (jlong) lockedSurface.get();
}
~~~

该方法的过程就是获得一块存储区域，然后绑定给Canvas。在第二步的VIew.draw（）中的ui操作都是在这块存储区域记录的。接下来的第三步就是把这些数据给到对应的引擎去处理然后放到显示设备显示。具体流程看图

![image](http://wiki.jikexueyuan.com/project/deep-android-v1/images/chapter8/image009.png)

---



## 分析Surface！

我们按照上面的图一步一步的来分析



## SurfaceComposerClient

很早就出现了这个东西，到底是个什么呢？你看他中文翻译多厉害：Compser-作曲家！其实真正处理图像混合的东西叫：SurfaceFlinger。SurfaceComposerClient和SurfaceFlinger到底有什么关系呢？SurfaceFlinger继承于SurfaceComposer！！！！！现在你知道他们是什么关系了吧？

- 与SurfaceFlinger相关的基础知识

`SurfaceFlinger`可以说是`Android UI`渲染体系的核心，在Android系统启动时会启动`SurfaceFlinger`服务,它的主要作用就是被Android应用程序调用，把绘制(测量，布局，绘制)后的窗口(Surface)渲染到手机屏幕上。所以整个 UI刷新过程可能像下面这张图:

![image](https://user-gold-cdn.xitu.io/2019/1/15/1684f466358d089b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

~~~c
作者：susion

链接：https://juejin.im/post/5c3d4104f265da61141cd13f

来源：掘金

著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
~~~

我们看看SurfaceComposerClient初始化的地方！

~~~java
public final class SurfaceSession {
    // Note: This field is accessed by native code.
    //看这里，官方注释！！！SurfaceComposerClient*！！！
    private long mNativeClient; // SurfaceComposerClient*

    private static native long nativeCreate();
    private static native void nativeDestroy(long ptr);
    private static native void nativeKill(long ptr);

    /** Create a new connection with the surface flinger. */
    public SurfaceSession() {
        //在这里创建
        mNativeClient = nativeCreate();
    }

    /* no user serviceable parts here ... */
    @Override
    protected void finalize() throws Throwable {
        try {
            if (mNativeClient != 0) {
                nativeDestroy(mNativeClient);
            }
        } finally {
            super.finalize();
        }
    }

    /**
     * Forcibly detach native resources associated with this object.
     * Unlike destroy(), after this call any surfaces that were created
     * from the session will no longer work.
     */
    public void kill() {
        nativeKill(mNativeClient);
    }
}
~~~

SurfaceSession里面的nativeObject居然是SurfaceComposerClient！！！看他对应的JNI函数

~~~java
//media/ba/sd/aosp/frameworks/base/core/jni/android_view_SurfaceSession.cpp
static jlong nativeCreate(JNIEnv* env, jclass clazz) {
    SurfaceComposerClient* client = new SurfaceComposerClient();
     client->incStrong((void*)nativeCreate);
    return reinterpret_cast<jlong>(client);
}
~~~

看构造

~~~java
///media/ba/sd/aosp/frameworks/native/libs/gui/SurfaceComposerClient.cpp
SurfaceComposerClient::SurfaceComposerClient()
    : mStatus(NO_INIT), mComposer(Composer::getInstance())
{
}

~~~

可以看到构造里面是空的，但是！！！onFirstRef方法里面才进行初始化！要不是我学过JNI，就真找不到这个初始化的代码了！！！

~~~c
//media/ba/sd/aosp/frameworks/native/libs/gui/SurfaceComposerClient.cpp
void SurfaceComposerClient::onFirstRef() {
    //没骗你吧！进行通信，拿到ISurfaceComposer，真实对象是BpSurfaceComposer
    sp<ISurfaceComposer> sm(ComposerService::getComposerService());
    if (sm != 0) {
        //进行连接
        sp<ISurfaceComposerClient> conn = sm->createConnection();
        if (conn != 0) {
            mClient = conn;
            mStatus = NO_ERROR;
        }
    }
}
~~~

刚刚我们说过SurfaceFlinger继承与SurfaceComposer，所以这里其实是在和SurfaceFlinger进行Connection！！

~~~c
//media/ba/sd/aosp/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
sp<ISurfaceComposerClient> SurfaceFlinger::createConnection()
{
    //BClient：这是用来Binder通信的，作用是用来接收客户端请求，然后把请求提交给SF处理
    sp<ISurfaceComposerClient> bclient;
    //为什么会有这个？
    sp<Client> client(new Client(this));
    
    //这个方法
    status_t err = client->initCheck();
    if (err == NO_ERROR) {
        //Client继承于ISurfaceComposerClient
        bclient = client;
    }
    return bclient;
}

~~~

可以看到我们客户端这一次生成的WIndow通过createConnection后拿到了    sp<ISurfaceComposerClient> bclient;这样就能和SurfaceFlinger进进程通信了！一个应用程序只具有一个SurfaceComposerClient对象！为什么呢？因为在创建SurfaceSession的时候不就有个判空？如果已经有了我们进程SurfaceSession，WMS进程就不会打开第二个SurfaceSession了！而SurfaceComposerClient又是在SurfaceSession构造函数里面创建的，所以当然是一个进程只有一个！！而且，和SurfaceFlinger进程交互，只需要一个Bp端就够了呀！

接下来我们看看Client是什么： 这个对象十分重要，它维护这应用程序的渲染核心数据，并负责与`SurfaceFlinger`通信,以及用来创建Surface，销毁Surface，获取和清除Surface信息。我们看看他内容就知道了。

~~~c
//media/ba/sd/aosp/frameworks/native/services/surfaceflinger/Client.h
amespace android {

// ---------------------------------------------------------------------------

class Layer;
class SurfaceFlinger;

// ---------------------------------------------------------------------------

class Client : public BnSurfaceComposerClient
{
public:
        Client(const sp<SurfaceFlinger>& flinger);
        ~Client();

    status_t initCheck() const;

    
    // protected by SurfaceFlinger::mStateLock
    void attachLayer(const sp<IBinder>& handle, const sp<Layer>& layer);

    void detachLayer(const Layer* layer);

    sp<Layer> getLayerUser(const sp<IBinder>& handle) const;

private:
    // ISurfaceComposerClient interface //创建
    virtual status_t createSurface(
            const String8& name,
            uint32_t w, uint32_t h,PixelFormat format, uint32_t flags,
            sp<IBinder>* handle,
            sp<IGraphicBufferProducer>* gbp);

    //销毁
    virtual status_t destroySurface(const sp<IBinder>& handle);

    //清除信息
    virtual status_t clearLayerFrameStats(const sp<IBinder>& handle) const;

    //获取信息
    virtual status_t getLayerFrameStats(const sp<IBinder>& handle, FrameStats* outStats) const;
    virtual status_t getTransformToDisplayInverse(
            const sp<IBinder>& handle, bool* outTransformToDisplayInverse) const;

    //和SurfaceFlinger通信
    virtual status_t onTransact(
        uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags);

    // constant
    sp<SurfaceFlinger> mFlinger;

    // protected by mLock 这个后面会讲
    DefaultKeyedVector< wp<IBinder>, wp<Layer> > mLayers;

    // thread-safe
    mutable Mutex mLock;
};

// ---------------------------------------------------------------------------
}; // namespace android

#endif // ANDROID_SF_CLIENT_H

~~~

管理Surface的生命周期耶！！！所以说作用还是很大的！到这里SurfaceComposerClient就初始化完成了！我们回到流程图

![image](http://wiki.jikexueyuan.com/project/deep-android-v1/images/chapter8/image009.png)

## SurfaceControl

现在我们看看SurfaceControl是怎么创建的，我们上面并没有详细讲SurfaceControl是怎么创建的，现在我们来看看

~~~c
//media/ba/sd/aosp/frameworks/base/core/jni/android_view_SurfaceControl.cpp
static jlong nativeCreate(JNIEnv* env, jclass clazz, jobject sessionObj,
        jstring nameStr, jint w, jint h, jint format, jint flags) {
    ScopedUtfChars name(env, nameStr);
    
  ...
    sp<SurfaceComposerClient> client(android_view_SurfaceSession_getClient(env, sessionObj));
    
    //就是这里，我们上次说他这里是进行进程通信，经过上面的分析后现在我们知道他是和谁进程通信了！！！！
      sp<SurfaceControl> surface = client->createSurface(
            String8(name.c_str()), w, h, format, flags);
    if (surface == NULL) {
        jniThrowException(env, OutOfResourcesException, NULL);
        return 0;
    }
 ..
    return reinterpret_cast<jlong>(surface.get());
    
}

~~~

通过SurfaceFlinger创建SurfaceControl对象，这一次我们就不看Bp端的内容了，因为Bp端肯定又是直接new个SurfaceControl出来，等这次进程通信完后从数据包拿数据进行填充，所以这次进程通信我们直接看SurfaceFlinger的对应方法看他里面到底干了什么就好了

~~~c
status_t Client::createSurface(
        const String8& name,
        uint32_t w, uint32_t h, PixelFormat format, uint32_t flags,
        sp<IBinder>* handle,
        sp<IGraphicBufferProducer>* gbp)
{
    /*
     * createSurface must be called from the GL thread so that it can
     * have access to the GL context.，这里写的很清楚了，就是为了保证可以使用GL的Context，所以才要post到那个 线程，其实这里就是通知SurfaceFlinger去创建Surface啦！
     */

    class MessageCreateLayer : public MessageBase {
        SurfaceFlinger* flinger;
        Client* client;
        sp<IBinder>* handle;
        sp<IGraphicBufferProducer>* gbp;
        status_t result;
        const String8& name;
        uint32_t w, h;
        PixelFormat format;
        uint32_t flags;
    public:
        MessageCreateLayer(SurfaceFlinger* flinger,
                const String8& name, Client* client,
                uint32_t w, uint32_t h, PixelFormat format, uint32_t flags,
                sp<IBinder>* handle,
                sp<IGraphicBufferProducer>* gbp)
            : flinger(flinger), client(client),
              handle(handle), gbp(gbp), result(NO_ERROR),
              name(name), w(w), h(h), format(format), flags(flags) {
        }
        status_t getResult() const { return result; }
        virtual bool handler() {
            //注意这句！！！为什么是创建Layer？？这里注意一下最后的参数，gbp
            result = flinger->createLayer(name, client, w, h, format, flags,
                    handle, gbp);
            return true;
        }
    };

    sp<MessageBase> msg = new MessageCreateLayer(mFlinger.get(),
            name, this, w, h, format, flags, handle, gbp);
    mFlinger->postMessageSync(msg);
    //他返回的对象是Layer！！！！
    return static_cast<MessageCreateLayer*>( msg.get() )->getResult();
}
~~~

现在我们是在是没有办法了！必须要讲Layer是什么东西了！！！ 

### Layer

#### 显示层（Layer）和屏幕组成

你了解屏幕显示的漂亮界面是如何组织的吗？来看图8-10所展示的屏幕组成示意图：

![image](http://wiki.jikexueyuan.com/project/deep-android-v1/images/chapter8/image010.png)

图8-10  屏幕组成示意图

从图8-10中可以看出：

·  屏幕位于一个三维坐标系中，其中Z轴从屏幕内指向屏幕外。

·  编号为①②③的矩形块叫显示层（Layer）。每一层有自己的属性，例如颜色、透明度、所处屏幕的位置、宽、高等。除了属性之外，每一层还有自己对应的显示内容，也就是需要显示的图像。

在Android中，Surface系统工作时，会由SurfaceFlinger对这些按照Z轴排好序的显示层进行图像混合，混合后的图像就是在屏幕上看到的美妙画面了。这种按Z轴排序的方式符合我们在日常生活中的体验，例如前面的物体会遮挡住后面的物体。

注意，Surface系统中定义了一个名为Layer类型的类，为了区分广义概念上的Layer和代码中的Layer，这里称广义层的Layer为显示层，以免混淆。

Surface系统提供了三种属性，一共四种不同的显示层。简单介绍一下：

·  第一种属性是eFXSurfaceNormal属性，大多数的UI界面使用的就是这种属性。它有两种模式：

​       1）Normal模式，这种模式的数据，是通过前面的mView.draw(canvas)画上去的。这也是绝大多数UI所采用的方式。

​       2）PushBuffer模式，这种模式对应于视频播放、摄像机摄录/预览等应用场景。以摄像机为例，当摄像机运行时，来自Camera的预览数据直接push到Buffer中，无须应用层自己再去draw了。

·  第二种属性是eFXSurfaceBlur属性，这种属性的UI有点朦胧美，看起来很像隔着一层毛玻璃。

·  第三种属性是eFXSurfaceDim属性，这种属性的UI看起来有点暗，好像隔了一层深色玻璃。从视觉上讲，虽然它的UI看起来有点暗，但并不模糊。而eFXSurfaceBlur不仅暗，还有些模糊。

图8-11展示了最后两种类型的视觉效果图，其中左边的是Blur模式，右边的是Dim模式。

​           

![image](http://wiki.jikexueyuan.com/project/deep-android-v1/images/chapter8/image011.png)![image](http://wiki.jikexueyuan.com/project/deep-android-v1/images/chapter8/image012.png)

图8-11  Blur和Dim效果图

注意，关于Surface系统的显示层属性定义，读者可参考ISurfaceComposer.h。

现在我们知道Layer是什么东西了，现在让我们看看Layer创建的代码

### 标记H

~~~c
status_t SurfaceFlinger::createLayer(
        const String8& name,
        const sp<Client>& client,
        uint32_t w, uint32_t h, PixelFormat format, uint32_t flags,
        sp<IBinder>* handle, sp<IGraphicBufferProducer>* gbp)
{
    ...

    sp<Layer> layer;

    //果然是创建不同的显示层效果霍
    switch (flags & ISurfaceComposerClient::eFXSurfaceMask) {
        case ISurfaceComposerClient::eFXSurfaceNormal:
            //我们注意看这个，这个就是我们上面说的普通效果的显示层，注意！这里也用到了gbp
            result = createNormalLayer(client,
                    name, w, h, flags, format,
                    handle, gbp, &layer);
            break;
        case ISurfaceComposerClient::eFXSurfaceDim:
            result = createDimLayer(client,
                    name, w, h, flags,
                    handle, gbp, &layer);
            break;
        default:
            result = BAD_VALUE;
            break;
    }

    if (result != NO_ERROR) {
        return result;
    }

    //这个方法我们等下讲，标记为H
    result = addClientLayer(client, *handle, *gbp, layer);
    if (result != NO_ERROR) {
        return result;
    }

    setTransactionFlags(eTransactionNeeded);
    return result;
}
~~~

我们看看createNormalLayer方法

~~~c
status_t SurfaceFlinger::createNormalLayer(const sp<Client>& client,
        const String8& name, uint32_t w, uint32_t h, uint32_t flags, PixelFormat& format,
        sp<IBinder>* handle, sp<IGraphicBufferProducer>* gbp, sp<Layer>* outLayer)
{
    // initialize the surfaces
    switch (format) {
    case PIXEL_FORMAT_TRANSPARENT:
    case PIXEL_FORMAT_TRANSLUCENT:
        format = PIXEL_FORMAT_RGBA_8888;
        break;
    case PIXEL_FORMAT_OPAQUE:
        format = PIXEL_FORMAT_RGBX_8888;
        break;
    }

    *outLayer = new Layer(this, client, name, w, h, flags);
    status_t err = (*outLayer)->setBuffers(w, h, format, flags); //把新建的layer的指针拷贝给outLayer,这样outLayer就指向了新建的Layer
    if (err == NO_ERROR) {
        *handle = (*outLayer)->getHandle();//获取 handle
        *gbp = (*outLayer)->getProducer(); //获取 生产者

    }

    ALOGE_IF(err, "createNormalLayer() failed (%s)", strerror(-err));
    return err;
}

~~~

主要做了4步

+ 构造函数

+ setBuffers
+ 获取  handle
+ 获取 IGraphicBufferProducer

构造函数,没有我想关注的东西，看onFirstRef函数

### 标记I

~~~c

//media/ba/sd/aosp/frameworks/native/services/surfaceflinger/Layer.cpp
void Layer::onFirstRef() {
    
    //注意看这两个东西一个是生产者一个是消费者，他们是两个Buffer，
    // Creates a custom BufferQueue for SurfaceFlingerConsumer to use
    sp<IGraphicBufferProducer> producer;
    sp<IGraphicBufferConsumer> consumer;
       BufferQueue::createBufferQueue(&producer, &consumer);
    
    
    //MonitoredProducer是对BufferQueueProducer的封装，其目的，就是Producer销毁时，能通知SurfaceFlinger。这就是取名Monitored的愿意。余下的，MonitoredProducer的很多接口都是直接调，对应的BufferQueueProducer的实现。
    mProducer = new MonitoredProducer(producer, mFlinger);

    //标记I
    mSurfaceFlingerConsumer = new SurfaceFlingerConsumer(consumer, mTextureName,
            this);
    mSurfaceFlingerConsumer->setConsumerUsageBits(getEffectiveUsage(0));
   
    mSurfaceFlingerConsumer->setContentsChangedListener(this);
    mSurfaceFlingerConsumer->setName(mName);

#ifdef TARGET_DISABLE_TRIPLE_BUFFERING
#warning "disabling triple buffering"
#else
    
   //这里是指生产者最大可以申请两个缓冲区
    mProducer->setMaxDequeuedBufferCount(2);
#endif

    
    const sp<const DisplayDevice> hw(mFlinger->getDefaultDisplayDevice());
    updateTransformHint(hw);
}
~~~

到这里，我们可以看到基本都是在处理Buffer，到了这里，我们就要正式开始介绍SurfaceFlinger和图像缓冲的知识了，这里引用一个大佬的讲解：

> 我们将App绘图类比为向画板中画画，但是与画画不同的是，我们的绘制UI其实是写入UI的像素数据，这些数据最终将被渲染到屏幕上，屏幕上的像素点显示对应坐标的像素值。那么问题来了，我们怎么向屏幕中写入数据呢？别忘了，Android是基于Linux的，Linux系统有个Framebuffer，我们只要向这个FrameBuffer中写入数据，系统就会在一个合适的时机从Framebuffer中取出数据，渲染到屏幕上。那么我们是不是只要将app的UI数据写入到这个FrameBuffer就可以了呢？
>
> 事实上，这是不可取的，因为Android系统里安装了很多app，每个App又会有很多Surface，可是屏幕只有一个，如果大家同时都往屏幕上直接写数据，岂不是乱套了，所以Android就搞了一个SurfaceFlinger，专门来负责这件事。屏幕相当于学校里的的画廊，SurfaceFlinger就是负责画廊的老师，它给每个学生发了一张纸，告诉大家将自己的画画在自己的纸上，最后再交给老师（SurfaceFlinger），老师再将大家的画整理一下，按照一定顺序贴到画廊（屏幕）上。
>
> 画画的例子告诉我们，老师会给每个学生都发一张纸，所以SurfaceFlinger也会给每个Activity分配一个缓冲区来绘制UI，这些缓冲区叫图形缓冲区，而上面的Framebuffer叫帧缓冲区。但是事实上，学校里有很多学生（Surface），每个学生画完一张，交给SurfaceFlinger后，SurfaceFlinger又要接着给他再发一张，如果负责画廊的老师（SurfaceFlinger）一个个去给每个学生（Surface）收发画纸（缓冲区），岂不要累死，所以每个学生（Surface）又会有个助理老师来负责发画纸，收画纸这件事，而这个助理就是BufferQueue。
>
> BufferQueue是Surface中所有缓冲区的管理者，内部分配了一个包含64个BufferSlot的数组：
>
> ```java
> //frameworks/native/include/gui/BufferQueueDefs.h
> enum { NUM_BUFFER_SLOTS = 64 };
> typedef BufferSlot SlotsType[NUM_BUFFER_SLOTS]
> ```
>
> BufferSlot内部有个智能指针，指向一个缓冲区GraphicBuffer。也就是说，一个Surface最多可以有64个图形缓冲区。
>
> **BufferQueue采用了生产者-消费者的模式：**其中生产者为BufferQueueProducer，通过调用dequeBuffer（）获取到一个空闲的缓冲区，并填入要绘制的图形数据，接着调用queueBuffer（）将Buffer重新返回给BufferQueue。而消费者则为BufferQueueConsumer，通过调用acquireBuffer（）从BufferQueue中拿到一个被填满的缓冲区并消费。
>
> 
>
> Surface并不关心消费者，因为它应该不管这件事，它的责任是拿到空闲的缓冲区，并绘制自己的UI数据，所以它需要的是空闲缓冲区的生产者，及BufferQueueProducer。
>
> 来源：<https://zhuanlan.zhihu.com/p/30535788>

所以我们现在终于知道IGraphicBufferProducer是什么了，这也 能解释了为什么在创建完Layer后，我们给SurfaceControl的是生产者，而不是消费者了，正如上面说的，surface只关注生产就好了！！！不记得了？我们看看代码

~~~c
status_t SurfaceFlinger::createNormalLayer(const sp<Client>& client,
        const String8& name, uint32_t w, uint32_t h, uint32_t flags, PixelFormat& format,
        sp<IBinder>* handle, sp<IGraphicBufferProducer>* gbp, sp<Layer>* outLayer)
{
    // initialize the surfaces
    switch (format) {
    case PIXEL_FORMAT_TRANSPARENT:
    case PIXEL_FORMAT_TRANSLUCENT:
        format = PIXEL_FORMAT_RGBA_8888;
        break;
    case PIXEL_FORMAT_OPAQUE:
        format = PIXEL_FORMAT_RGBX_8888;
        break;
    }

    *outLayer = new Layer(this, client, name, w, h, flags);
    status_t err = (*outLayer)->setBuffers(w, h, format, flags); 
    if (err == NO_ERROR) {
        *handle = (*outLayer)->getHandle();//获取 handle
        *gbp = (*outLayer)->getProducer(); //看这里！！！！

    }

    ALOGE_IF(err, "createNormalLayer() failed (%s)", strerror(-err));
    return err;
}
~~~

现在我们知道，一个Window对应一个VIewRootImp，一个VIewRootImp对应一个surface，一个surface对应着一个SurfaceControl，一个SurfaceControl对应一个Layer，一个Layer对应一个生产者和一个消费者，但是其实生产者和消费操作 的缓冲区是同一个！我们看看创建缓冲区的代码（废话霍）

~~~c
void BufferQueue::createBufferQueue(sp<IGraphicBufferProducer>* outProducer,
        sp<IGraphicBufferConsumer>* outConsumer,
        const sp<IGraphicBufferAlloc>& allocator) {
    LOG_ALWAYS_FATAL_IF(outProducer == NULL,
            "BufferQueue: outProducer must not be NULL");
    LOG_ALWAYS_FATAL_IF(outConsumer == NULL,
            "BufferQueue: outConsumer must not be NULL");

    //创建一个BufferQueueCore
    sp<BufferQueueCore> core(new BufferQueueCore(allocator));
    LOG_ALWAYS_FATAL_IF(core == NULL,
            "BufferQueue: failed to create BufferQueueCore");

    //创建生产者
    sp<IGraphicBufferProducer> producer(new BufferQueueProducer(core));
    LOG_ALWAYS_FATAL_IF(producer == NULL,
            "BufferQueue: failed to create BufferQueueProducer");

    //创建消费者
    sp<IGraphicBufferConsumer> consumer(new BufferQueueConsumer(core));
    LOG_ALWAYS_FATAL_IF(consumer == NULL,
            "BufferQueue: failed to create BufferQueueConsumer");

    //返回给Layer
    *outProducer = producer;
    *outConsumer = consumer;
}
~~~

可以看到生产者消费者都是用的同一个BufferQueueCore，所以他们用的其实是同一个缓冲区，接下来返回给Layer后，我们看看代码

~~~java
//media/ba/sd/aosp/frameworks/native/services/surfaceflinger/Layer.cpp
void Layer::onFirstRef() {
    
  ...
 	sp<IGraphicBufferProducer> producer;
  
    sp<IGraphicBufferConsumer> consumer;
    
 
       BufferQueue::createBufferQueue(&producer, &consumer);
    
        //MonitoredProducer是对BufferQueueProducer的封装，其目的，就是Producer销毁时，能通知SurfaceFlinger。这就是取名Monitored的愿意。余下的，MonitoredProducer的很多接口都是直接调，对应的BufferQueueProducer的实现。
    mProducer = new MonitoredProducer(producer, mFlinger);
   
    //现在我们讲到这里，他传进了消费者
    mSurfaceFlingerConsumer = new SurfaceFlingerConsumer(consumer, mTextureName,
            this);
    mSurfaceFlingerConsumer->setConsumerUsageBits(getEffectiveUsage(0));
   //然后把当前的Layer也搞进去了
      mSurfaceFlingerConsumer->setContentsChangedListener(this);
    mSurfaceFlingerConsumer->setName(mName);

#ifdef TARGET_DISABLE_TRIPLE_BUFFERING
#warning "disabling triple buffering"
#else
    
   //这里是指生产者最大可以申请两个缓冲区
    mProducer->setMaxDequeuedBufferCount(2);
#endif

    
    const sp<const DisplayDevice> hw(mFlinger->getDefaultDisplayDevice());
    updateTransformHint(hw);
}
~~~

其实就是进行初始化生产者和消费者，按照类名，他应该是去和SurfaceFlinger搞一起了。因为SurfaceFlinger就是消费者呀，具体我们后面看看能不能详细的讲，我们现在再来理解一下生产者，BufferQueueProducer中dequeueBuffer和queueBuffer是两个非常重要的函数。我们的应用中，是通过dequeueBuffer函数，获取到一个Buffer，再通过queueBuffer，将数据写到BufferQueue里面。具体过程我们稍后面讲解。现在我们回到为终于为SurfaceControl生成Layer后的代码

~~~c
status_t SurfaceFlinger::createNormalLayer(const sp<Client>& client,
        const String8& name, uint32_t w, uint32_t h, uint32_t flags, PixelFormat& format,
        sp<IBinder>* handle, sp<IGraphicBufferProducer>* gbp, sp<Layer>* outLayer)
{
    // initialize the surfaces
    switch (format) {
    case PIXEL_FORMAT_TRANSPARENT:
    case PIXEL_FORMAT_TRANSLUCENT:
        format = PIXEL_FORMAT_RGBA_8888;
        break;
    case PIXEL_FORMAT_OPAQUE:
        format = PIXEL_FORMAT_RGBX_8888;
        break;
    }

    *outLayer = new Layer(this, client, name, w, h, flags);
    //到这里！！！好像就初始化消费者Buffer的宽和高
    status_t err = (*outLayer)->setBuffers(w, h, format, flags); 
    if (err == NO_ERROR) {
        *handle = (*outLayer)->getHandle();//获取 handle
        *gbp = (*outLayer)->getProducer(); //获取 生产者

    }

    ALOGE_IF(err, "createNormalLayer() failed (%s)", strerror(-err));
    return err;
}


//这个就直接new一个Handle，后面应该是要用来回调
sp<IBinder> Layer::getHandle() {
    Mutex::Autolock _l(mLock);

    LOG_ALWAYS_FATAL_IF(mHasSurface,
            "Layer::getHandle() has already been called");

    mHasSurface = true;

    return new Handle(mFlinger, this);
}

~~~

我们看看标记H处的addClientLayer(handle)做了什么，因为他传了这个Handle和layer过去

~~~java
status_t SurfaceFlinger::addClientLayer(const sp<Client>& client,
        const sp<IBinder>& handle,
        const sp<IGraphicBufferProducer>& gbc,
        const sp<Layer>& lbc)
{
    // add this layer to the current state list
    {
        Mutex::Autolock _l(mStateLock);
        if (mCurrentState.layersSortedByZ.size() >= MAX_LAYERS) {
            return NO_MEMORY;
        }
        //将当前显示层添加到z轴！！！
        mCurrentState.layersSortedByZ.add(lbc);
        //把创建的Layer加入这个GBp集合里面
        mGraphicBufferProducerList.add(IInterface::asBinder(gbc));
    }

    // attach this layer to the client
    //这个Client就是前面之前生成的Client，
    client->attachLayer(handle, lbc);

    return NO_ERROR;
}
~~~

我们现在看看attachLayer，做了什么

~~~java
//media/ba/sd/aosp/frameworks/native/services/surfaceflinger/Client.h
void Client::attachLayer(const sp<IBinder>& handle, const sp<Layer>& layer)
{
    Mutex::Autolock _l(mLock);
    mLayers.add(handle, layer);
}

~~~

这里就是加入到Client里面的集合，就是为了方便管理.和回调。

那SurfaceControl就初始化成功了，但是其实我们还有很多的疑问：

- 生产者生产完后是怎么通知消费者的？
- 生产者和消费者用的GraphicBuffer是怎么样的？
- SurfaceFlinger拿到GraphicBuffer后怎么处理？
- 处理好后怎么给Linux的FrameBuffer，而FrameBuffer又是什么？

下面我们就看看前两个,从消费者的构造函数入手

再来看Consumer，BufferLayerConsumer继承ConsumerBase。BufferLayerConsumer的构造函数中，主要是一些变量的初始化，主要是ConsumerBase的构造函数：

~~~c
// frameworks/native/libs/gui/ConsumerBase.cpp

ConsumerBase::ConsumerBase(const sp<IGraphicBufferConsumer>& bufferQueue, bool controlledByApp) :
        mAbandoned(false),
        mConsumer(bufferQueue),
        mPrevFinalReleaseFence(Fence::NO_FENCE) {
    // Choose a name using the PID and a process-unique ID.
    mName = String8::format("unnamed-%d-%d", getpid(), createProcessUniqueId());

    // Note that we can't create an sp<...>(this) in a ctor that will not keep a
    // reference once the ctor ends, as that would cause the refcount of 'this'
    // dropping to 0 at the end of the ctor.  Since all we need is a wp<...>
    // that's what we create.
            
      //创建一个回调，而且是自己！！！！
    wp<ConsumerListener> listener = static_cast<ConsumerListener*>(this);
          //向BufferQueue设置监听
    sp<IConsumerListener> proxy = new BufferQueue::ProxyConsumerListener(listener);
     status_t err = mConsumer->consumerConnect(proxy, controlledByApp);
    if (err != NO_ERROR) {
        CB_LOGE("ConsumerBase: error connecting to BufferQueue: %s (%d)",
                strerror(-err), err);
    } else {
        mConsumer->setConsumerName(mName);
    }
}
~~~

这样一来！！我们的消费者就和bufferQueue有个监听回调了，一说到消费者的回调突然想起前面不是也和SurfaceFlinger设置过？？

~~~c
//media/ba/sd/aosp/frameworks/native/services/surfaceflinger/Layer.cpp
void Layer::onFirstRef() {
    
  ...
 	sp<IGraphicBufferProducer> producer;
  
    sp<IGraphicBufferConsumer> consumer;
    
 ....
   
   
    mSurfaceFlingerConsumer = new SurfaceFlingerConsumer(consumer, mTextureName,
            this);
    mSurfaceFlingerConsumer->setConsumerUsageBits(getEffectiveUsage(0));
   //这里！！！！！！！！！
      mSurfaceFlingerConsumer->setContentsChangedListener(this);
    mSurfaceFlingerConsumer->setName(mName);

    ...
}
~~~

~~~c
void SurfaceFlingerConsumer::setContentsChangedListener(
        const wp<ContentsChangedListener>& listener) {
    //设置进去
    setFrameAvailableListener(listener);
    Mutex::Autolock lock(mMutex);
    mContentsChangedListener = listener;
}


~~~







































