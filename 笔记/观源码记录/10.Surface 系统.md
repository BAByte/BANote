[TOC]

# 10.Surface 系统



在看安卓开发艺术探索的时候就学习过Window和view和ViewRoot的关系，我们重温一下：

+ Window：Window是一个抽象基类，用于控制顶层窗口的外观和行为。做为顶层窗口它有什么特殊的职能呢？即绘制背景和标题栏、默认的按键处理等。window的按键事件来自于哪里呢？就是WMS，windown的真正实例是PhoneWindow。Window里面有个mWindowManager，mWindowManager的实现是LocalWindowMananager，为什么要这个WindowManager呢？他是用来创建VIewRoot以及和WMS交互的！

![image](http://wiki.jikexueyuan.com/project/deep-android-v1/images/chapter8/image003.png)

+ VIewRoot:就是我们布局他爸了，你一个界面里面的所有的VIew都归他管，具体你可以看看"安卓艺术开发探索"的笔记

今天我们的主角Surface在ViewRootImp里面初次露面，我们看看代码

~~~java
//home/ba/Android/Sdk/sources/android-25/android/view/ViewRootImpl.java
 //直接就给你new一个出来了。
    final Surface mSurface = new Surface();
~~~

surface到底和什么有关呢？和绘制有关！！我们在使用VIew的时候，绘制时都是调用onDraw方法，该方法的具体实现其实是：

~~~java
[-->ViewRoot.java]

private void draw(boolean fullRedrawNeeded) {

       Surface surface = mSurface;//mSurface是ViewRoot的成员变量

       ......

        Canvascanvas;

       try {

           int left = dirty.left;

           int top = dirty.top;

           int right = dirty.right;

           int bottom = dirty.bottom;

           //从mSurface中lock一块Canvas

           canvas = surface.lockCanvas(dirty);

           ......

           mView.draw(canvas);//调用DecorView的draw函数，canvas就是画布的意思啦！

           ......

           //unlock画布，屏幕上马上就会见到漂亮宝贝的长相了。

           surface.unlockCanvasAndPost(canvas);

        }

          ......

    }
~~~

哦！原来真正的画布其实不是canvas（canvas我们在“重温自定义VIew”系列笔记里面学习过）！而是Surface呀！我们看看官方一点的图：我们看左边的

![image](http://wiki.jikexueyuan.com/project/deep-android-v1/images/chapter8/image001.png)

安卓在绘制二维图形的时候走的是左边的过程，可以看到java层用的是view/canvas，但是最后其实是到surface绘制的，我们想啊，绘制的代码肯定不是在java层的，肯定在native的WMS中，这就意味着native层有着对应于java层的surface！我们看看时序图：

![image](http://wiki.jikexueyuan.com/project/deep-android-v1/images/chapter8/image007.png)

从时序图中可以看出：java层通过WindowManager和WMS打开了一次会话，然后当java层调用relayoutWindown()的时候,WMS将会从java层中调用copyFrom()方法拿到java层Surface实例的相关属性，然后在native层从新构造一个surface出来。然后就使用surface进行绘制，但是什么情况下会调用relayoutrelayoutWindown()方法呢？在初始化完VIewRoot后会调用setView给他设置View和布局属性，

~~~java
  public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {
  ...
       // Schedule the first layout -before- adding to the window
                // manager, to make sure we do the relayout before receiving
                // any other events from the system.
                requestLayout();//然后会调用这个方法
      ...
  }
~~~

~~~java
   @Override
    public void requestLayout() {
        if (!mHandlingLayoutInLayoutRequest) {
            checkThread();
            mLayoutRequested = true;
            scheduleTraversals();
        }
    }
~~~

~~~java
[-->ViewRoot.java]
public void handleMessage(Message msg) {

       switch (msg.what) {

        ......

       case DO_TRAVERSAL:

            ......

           performTraversals();//调用performTraversals函数,熟悉吧！！这个函数就是去刷新视图的意思。

......

           break;

       ......

}

}
~~~

~~~java
[-->ViewRoot.java]

private void performTraversals() {

 finalView host = mView;//还记得这mView吗？它就是DecorView喔

 

  booleaninitialized = false;

  booleancontentInsetsChanged = false;

  booleanvisibleInsetsChanged;

  try {

    relayoutResult= //①关键函数relayoutWindow

relayoutWindow(params, viewVisibility,insetsPending);

   }

......

draw(fullRedrawNeeded);// ②开始绘制

......

}
~~~

终于找到了！！那么我们知道调用了relayoutWindow后会和WMS进行通信，然后生成一个native层的surface，