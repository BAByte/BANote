[TOC]

# 10. Android 显示系统

安卓的显示系统！这可是非常复杂的一个系统，我们在以前有关于GUI的顶多就玩了下自定义VIew，而且在自定义VIew就学的够呛的了，今天我们不玩自定义View了！研究一下安卓系统是怎么管理和绘制Gui的！

# 从Activity的显示说起

一个应用的GUI的开始，当然是在第一个Activity(假设应用只有一个Activity)创建的时候，从创建进程到ActivityThread的handleLaunchActivity

~~~java
///media/ba/sd/aosp/frameworks/base/core/java/android/app/ActivityThread.java   
private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) {
       ...
        //这里就是去生成Activity，并且调用onCreate()方法
        Activity a = performLaunchActivity(r, customIntent);

        if (a != null) {
           ..
            //这里是调用Acitivty的onResume方法，我们等下再讲这里,
            handleResumeActivity(r.token, false, r.isForward,
                    !r.activity.mFinished && !r.startsNotResumed, r.lastProcessedSeq, reason);
        }

          ...
    }
~~~

看看performLaunchActivity方法

~~~java
///media/ba/sd/aosp/frameworks/base/core/java/android/app/ActivityThread.java

    private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
        
        Activity activity = null;
        try {
            //通过反射生成对应的Activity
            java.lang.ClassLoader cl = r.packageInfo.getClassLoader();
            activity = mInstrumentation.newActivity(
                    cl, component.getClassName(), r.intent);
            StrictMode.incrementExpectedActivityCount(activity.getClass());
            r.intent.setExtrasClassLoader(cl);
            r.intent.prepareToEnterProcess();
            if (r.state != null) {
                r.state.setClassLoader(cl);
            }
        } catch (Exception e) {
            if (!mInstrumentation.onException(activity, e)) {
                throw new RuntimeException(
                    "Unable to instantiate activity " + component
                    + ": " + e.toString(), e);
            }
        }

        try {
            //生成Application
            Application app = r.packageInfo.makeApplication(false, mInstrumentation);

            if (localLOGV) Slog.v(TAG, "Performing launch of " + r);
            if (localLOGV) Slog.v(
                    TAG, r + ": app=" + app
                    + ", appName=" + app.getPackageName()
                    + ", pkg=" + r.packageInfo.getPackageName()
                    + ", comp=" + r.intent.getComponent().toShortString()
                    + ", dir=" + r.packageInfo.getAppDir());

            if (activity != null) {
                //生成BaseContext
                Context appContext = createBaseContextForActivity(r, activity);
                CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());
                Configuration config = new Configuration(mCompatConfiguration);
                if (r.overrideConfig != null) {
                    config.updateFrom(r.overrideConfig);
                }
                if (DEBUG_CONFIGURATION) Slog.v(TAG, "Launching activity "
                        + r.activityInfo.name + " with config " + config);
                Window window = null;
                if (r.mPendingRemoveWindow != null && r.mPreserveWindow) {
                    window = r.mPendingRemoveWindow;
                    r.mPendingRemoveWindow = null;
                    r.mPendingRemoveWindowManager = null;
                }
                
                //给这个Acitivity初始化一些该有的信息，这里很重要，标记为A
                activity.attach(appContext, this, getInstrumentation(), r.token,
                        r.ident, app, r.intent, r.activityInfo, title, r.parent,
                        r.embeddedID, r.lastNonConfigurationInstances, config,
                        r.referrer, r.voiceInteractor, window);
                ...
                
                 //下面就是回调Activity的的onCreate方法
                if (r.isPersistable()) {
                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);
                } else {
                    mInstrumentation.callActivityOnCreate(activity, r.state);
                }
                if (!activity.mCalled) {
                    throw new SuperNotCalledException(
                        "Activity " + r.intent.getComponent().toShortString() +
                        " did not call through to super.onCreate()");
                }
              ...

        return activity;
    }

~~~

我们知道onCreate方法里面最重要的就是setContentView！！！这里我们还知道，Activity的生命周期的onCreate方法并不是把界面显示出来，而是去生成属于这个Activity的所有View对象并且设置一个标题栏，这里是装饰模式，我们看下去（在以前的笔记中是有说过这个东西的，本来不打算说下去的，但是没有办法。不说怕你想不通）。

~~~java
///home/ba/Android/Sdk/sources/android-25/android/app/Activity.java 
public void setContentView(@LayoutRes int layoutResID) {
        getWindow().setContentView(layoutResID);
        initWindowDecorActionBar();
    }

 public Window getWindow() {
        return mWindow;
    }
~~~

可以看到我们的给Activity设置的VIew是设置在了这个mWindow中，这个mWindow是什么？以前就说过他具体实现是：PhoneWindow！

鉴于有些人可能搞不懂window和VIew的关系：

+ window是一个抽象基类，用于控制顶层窗口的外观和行为。外观指的是我们setContentView进去后是没有actionBar的，window会帮我们搞定。行为是指：我们的View虽然都有分发触摸事件的方法，但在以前我们一直说是系统调用这些方法，那里面的事件哪里来的？触摸事件肯定是来自系统的其他进程：WMS，WMS是去找符合触摸位置等条件的window，然后给对应的window，然后给window里面的ViewRootImp，然后VIewRootImp再分发到对应的view上的。
+ ViewRootImp以前也讲过，他不是View的子类，他是用来管理一个Window下的所有View。一个WIndow的所有VIew的生命周期都是由ViewRootImp管理的
+ view是一个视图单位，占据着屏幕的一块区域，用来绘制对应的内容。

我们看看这个Window是怎么生成的,不好找，全局搜索后发现在attach方法中，我们回到上面的标记A，也就是Acitivity生成的地方，在这里调用了attach：

~~~java
//home/ba/Android/Sdk/sources/android-25/android/app/Activity.java 
    private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
    ...
          
                //给这个Acitivity初始化一些该有的信息，这里很重要
                activity.attach(appContext, this, getInstrumentation(), r.token,
                        r.ident, app, r.intent, r.activityInfo, title, r.parent,
                        r.embeddedID, r.lastNonConfigurationInstances, config,
                        r.referrer, r.voiceInteractor, window);
    ...
    }
~~~

看看这个attach方法里面有什么

~~~java
//home/ba/Android/Sdk/sources/android-25/android/app/Activity.java、
final void attach(Context context, ActivityThread aThread,
            Instrumentation instr, IBinder token, int ident,
            Application application, Intent intent, ActivityInfo info,
            CharSequence title, Activity parent, String id,
            NonConfigurationInstances lastNonConfigurationInstances,
            Configuration config, String referrer, IVoiceInteractor voiceInteractor,
            Window window) {
        attachBaseContext(context);

        mFragments.attachHost(null /*parent*/);

    ///看这里！！
        mWindow = new PhoneWindow(this, window);
    ...
            mWindow.setWindowManager(
                (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),
                mToken, mComponent.flattenToString(),
                (info.flags & ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);
        if (mParent != null) {
            mWindow.setContainer(mParent.getWindow());
        }
        mWindowManager = mWindow.getWindowManager();
        mCurrentConfig = config;
}
~~~

是PhoneWindow吧！但是他还生成了一个WindowManage,然后set进去了？？

~~~java
 public void setWindowManager(WindowManager wm, IBinder appToken, String appName,
            boolean hardwareAccelerated) {
        mAppToken = appToken;
        mAppName = appName;
        mHardwareAccelerated = hardwareAccelerated
                || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, false);
        if (wm == null) {
            wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
        }
        mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this);
    }
~~~

哦！可以看到生成了一个WindowManagerImpl，然后就结束了！！但是这个名字一看就很重要啊！说不定后面有大用，我们先标记为B，我们回到SetContentVIew，现在应该看PhoneWindow的setContentVIew了

~~~java
///media/ba/sd/aosp/frameworks/base/core/java/com/android/internal/policy/PhoneWindow.java 
public void setContentView(int layoutResID) {
        // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window
        // decor, when theme attributes and the like are crystalized. Do not check the feature
        // before this happens.mContentParent是null，为什么叫setContentVIew现在明白了吗？
        if (mContentParent == null) {
            //看这里！！！！
            installDecor();
        } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
            mContentParent.removeAllViews();
        }

       ...
    }


 private void installDecor() {
        mForceDecorInstall = false;
        if (mDecor == null) {
            //生成DecorVIew，基类是FramLayout！！！
            mDecor = generateDecor(-1);
            mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);
            mDecor.setIsRootNamespace(true);
            if (!mInvalidatePanelMenuPosted && mInvalidatePanelMenuFeatures != 0) {
                mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);
            }
        } else {
            mDecor.setWindow(this);
        }
        if (mContentParent == null) {
            //然后生成ContentParent，这里其实就是去设置actionBar和WIndow的Style!!
            //具体代码我就不给了。
            mContentParent = generateLayout(mDecor);
    ...
  }
     
     
~~~

我们现在先总结一下：

![image](http://wiki.jikexueyuan.com/project/deep-android-v1/images/chapter8/image004.png)

这张图很完美的看出我们前面在讲的是什么：

+ 我们调用了Activity的setContentVIew后会生成PhoneWindow，和WindowManagerImpl，
+ 然后PhoneWindow会去生成DecorVIew。
+ DecorVIew就是包括了标题栏和我们设置的View！

到这里，Acitivity的onCreate就结束了，我们只是生成了DecorView，我们并没有去绘制这些VIew，这里的所有VIew都是用LayoutInflator生成的！按照Activity的生命周期，我们应该到onResume这个过程了！回到ActivityThread

~~~java
///media/ba/sd/aosp/frameworks/base/core/java/android/app/ActivityThread.java   
private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) {
       ...
        //这里就是去生成Activity，并且调用onCreate()方法
        Activity a = performLaunchActivity(r, customIntent);

        if (a != null) {
           ..
            //这里是调用Acitivty的onResume方法，我们等下再讲这里,我们现在走到了这里！
            handleResumeActivity(r.token, false, r.isForward,
                    !r.activity.mFinished && !r.startsNotResumed, r.lastProcessedSeq, reason);
        }

          ...
    }
~~~

~~~java
///media/ba/sd/aosp/frameworks/base/core/java/android/app/ActivityThread.java   
    final void handleResumeActivity(IBinder token,
            boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) {
        ActivityClientRecord r = mActivities.get(token);
        if (!checkAndUpdateLifecycleSeq(seq, r, "resumeActivity")) {
            return;
        }

        // If we are getting ready to gc after going to the background, well
        // we are back active so skip it.
        unscheduleGcIdler();
        mSomeActivitiesChanged = true;

        //调用Activity的onResume方法
        r = performResumeActivity(token, clearHide, reason);

        if (r != null) {
            //拿到Activity
            final Activity a = r.activity;

       ...

            final int forwardBit = isForward ?
                    WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;

        
            if (r.window == null && !a.mFinished && willBeVisible) {
                //这个Window就是前面生成的PhoneWindow
                r.window = r.activity.getWindow();
                //这里就是我们前面生成的DecorVIew
                View decor = r.window.getDecorView();
                decor.setVisibility(View.INVISIBLE);
                //这个就是我们前面生成的WindowManagerImpl
                ViewManager wm = a.getWindowManager();
               
                
               ....
                   
                 //看这里！！是调用我们的WindowManagerImpl，然后addView！！！
                if (a.mVisibleFromClient && !a.mWindowAdded) {
                    a.mWindowAdded = true;
                    wm.addView(decor, l);
                }
                ...

            }
~~~

在标记B处，就出现了WindowManagerImpl！就说他很重要吧！！终于用到了！！我们看看他的addVIew方法

~~~java
///home/ba/Android/Sdk/sources/android-25/android/view/WindowManagerImpl.java 
@Override
    public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {
        applyDefaultToken(params);
        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);
    }

~~~

跑到了这个mGlobal去了。。。。

~~~java
///home/ba/Android/Sdk/sources/android-25/android/view/WindowManagerImpl.java   
/*

提供与系统窗口管理器的低级通信
  与任何特定上下文无关的操作。
 
  该类仅在内部用于实现全局函数
  调用者已经知道显示和相关的兼容性信息
  为了操作。在大多数情况下，您应该使用{@link WindowManager}
  因为它受到上下文的约束。
*/
private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();
~~~

还是个单例！那就看他的addVIew方法！

~~~java

///home/ba/Android/Sdk/sources/android-25/android/view/WindowManagerGlobal.java
    public void addView(View view, ViewGroup.LayoutParams params,
            Display display, Window parentWindow) {
      ...


        ViewRootImpl root;
        View panelParentView = null;

     /...

         //这里出现了VIewRootImp！！
            root = new ViewRootImpl(view.getContext(), display);

            view.setLayoutParams(wparams);

        
    
            mViews.add(view);
            mRoots.add(root);
            mParams.add(wparams);
        }

        // do this last because it fires off messages to start doing things
        try {
            //重点来了！！！这里把我们前面生成的DecorView设置进VIewRootImp了！！
            root.setView(view, wparams, panelParentView);
        } 
...
    }
~~~

分析到这里，我们终于到了要调用VIew的生命周期的方法了,我们看看ViewRootImp的setView方法

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java
public void setView(View view, WindowManager.LayoutParamsattrs,

                        View panelParentView){//第一个参数view是DecorView

      ......

       mView= view;//保存这个view

       synchronized (this) {

           requestLayout(); //待会先看看这个。

               try {

                    //调用IWindowSession的add函数，第一个参数是mWindow

                    res =sWindowSession.add(mWindow, mWindowAttributes,

                           getHostVisibility(), mAttachInfo.mContentInsets);

               }

          ......

}
~~~

ViewRoot的setView函数做了三件事：

·  保存传入的view参数为mView，这个mView指向PhoneWindow的DecorView。

·  调用requestLayout。

·  调用IWindowSession的add函数，这是一个跨进程的Binder通信，第一个参数是mWindow，它是W类型，从IWindow.stub派生。

我们先看看requestLayout做了什么

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java  
@Override
    public void requestLayout() {
        if (!mHandlingLayoutInLayoutRequest) {
            //检查当前线程是否是UI线程！！！
            checkThread();
            mLayoutRequested = true;
            //是不是就去绘制了？？
            scheduleTraversals();
        }
    }


    void scheduleTraversals() {
        if (!mTraversalScheduled) {
            mTraversalScheduled = true;
            //发了个消息,所以我们看看mTraversalRunnable写了什么
            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();
            mChoreographer.postCallback(
                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);
            ...
        }
    }

 final class TraversalRunnable implements Runnable {
        @Override
        public void run() {
            //继续
            doTraversal();
        }
    }

   void doTraversal() {
        if (mTraversalScheduled) {
            mTraversalScheduled = false;
            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);

            if (mProfile) {
                Debug.startMethodTracing("ViewAncestor");
            }

            //看这个！！！这是我们熟悉的方法啊！！这能触发绘制！！！
            performTraversals();

            if (mProfile) {
                Debug.stopMethodTracing();
                mProfile = false;
            }
        }
    }

 private void performTraversals() {      
     //这就是我们的DecorVIew
        final View host = mView;
     
     try {

    	relayoutResult= //①关键函数relayoutWindow

		relayoutWindow(params, viewVisibility,insetsPending);

   }

......

		performDraw()// ②开始绘制
 }

~~~

我们先看performDraw方法做了什么

~~~java

 private void performDraw() {
          ....
        try {
           //这个！！！
            draw(fullRedrawNeeded);
        } finally {
            mIsDrawing = false;
            Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        }
     ...
 }


private void draw(boolean fullRedrawNeeded) {
        Surface surface = mSurface;
        if (!surface.isValid()) {
            return;
        }
    ...

        //这个！！！
          if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) {
                    return;
         }
    ...

     }


   private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff,
            boolean scalingRequired, Rect dirty) {

        // Draw with software renderer.
        final Canvas canvas;
        try {
         
            ...

            //锁住
            canvas = mSurface.lockCanvas(dirty);

      ....
          		//绘制
                mView.draw(canvas);

       ...
            
        } finally {
            try {
                //解锁
                surface.unlockCanvasAndPost(canvas);
            }
            ...
        }
        return true;
    }

~~~



