[TOC]

# 10. Android 显示系统

安卓的显示系统！这可是非常复杂的一个系统，我们在以前有关于GUI的顶多就玩了下自定义VIew，而且在自定义VIew就学的够呛的了，今天我们不玩自定义View了！研究一下安卓系统是怎么管理和绘制Gui的！

## 从Activity的显示说起

一个应用的GUI的开始，当然是在第一个Activity(假设应用只有一个Activity)创建的时候，从创建进程到ActivityThread的handleLaunchActivity

~~~java
///media/ba/sd/aosp/frameworks/base/core/java/android/app/ActivityThread.java   
private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) {
       ...
        //这里就是去生成Activity，并且调用onCreate()方法
        Activity a = performLaunchActivity(r, customIntent);

        if (a != null) {
           ..
            //这里是调用Acitivty的onResume方法，我们等下再讲这里,
            handleResumeActivity(r.token, false, r.isForward,
                    !r.activity.mFinished && !r.startsNotResumed, r.lastProcessedSeq, reason);
        }

          ...
    }
~~~

看看performLaunchActivity方法

~~~java
///media/ba/sd/aosp/frameworks/base/core/java/android/app/ActivityThread.java

    private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
        
        Activity activity = null;
        try {
            //通过反射生成对应的Activity
            java.lang.ClassLoader cl = r.packageInfo.getClassLoader();
            activity = mInstrumentation.newActivity(
                    cl, component.getClassName(), r.intent);
            StrictMode.incrementExpectedActivityCount(activity.getClass());
            r.intent.setExtrasClassLoader(cl);
            r.intent.prepareToEnterProcess();
            if (r.state != null) {
                r.state.setClassLoader(cl);
            }
        } catch (Exception e) {
            if (!mInstrumentation.onException(activity, e)) {
                throw new RuntimeException(
                    "Unable to instantiate activity " + component
                    + ": " + e.toString(), e);
            }
        }

        try {
            //生成Application
            Application app = r.packageInfo.makeApplication(false, mInstrumentation);

            if (localLOGV) Slog.v(TAG, "Performing launch of " + r);
            if (localLOGV) Slog.v(
                    TAG, r + ": app=" + app
                    + ", appName=" + app.getPackageName()
                    + ", pkg=" + r.packageInfo.getPackageName()
                    + ", comp=" + r.intent.getComponent().toShortString()
                    + ", dir=" + r.packageInfo.getAppDir());

            if (activity != null) {
                //生成BaseContext
                Context appContext = createBaseContextForActivity(r, activity);
                CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());
                Configuration config = new Configuration(mCompatConfiguration);
                if (r.overrideConfig != null) {
                    config.updateFrom(r.overrideConfig);
                }
                if (DEBUG_CONFIGURATION) Slog.v(TAG, "Launching activity "
                        + r.activityInfo.name + " with config " + config);
                Window window = null;
                if (r.mPendingRemoveWindow != null && r.mPreserveWindow) {
                    window = r.mPendingRemoveWindow;
                    r.mPendingRemoveWindow = null;
                    r.mPendingRemoveWindowManager = null;
                }
                
                //给这个Acitivity初始化一些该有的信息，这里很重要，标记为A
                activity.attach(appContext, this, getInstrumentation(), r.token,
                        r.ident, app, r.intent, r.activityInfo, title, r.parent,
                        r.embeddedID, r.lastNonConfigurationInstances, config,
                        r.referrer, r.voiceInteractor, window);
                ...
                
                 //下面就是回调Activity的的onCreate方法
                if (r.isPersistable()) {
                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);
                } else {
                    mInstrumentation.callActivityOnCreate(activity, r.state);
                }
                if (!activity.mCalled) {
                    throw new SuperNotCalledException(
                        "Activity " + r.intent.getComponent().toShortString() +
                        " did not call through to super.onCreate()");
                }
              ...

        return activity;
    }

~~~

我们知道onCreate方法里面最重要的就是setContentView！！！这里我们还知道，Activity的生命周期的onCreate方法并不是把界面显示出来，而是去生成属于这个Activity的所有View对象并且设置一个标题栏，这里是装饰模式，我们看下去（在以前的笔记中是有说过这个东西的，本来不打算说下去的，但是没有办法。不说怕你想不通）。

~~~java
///home/ba/Android/Sdk/sources/android-25/android/app/Activity.java 
public void setContentView(@LayoutRes int layoutResID) {
        getWindow().setContentView(layoutResID);
        initWindowDecorActionBar();
    }

 public Window getWindow() {
        return mWindow;
    }
~~~

可以看到我们的给Activity设置的VIew是设置在了这个mWindow中，这个mWindow是什么？以前就说过他具体实现是：PhoneWindow！

鉴于有些人可能搞不懂window和VIew的关系：

+ window是一个抽象基类，用于控制顶层窗口的外观和行为。外观指的是我们setContentView进去后是没有actionBar的，window会帮我们搞定。行为是指：我们的View虽然都有分发触摸事件的方法，但在以前我们一直说是系统调用这些方法，那里面的事件哪里来的？触摸事件肯定是来自系统的其他进程：WMS，WMS是去找符合触摸位置等条件的window，然后给对应的window，然后给window里面的ViewRootImp，然后VIewRootImp再分发到对应的view上的。
+ ViewRootImp以前也讲过，他不是View的子类，他是用来管理一个Window下的所有View。一个WIndow的所有VIew的生命周期都是由ViewRootImp管理的
+ view是一个视图单位，占据着屏幕的一块区域，用来绘制对应的内容。

我们看看这个Window是怎么生成的,不好找，全局搜索后发现在attach方法中，我们回到上面的标记A，也就是Acitivity生成的地方，在这里调用了attach：

~~~java
//home/ba/Android/Sdk/sources/android-25/android/app/Activity.java 
    private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
    ...
          
                //给这个Acitivity初始化一些该有的信息，这里很重要
                activity.attach(appContext, this, getInstrumentation(), r.token,
                        r.ident, app, r.intent, r.activityInfo, title, r.parent,
                        r.embeddedID, r.lastNonConfigurationInstances, config,
                        r.referrer, r.voiceInteractor, window);
    ...
    }
~~~

看看这个attach方法里面有什么

~~~java
//home/ba/Android/Sdk/sources/android-25/android/app/Activity.java、
final void attach(Context context, ActivityThread aThread,
            Instrumentation instr, IBinder token, int ident,
            Application application, Intent intent, ActivityInfo info,
            CharSequence title, Activity parent, String id,
            NonConfigurationInstances lastNonConfigurationInstances,
            Configuration config, String referrer, IVoiceInteractor voiceInteractor,
            Window window) {
        attachBaseContext(context);

        mFragments.attachHost(null /*parent*/);

    ///看这里！！
        mWindow = new PhoneWindow(this, window);
    ...
            mWindow.setWindowManager(
                (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),
                mToken, mComponent.flattenToString(),
                (info.flags & ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);
        if (mParent != null) {
            mWindow.setContainer(mParent.getWindow());
        }
        mWindowManager = mWindow.getWindowManager();
        mCurrentConfig = config;
}
~~~

是PhoneWindow吧！但是他还生成了一个WindowManage,然后set进去了？？

~~~java
 public void setWindowManager(WindowManager wm, IBinder appToken, String appName,
            boolean hardwareAccelerated) {
        mAppToken = appToken;
        mAppName = appName;
        mHardwareAccelerated = hardwareAccelerated
                || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, false);
        if (wm == null) {
            wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
        }
        mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this);
    }
~~~

哦！可以看到生成了一个WindowManagerImpl，然后就结束了！！但是这个名字一看就很重要啊！说不定后面有大用，我们先标记为B，我们回到SetContentVIew，现在应该看PhoneWindow的setContentVIew了

~~~java
///media/ba/sd/aosp/frameworks/base/core/java/com/android/internal/policy/PhoneWindow.java 
public void setContentView(int layoutResID) {
        // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window
        // decor, when theme attributes and the like are crystalized. Do not check the feature
        // before this happens.mContentParent是null，为什么叫setContentVIew现在明白了吗？
        if (mContentParent == null) {
            //看这里！！！！
            installDecor();
        } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
            mContentParent.removeAllViews();
        }

       ...
    }


 private void installDecor() {
        mForceDecorInstall = false;
        if (mDecor == null) {
            //生成DecorVIew，基类是FramLayout！！！
            mDecor = generateDecor(-1);
            mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);
            mDecor.setIsRootNamespace(true);
            if (!mInvalidatePanelMenuPosted && mInvalidatePanelMenuFeatures != 0) {
                mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);
            }
        } else {
            mDecor.setWindow(this);
        }
        if (mContentParent == null) {
            //然后生成ContentParent，这里其实就是去设置actionBar和WIndow的Style!!
            //具体代码我就不给了。
            mContentParent = generateLayout(mDecor);
    ...
  }
     
     
~~~

我们现在先总结一下：

![image](http://wiki.jikexueyuan.com/project/deep-android-v1/images/chapter8/image004.png)

这张图很完美的看出我们前面在讲的是什么：

+ 我们调用了Activity的setContentVIew后会生成PhoneWindow，和WindowManagerImpl，
+ 然后PhoneWindow会去生成DecorVIew。
+ DecorVIew就是包括了标题栏和我们设置的View！

到这里，Acitivity的onCreate就结束了，我们只是生成了DecorView，我们并没有去绘制这些VIew，这里的所有VIew都是用LayoutInflator生成的！按照Activity的生命周期，我们应该到onResume这个过程了！回到ActivityThread

~~~java
///media/ba/sd/aosp/frameworks/base/core/java/android/app/ActivityThread.java   
private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) {
       ...
        //这里就是去生成Activity，并且调用onCreate()方法
        Activity a = performLaunchActivity(r, customIntent);

        if (a != null) {
           ..
            //这里是调用Acitivty的onResume方法，我们等下再讲这里,我们现在走到了这里！
            handleResumeActivity(r.token, false, r.isForward,
                    !r.activity.mFinished && !r.startsNotResumed, r.lastProcessedSeq, reason);
        }

          ...
    }
~~~

~~~java
///media/ba/sd/aosp/frameworks/base/core/java/android/app/ActivityThread.java   
    final void handleResumeActivity(IBinder token,
            boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) {
        ActivityClientRecord r = mActivities.get(token);
        if (!checkAndUpdateLifecycleSeq(seq, r, "resumeActivity")) {
            return;
        }

        // If we are getting ready to gc after going to the background, well
        // we are back active so skip it.
        unscheduleGcIdler();
        mSomeActivitiesChanged = true;

        //调用Activity的onResume方法
        r = performResumeActivity(token, clearHide, reason);

        if (r != null) {
            //拿到Activity
            final Activity a = r.activity;

       ...

            final int forwardBit = isForward ?
                    WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;

        
            if (r.window == null && !a.mFinished && willBeVisible) {
                //这个Window就是前面生成的PhoneWindow
                r.window = r.activity.getWindow();
                //这里就是我们前面生成的DecorVIew
                View decor = r.window.getDecorView();
                decor.setVisibility(View.INVISIBLE);
                //这个就是我们前面生成的WindowManagerImpl
                ViewManager wm = a.getWindowManager();
               
                
               ....
                   
                 //看这里！！是调用我们的WindowManagerImpl，然后addView！！！
                if (a.mVisibleFromClient && !a.mWindowAdded) {
                    a.mWindowAdded = true;
                    wm.addView(decor, l);
                }
                ...

            }
~~~

在标记B处，就出现了WindowManagerImpl！就说他很重要吧！！终于用到了！！我们看看他的addVIew方法

~~~java
///home/ba/Android/Sdk/sources/android-25/android/view/WindowManagerImpl.java 
@Override
    public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {
        applyDefaultToken(params);
        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);
    }

~~~

跑到了这个mGlobal去了。。。。

~~~java
///home/ba/Android/Sdk/sources/android-25/android/view/WindowManagerImpl.java   
/*

提供与系统窗口管理器的低级通信
  与任何特定上下文无关的操作。
 
  该类仅在内部用于实现全局函数
  调用者已经知道显示和相关的兼容性信息
  为了操作。在大多数情况下，您应该使用{@link WindowManager}
  因为它受到上下文的约束。
*/
private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();
~~~

还是个单例！那就看他的addVIew方法！

~~~java

///home/ba/Android/Sdk/sources/android-25/android/view/WindowManagerGlobal.java
    public void addView(View view, ViewGroup.LayoutParams params,
            Display display, Window parentWindow) {
      ...


        ViewRootImpl root;
        View panelParentView = null;

     /...

         //这里出现了VIewRootImp！！
            root = new ViewRootImpl(view.getContext(), display);

            view.setLayoutParams(wparams);

        
    
            mViews.add(view);
            mRoots.add(root);
            mParams.add(wparams);
        }

        // do this last because it fires off messages to start doing things
        try {
            //重点来了！！！这里把我们前面生成的DecorView设置进VIewRootImp了！！
            root.setView(view, wparams, panelParentView);
        } 
...
    }
~~~

分析到这里，我们终于到了要调用VIew的生命周期的方法了,我们看看ViewRootImp的setView方法

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java
public void setView(View view, WindowManager.LayoutParamsattrs,

                        View panelParentView){//第一个参数view是DecorView

      ......

       mView= view;//保存这个view

       synchronized (this) {

           requestLayout(); //待会先看看这个。

               try {

                    //调用IWindowSession的addToDisplay函数，第一个参数是mWindow

                 res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,
                            getHostVisibility(), mDisplay.getDisplayId(),
                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,
                            mAttachInfo.mOutsets, mInputChannel);

               }
           
          ......

}
~~~

ViewRoot的setView函数做了三件事：

·  保存传入的view参数为mView，这个mView指向PhoneWindow的DecorView。

·  调用requestLayout。

·  调用IWindowSession的addToDisplay函数，这是一个跨进程的Binder通信，第一个参数是mWindow，它是W类型，从IWindow.stub派生。

## 熟悉的绘制流程

我们先看看requestLayout做了什么

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java  
@Override
    public void requestLayout() {
        if (!mHandlingLayoutInLayoutRequest) {
            //检查当前线程是否是UI线程！！！
            checkThread();
            mLayoutRequested = true;
            //是不是就去绘制了？？
            scheduleTraversals();
        }
    }


    void scheduleTraversals() {
        if (!mTraversalScheduled) {
            mTraversalScheduled = true;
            //发了个消息,所以我们看看mTraversalRunnable写了什么
            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();
            mChoreographer.postCallback(
                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);
            ...
        }
    }

 final class TraversalRunnable implements Runnable {
        @Override
        public void run() {
            //继续
            doTraversal();
        }
    }

   void doTraversal() {
        if (mTraversalScheduled) {
            mTraversalScheduled = false;
            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);

            if (mProfile) {
                Debug.startMethodTracing("ViewAncestor");
            }

            //看这个！！！这是我们熟悉的方法啊！！这能触发绘制！！！
            performTraversals();

            if (mProfile) {
                Debug.stopMethodTracing();
                mProfile = false;
            }
        }
    }

 private void performTraversals() {      
     //这就是我们的DecorVIew
        final View host = mView;
     
     try {

    	relayoutResult= //①关键函数relayoutWindow，标记为G

		relayoutWindow(params, viewVisibility,insetsPending);
   }

......

		performDraw()// ②开始绘制
 }

~~~

我们先看performDraw方法做了什么

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java  
 private void performDraw() {
          ....
        try {
           //这个！！！
            draw(fullRedrawNeeded);
        } finally {
            mIsDrawing = false;
            Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        }
     ...
 }


private void draw(boolean fullRedrawNeeded) {
    	//surface????
        Surface surface = mSurface;
        if (!surface.isValid()) {
            return;
        }
    ...

        //这个！！！
          if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) {
                    return;
         }
    ...

     }


   private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff,
            boolean scalingRequired, Rect dirty) {

        // 看到这个的时候，虎躯一震！这不就是画布吗！！！！
        final Canvas canvas;
        try {
         
            ...

            //锁住
            canvas = mSurface.lockCanvas(dirty);

      ....
          		//绘制！！！
                mView.draw(canvas);

       ...
            
        } finally {
            try {
                //解锁
                surface.unlockCanvasAndPost(canvas);
            }
            ...
        }
        return true;
    }

~~~

我们很清楚的知道view.draw（）方法里面做了些什么，不就是“四大金刚”相互合作，这四大金刚是：

·  Bitmap：用于存储像素，也就是画布。可把它当做一块数据存储区域。

·  Canvas：用于记载画图的动作，比如画一个圆，画一个矩形等。Canvas类提供了这些基本的绘图函数。

·  Drawing primitive：绘图基元，例如矩形、圆、弧线、文本、图片等。

·  Paint：它用来描述绘画时使用的颜色、风格（如实线、虚线等）等。

在一般情况下，Canvas会封装一块Bitmap，而作图就是基于这块Bitmap的。前面说的画布，其实指的就是Canvas中的这块Bitmap。动动脑子想想，显示器这个硬件设备肯定不是java层去直接控制的，我们现在要研究的不是java层的那些个抽象方法调来调去，具体的绘制实现肯定在native层，一定要把它揪出来。

## Surface初现！

我们可以看到在调用view的draw之前，跑出来了一个surface！他的值来源于mSurface字段！！那这块Bitmap是不是就是由这个surface准备的？我们看看他的初始化

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java  
final Surface mSurface = new Surface();
~~~

看看surface的构造函数

~~~java
//home/ba/Android/Sdk/sources/android-25/android/view/Surface.java
//注意这个
 private final Canvas mCanvas = new CompatibleCanvas();
public Surface() {
    }
~~~

空的！！那还能咋办呀？只能看看他的lockCanvas方法干了些什么

~~~java
//home/ba/Android/Sdk/sources/android-25/android/view/Surface.java
public Canvas lockCanvas(Rect inOutDirty)
            throws Surface.OutOfResourcesException, IllegalArgumentException {
        synchronized (mLock) {
            checkNotReleasedLocked();
            if (mLockedObject != 0) {
                // Ideally, nativeLockCanvas() would throw in this situation and prevent the
                // double-lock, but that won't happen if mNativeObject was updated.  We can't
                // abandon the old mLockedObject because it might still be in use, so instead
                // we just refuse to re-lock the Surface.
                throw new IllegalArgumentException("Surface was already locked");
            }
            //是个JNI方法
            mLockedObject = nativeLockCanvas(mNativeObject, mCanvas, inOutDirty);
            //返回了CompatibleCanvas
            return mCanvas;
        }
    }
~~~

这个mCanvas的实际类型为CompatibleCanvas，可以看到调了个JNI函数，很激动吧！！终于看到有native的影子了！所以我们要找到注册的地方，但是我搜索了Serface类，没有调用init方法。但是！！注意看nativeLockCanvas方法传入的参数！mNativeObject！！这是什么？？

~~~java
//home/ba/Android/Sdk/sources/android-25/android/view/Surface.java
long mNativeObject; 
~~~

指针耶！说明这个东西的具体对象其实是在c++层！我们使用surfece的函数时候mNativeObject;都要作为参数传进去，那他是怎么来的?他的真正类型是什么？

~~~java
//home/ba/Android/Sdk/sources/android-25/android/view/Surface.java
public void copyFrom(SurfaceControl other) {
        if (other == null) {
            throw new IllegalArgumentException("other must not be null");
        }

     	//这里！！！！
        long surfaceControlPtr = other.mNativeObject;
        if (surfaceControlPtr == 0) {
            throw new NullPointerException(
                    "SurfaceControl native object is null. Are you using a released SurfaceControl?");
        }
        long newNativeObject = nativeCreateFromSurfaceControl(surfaceControlPtr);

        synchronized (mLock) {
            if (mNativeObject != 0) {
                nativeRelease(mNativeObject);
            }
            setNativeObjectLocked(newNativeObject);
        }
    }
~~~

这个copyFrom什么时候调用的？？我们在绘制之前，还调用了一个方法在标记G处：relayoutWindow()，他会不会就是去准备SurfaceControl这个对象？

~~~java
  private int relayoutWindow(WindowManager.LayoutParams params, int viewVisibility,
            boolean insetsPending) throws RemoteException {

       ...
         //注意看最后一个参数，mSurface！！！传进去的原因可能就是去方便调用Surface的方法，说不定就是copyFrom方法！
        int relayoutResult = mWindowSession.relayout(
                mWindow, mSeq, params,
                (int) (mView.getMeasuredWidth() * appScale + 0.5f),
                (int) (mView.getMeasuredHeight() * appScale + 0.5f),
                viewVisibility, insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : 0,
                mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets,
                mPendingStableInsets, mPendingOutsets, mPendingBackDropFrame, mPendingConfiguration,
                mSurface);

        mPendingAlwaysConsumeNavBar =
                (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_CONSUME_ALWAYS_NAV_BAR) != 0;

      ...
        return relayoutResult;
    }
~~~

这个mWindowSession又是什么东西？？到目前为止已经出现了两次进程通信了！！!在VIewRootImp的setVIew方法出现了一次，在relayoutWindow又出现了一次。

## 蛛丝马迹

我们回到ViewRootImp的构造函数仔细看看

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java    
public ViewRootImpl(Context context, Display display) {
      ...
        mWindowSession = WindowManagerGlobal.getWindowSession();
      ...
        mWindow = new W(this);
      
        ...
     
    }

~~~

我们先看getWindowSession

~~~java
//home/ba/Android/Sdk/sources/android-25/android/view/WindowManagerGlobal.java    
public static IWindowSession getWindowSession() {
        synchronized (WindowManagerGlobal.class) {
            if (sWindowSession == null) {
                try {
                    InputMethodManager imm = InputMethodManager.getInstance();
                    IWindowManager windowManager = getWindowManagerService();
                    sWindowSession = windowManager.openSession(
                            new IWindowSessionCallback.Stub() {
                                @Override
                                public void onAnimatorScaleChanged(float scale) {
                                    ValueAnimator.setDurationScale(scale);
                                }
                            },
                            imm.getClient(), imm.getInputContext());
                } catch (RemoteException e) {
                    throw e.rethrowFromSystemServer();
                }
            }
            return sWindowSession;
        }
    }
~~~

可以看到这一次openSession的进程通信的目的端是WMS！我们看看这个openSession干了什么

~~~java
//media/ba/sd/aosp/frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java   
@Override
    public IWindowSession openSession(IWindowSessionCallback callback, IInputMethodClient client,
            IInputContext inputContext) {
        if (client == null) throw new IllegalArgumentException("null client");
        if (inputContext == null) throw new IllegalArgumentException("null inputContext");
        Session session = new Session(this, callback, client, inputContext);
        return session;
    }
~~~

说明了IWindowSession对象是WMS的Bn代理！！！那W类型的mWindow是什么？

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java    
static class W extends IWindow.Stub {
        private final WeakReference<ViewRootImpl> mViewAncestor;
        private final IWindowSession mWindowSession;

        W(ViewRootImpl viewAncestor) {
            mViewAncestor = new WeakReference<ViewRootImpl>(viewAncestor);
            mWindowSession = viewAncestor.mWindowSession;
        }
        
        ...
    }
~~~

嗯，他也是用来进程通信的！他的类型是IWindow，我们后面再讲这个IWindow。我们回到ViewRootImp的setVIew方法

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java
public void setView(View view, WindowManager.LayoutParamsattrs,

                        View panelParentView){//第一个参数view是DecorView

      ......

       mView= view;//保存这个view

       synchronized (this) {

           requestLayout(); 

               try {

                    //调用IWindowSession的add函数，第一个参数是mWindow

                       res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,
                            getHostVisibility(), mDisplay.getDisplayId(),
                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,
                            mAttachInfo.mOutsets, mInputChannel);

               }

          ......

}
~~~

我们先小结一下：

+ 我们在Activity的onCreate阶段进行了装饰我们通过setCotentView方法设置进去的VIew，生成DecorVIew
+ 然后为这个Activity绑定了一个PhoneWindow和WindowMananger
+ 然后在Activity的onResume阶段通过WindowMananger生成了一个ViewRootImp，用来管理我们的DecorVIew

- 我们new了ViewRootImp后就去和WMS进行了进程通信，其实就是先和WMS建立起联系，也算是初始化Binder通信
- 然后调用了VIewRootImp的setVIew方法，这里面做了两件事
- 从requestLayout走到了VIew的draw方法，但是在draw前，进行了一次进程通信，因为有个surface对象和绘制有着莫大的联系，但是我们查看Surface的代码发现他在里面就是一直调用native层的方法，这点我们知道绘制肯定是在native层，有意思的是，在Surface对象里面保存了一个叫做nativeObject的指针，他的类型不是对象，而是long。所以他的真实对象类型我们不清楚，当我们找他的来源时，停在了copyFrom方法，我们不知道谁去调用了这个方法，所以我们猜想是在draw前的进程通信那里做了手脚！！
- 在requestLayout()方法里面绘制完后我们又进行了一次进程通信sWindowSession.addToDisplay（）
- 所以我们现在卡在了两次进程通信！！只要搞明白这两次进程通信就能搞明白Surface到底和绘制有着什么关系。

## 两次进程通信

一个WIndow的作用就两个：行为和外观！  requestLayout(); 方法里面进行了VIew的draw，这里虽然进行了一次进程通信，但是我们相信这一次进程通信是绘制前的准备工作，毕竟他传入了个mSurface对象，所以我觉得requestLayout这里负责外观。

但是走完requestLayout的时候，就又进行了一次进程通信sWindowSession.add，这一次，我觉得是负责行为（也就是按键事件），因为他传入了个mWindow，要知道这个可是一个BInder对象，鉴于IWindowSession是WMS的BInder，所以类型为IWindow的mWindow很有可能就是给WMS回调的Bn端，为什么要回调？按键事件肯定是从WMS来的，WIndow只能等WMS告诉你！！！；

我们先分析sWindowSession.addToDisplay（）因为Surface才是重头戏，我们要放后面讲IWindowSession.aidl的具体实现是Session

~~~java
    //media/ba/sd/aosp/frameworks/base/services/core/java/com/android/server/wm/Session.java
   

    @Override
    public int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs,
            int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets,
            Rect outOutsets, InputChannel outInputChannel) {
        return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId,
                outContentInsets, outStableInsets, outOutsets, outInputChannel);
    }

~~~

可以看到，调用的是服务端的addWindow方法，也就是WMS的addWindow方法

~~~java
//media/ba/sd/aosp/frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java   
public int addWindow(Session session, IWindow client, int seq,
            WindowManager.LayoutParams attrs, int viewVisibility, int displayId,
            Rect outContentInsets, Rect outStableInsets, Rect outOutsets,
            InputChannel outInputChannel) {
      ...
        //创建一个WindowState
            WindowState win = new WindowState(this, session, client, token,
                    attachedWindow, appOp[0], seq, attrs, viewVisibility, displayContent);
           
           ...
        //这个很重要
            win.attach();
        ...

        return res;
    }
~~~



~~~java
//media/ba/sd/aosp/frameworks/base/services/core/java/com/android/server/wm/WindowState.java
void attach() {
        if (WindowManagerService.localLOGV) Slog.v(
            TAG, "Attaching " + this + " token=" + mToken
            + ", list=" + mToken.windows);
        mSession.windowAddedLocked();
    }
~~~

其实就是Session的windowAddedLocked方法

~~~java
//media/ba/sd/aosp/frameworks/base/services/core/java/com/android/server/wm/Session.java 
void windowAddedLocked() {
        if (mSurfaceSession == null) {
            if (WindowManagerService.localLOGV) Slog.v(
                TAG_WM, "First window added to " + this + ", creating SurfaceSession");
            //注意！！！这里
            mSurfaceSession = new SurfaceSession();
            if (SHOW_TRANSACTIONS) Slog.i(
                    TAG_WM, "  NEW SURFACE SESSION " + mSurfaceSession);
            mService.mSessions.add(this);
            if (mLastReportedAnimatorScale != mService.getCurrentAnimatorScale()) {
                mService.dispatchNewAnimatorScaleLocked(this);
            }
        }
        mNumWindow++;
    }
~~~

这里居然又生成了个SurfaceSession？？？懵逼！难道我们猜错了？？？这里不是按键处理？？莫急！你没看到是当为null的时候就创建吗？说明可能是为了第一次进来的时候创建的，我们看看其他地方有没创建SurfaceSession