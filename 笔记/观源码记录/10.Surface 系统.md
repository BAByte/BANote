[TOC]

# 10. Android 显示系统

安卓的显示系统！这可是非常复杂的一个系统，我们在以前有关于GUI的顶多就玩了下自定义VIew，我们其实只是在java层面不断的调用接口，去组织出我们想要的图像界面，一开始我对这个显示系统真的没有多大兴趣，因为我不知道学他的目的是什么，假设我们一直盲目的按照源码分析，我们能得到什么？就是实现的过程而已，而这个实现的过程那么的复杂，不断的从一个方法到另一个方法，我们从一个个方法中看到一个个对象，进而猜出整套的实现，但是！这个过程真的非常的枯燥！漂亮的架构那么多，漂亮的代码那么多，我一直盲目的花时间去看这些个源码，然而到最后却总是抽象成一段话，就结束了，而且这些好的架构你有时候能从其他地方看出来的，何必要从这么复杂的显示系统去看？？？我就觉得邓凡平老师的一句话非常有道理：我们看源码的时候，如果脱离了目的而去找实现，这不就是缘木求鱼吗？（你要是不明白我在说什么，要么是我表达的不好，要么是你看的源码不够多？？？）。就好比吃多了山珍海味，你才会开始挑食是一个道理吧。

所以说目的是非常重要的，我看这篇显示系统的目的很简单：我们知道显示器无非就是在控制屏幕上每个像素点的颜色，进而显示出不同的图像？但是我们平时开发的时候，不可能叫我们定义像素点的吧？比如我们想画个矩形，不就是直接调一个drawRect方法？再想想，矩形不就是长宽？难道这个方法会根据长宽去自动算出像素点的数据？？？那图像渲染引擎又是干嘛的？？安卓不是自带OpenGL和Skia吗？我就想搞懂这个关系，所以我才看这个显示系统的，，，

这一篇笔记，我们从看的到说起。一点一点的深入。

## 从Activity的显示说起

一个应用的GUI的开始，当然是在第一个Activity(假设应用只有一个Activity)创建的时候，从创建进程到ActivityThread的handleLaunchActivity

~~~java
///media/ba/sd/aosp/frameworks/base/core/java/android/app/ActivityThread.java   
private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) {
       ...
        //这里就是去生成Activity，并且调用onCreate()方法
        Activity a = performLaunchActivity(r, customIntent);

        if (a != null) {
           ..
            //这里是调用Acitivty的onResume方法，我们等下再讲这里,
            handleResumeActivity(r.token, false, r.isForward,
                    !r.activity.mFinished && !r.startsNotResumed, r.lastProcessedSeq, reason);
        }

          ...
    }
~~~

看看performLaunchActivity方法

### 标记A

~~~java
///media/ba/sd/aosp/frameworks/base/core/java/android/app/ActivityThread.java

    private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
        
        Activity activity = null;
        try {
            //通过反射生成对应的Activity
            java.lang.ClassLoader cl = r.packageInfo.getClassLoader();
            activity = mInstrumentation.newActivity(
                    cl, component.getClassName(), r.intent);
            StrictMode.incrementExpectedActivityCount(activity.getClass());
            r.intent.setExtrasClassLoader(cl);
            r.intent.prepareToEnterProcess();
            if (r.state != null) {
                r.state.setClassLoader(cl);
            }
        } catch (Exception e) {
            if (!mInstrumentation.onException(activity, e)) {
                throw new RuntimeException(
                    "Unable to instantiate activity " + component
                    + ": " + e.toString(), e);
            }
        }

        try {
            //生成Application
            Application app = r.packageInfo.makeApplication(false, mInstrumentation);

            if (localLOGV) Slog.v(TAG, "Performing launch of " + r);
            if (localLOGV) Slog.v(
                    TAG, r + ": app=" + app
                    + ", appName=" + app.getPackageName()
                    + ", pkg=" + r.packageInfo.getPackageName()
                    + ", comp=" + r.intent.getComponent().toShortString()
                    + ", dir=" + r.packageInfo.getAppDir());

            if (activity != null) {
                //生成BaseContext
                Context appContext = createBaseContextForActivity(r, activity);
                CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());
                Configuration config = new Configuration(mCompatConfiguration);
                if (r.overrideConfig != null) {
                    config.updateFrom(r.overrideConfig);
                }
                if (DEBUG_CONFIGURATION) Slog.v(TAG, "Launching activity "
                        + r.activityInfo.name + " with config " + config);
                Window window = null;
                if (r.mPendingRemoveWindow != null && r.mPreserveWindow) {
                    window = r.mPendingRemoveWindow;
                    r.mPendingRemoveWindow = null;
                    r.mPendingRemoveWindowManager = null;
                }
                
                //给这个Acitivity初始化一些该有的信息，这里很重要，标记为A
                activity.attach(appContext, this, getInstrumentation(), r.token,
                        r.ident, app, r.intent, r.activityInfo, title, r.parent,
                        r.embeddedID, r.lastNonConfigurationInstances, config,
                        r.referrer, r.voiceInteractor, window);
                ...
                
                 //下面就是回调Activity的的onCreate方法
                if (r.isPersistable()) {
                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);
                } else {
                    mInstrumentation.callActivityOnCreate(activity, r.state);
                }
                if (!activity.mCalled) {
                    throw new SuperNotCalledException(
                        "Activity " + r.intent.getComponent().toShortString() +
                        " did not call through to super.onCreate()");
                }
              ...

        return activity;
    }

~~~

我们知道onCreate方法里面最重要的就是setContentView！！！这里我们还知道，Activity的生命周期的onCreate方法并不是把界面显示出来，而是去生成属于这个Activity的所有View对象并且设置一个标题栏，这里是装饰模式，我们看下去（在以前的笔记中是有说过这个东西的，本来不打算说下去的，但是没有办法。不说怕你想不通）。

~~~java
///home/ba/Android/Sdk/sources/android-25/android/app/Activity.java 
public void setContentView(@LayoutRes int layoutResID) {
        getWindow().setContentView(layoutResID);
        initWindowDecorActionBar();
    }

 public Window getWindow() {
        return mWindow;
    }
~~~

可以看到我们的给Activity设置的VIew是设置在了这个mWindow中，这个mWindow是什么？以前就说过他具体实现是：PhoneWindow！

鉴于有些人可能搞不懂window和VIew的关系：

+ window是一个抽象基类，用于控制顶层窗口的外观和行为。外观指的是我们setContentView进去后是没有actionBar的，window会帮我们搞定。行为是指：我们的View虽然都有分发触摸事件的方法，但在以前我们一直说是系统调用这些方法，那里面的事件哪里来的？触摸事件肯定是来自系统的其他进程：WMS，WMS是去找符合触摸位置等条件的window，然后给对应的window，然后给window里面的ViewRootImp，然后VIewRootImp再分发到对应的view上的。
+ ViewRootImp以前也讲过，他不是View的子类，他是用来管理一个Window下的所有View。一个WIndow的所有VIew的生命周期都是由ViewRootImp管理的
+ view是一个视图单位，占据着屏幕的一块区域，用来绘制对应的内容。

我们看看这个Window是怎么生成的,不好找，全局搜索后发现在attach方法中，我们回到上面的标记A，也就是Acitivity生成的地方，在这里调用了attach：

~~~java
//home/ba/Android/Sdk/sources/android-25/android/app/Activity.java 
    private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
    ...
          
                //给这个Acitivity初始化一些该有的信息，这里很重要
                activity.attach(appContext, this, getInstrumentation(), r.token,
                        r.ident, app, r.intent, r.activityInfo, title, r.parent,
                        r.embeddedID, r.lastNonConfigurationInstances, config,
                        r.referrer, r.voiceInteractor, window);
    ...
    }
~~~

看看这个attach方法里面有什么

~~~java
//home/ba/Android/Sdk/sources/android-25/android/app/Activity.java、
final void attach(Context context, ActivityThread aThread,
            Instrumentation instr, IBinder token, int ident,
            Application application, Intent intent, ActivityInfo info,
            CharSequence title, Activity parent, String id,
            NonConfigurationInstances lastNonConfigurationInstances,
            Configuration config, String referrer, IVoiceInteractor voiceInteractor,
            Window window) {
        attachBaseContext(context);

        mFragments.attachHost(null /*parent*/);

    ///看这里！！
        mWindow = new PhoneWindow(this, window);
    ...
            mWindow.setWindowManager(
                (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),
                mToken, mComponent.flattenToString(),
                (info.flags & ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);
        if (mParent != null) {
            mWindow.setContainer(mParent.getWindow());
        }
        mWindowManager = mWindow.getWindowManager();
        mCurrentConfig = config;
}
~~~

是PhoneWindow吧！但是他还生成了一个WindowManage,然后set进去了？？

~~~java
 public void setWindowManager(WindowManager wm, IBinder appToken, String appName,
            boolean hardwareAccelerated) {
        mAppToken = appToken;
        mAppName = appName;
        mHardwareAccelerated = hardwareAccelerated
                || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, false);
        if (wm == null) {
            wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
        }
        mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this);
    }
~~~

### 标记B

哦！可以看到生成了一个WindowManagerImpl，然后就结束了！！但是这个名字一看就很重要啊！说不定后面有大用，我们先标记为B，我们回到SetContentVIew，现在应该看PhoneWindow的setContentVIew了

~~~java
///media/ba/sd/aosp/frameworks/base/core/java/com/android/internal/policy/PhoneWindow.java 
public void setContentView(int layoutResID) {
        // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window
        // decor, when theme attributes and the like are crystalized. Do not check the feature
        // before this happens.mContentParent是null，为什么叫setContentVIew现在明白了吗？
        if (mContentParent == null) {
            //看这里！！！！
            installDecor();
        } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
            mContentParent.removeAllViews();
        }

       ...
    }


 private void installDecor() {
        mForceDecorInstall = false;
        if (mDecor == null) {
            //生成DecorVIew，基类是FramLayout！！！
            mDecor = generateDecor(-1);
            mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);
            mDecor.setIsRootNamespace(true);
            if (!mInvalidatePanelMenuPosted && mInvalidatePanelMenuFeatures != 0) {
                mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);
            }
        } else {
            mDecor.setWindow(this);
        }
        if (mContentParent == null) {
            //然后生成ContentParent，这里其实就是去设置actionBar和WIndow的Style!!
            //具体代码我就不给了。
            mContentParent = generateLayout(mDecor);
    ...
  }
     
     
~~~

我们现在先总结一下：

![image](http://wiki.jikexueyuan.com/project/deep-android-v1/images/chapter8/image004.png)

这张图很完美的看出我们前面在讲的是什么：

+ 我们调用了Activity的setContentVIew后会生成PhoneWindow，和WindowManagerImpl，
+ 然后PhoneWindow会去生成DecorVIew。
+ DecorVIew就是包括了标题栏和我们设置的View！

到这里，Acitivity的onCreate就结束了，我们只是生成了DecorView，我们并没有去绘制这些VIew，这里的所有VIew都是用LayoutInflator生成的！按照Activity的生命周期，我们应该到onResume这个过程了！回到ActivityThread

~~~java
///media/ba/sd/aosp/frameworks/base/core/java/android/app/ActivityThread.java   
private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) {
       ...
        //这里就是去生成Activity，并且调用onCreate()方法
        Activity a = performLaunchActivity(r, customIntent);

        if (a != null) {
           ..
            //这里是调用Acitivty的onResume方法，我们等下再讲这里,我们现在走到了这里！
            handleResumeActivity(r.token, false, r.isForward,
                    !r.activity.mFinished && !r.startsNotResumed, r.lastProcessedSeq, reason);
        }

          ...
    }
~~~

~~~java
///media/ba/sd/aosp/frameworks/base/core/java/android/app/ActivityThread.java   
    final void handleResumeActivity(IBinder token,
            boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) {
        ActivityClientRecord r = mActivities.get(token);
        if (!checkAndUpdateLifecycleSeq(seq, r, "resumeActivity")) {
            return;
        }

        // If we are getting ready to gc after going to the background, well
        // we are back active so skip it.
        unscheduleGcIdler();
        mSomeActivitiesChanged = true;

        //调用Activity的onResume方法
        r = performResumeActivity(token, clearHide, reason);

        if (r != null) {
            //拿到Activity
            final Activity a = r.activity;

       ...

            final int forwardBit = isForward ?
                    WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;

        
            if (r.window == null && !a.mFinished && willBeVisible) {
                //这个Window就是前面生成的PhoneWindow
                r.window = r.activity.getWindow();
                //这里就是我们前面生成的DecorVIew
                View decor = r.window.getDecorView();
                decor.setVisibility(View.INVISIBLE);
                //这个就是我们前面生成的WindowManagerImpl
                ViewManager wm = a.getWindowManager();
               
                
               ....
                   
                 //看这里！！是调用我们的WindowManagerImpl，然后addView！！！
                if (a.mVisibleFromClient && !a.mWindowAdded) {
                    a.mWindowAdded = true;
                    wm.addView(decor, l);
                }
                ...

            }
~~~

在标记B处，就出现了WindowManagerImpl！就说他很重要吧！！终于用到了！！我们看看他的addVIew方法

~~~java
///home/ba/Android/Sdk/sources/android-25/android/view/WindowManagerImpl.java 
@Override
    public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {
        applyDefaultToken(params);
        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);
    }

~~~

跑到了这个mGlobal去了。。。。

~~~java
///home/ba/Android/Sdk/sources/android-25/android/view/WindowManagerImpl.java   
/*

提供与系统窗口管理器的低级通信
  与任何特定上下文无关的操作。
 
  该类仅在内部用于实现全局函数
  调用者已经知道显示和相关的兼容性信息
  为了操作。在大多数情况下，您应该使用{@link WindowManager}
  因为它受到上下文的约束。
*/
private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();
~~~

还是个单例！那就看他的addVIew方法！

~~~java

///home/ba/Android/Sdk/sources/android-25/android/view/WindowManagerGlobal.java
    public void addView(View view, ViewGroup.LayoutParams params,
            Display display, Window parentWindow) {
      ...


        ViewRootImpl root;
        View panelParentView = null;

     /...

         //这里出现了VIewRootImp！！
            root = new ViewRootImpl(view.getContext(), display);

            view.setLayoutParams(wparams);

        
    
            mViews.add(view);
            mRoots.add(root);
            mParams.add(wparams);
        }

        // do this last because it fires off messages to start doing things
        try {
            //重点来了！！！这里把我们前面生成的DecorView设置进VIewRootImp了！！
            root.setView(view, wparams, panelParentView);
        } 
...
    }
~~~

分析到这里，我们终于到了要调用VIew的生命周期的方法了,我们看看ViewRootImp的setView方法

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java
public void setView(View view, WindowManager.LayoutParamsattrs,

                        View panelParentView){//第一个参数view是DecorView

      ......

       mView= view;//保存这个view

       synchronized (this) {

           requestLayout(); //待会先看看这个。

               try {

                    //调用IWindowSession的addToDisplay函数，第一个参数是mWindow

                 res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,
                            getHostVisibility(), mDisplay.getDisplayId(),
                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,
                            mAttachInfo.mOutsets, mInputChannel);

               }
           
          ......

}
~~~

ViewRoot的setView函数做了三件事：

·  保存传入的view参数为mView，这个mView指向PhoneWindow的DecorView。

·  调用requestLayout。

·  调用IWindowSession的addToDisplay函数，这是一个跨进程的Binder通信，第一个参数是mWindow，它是W类型，从IWindow.stub派生。

## 熟悉的绘制流程（第一次想分析绘制）

### 标记C

我们先看看requestLayout做了什么

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java  
@Override
    public void requestLayout() {
        if (!mHandlingLayoutInLayoutRequest) {
            //检查当前线程是否是UI线程！！！
            checkThread();
            mLayoutRequested = true;
            //是不是就去绘制了？？
            scheduleTraversals();
        }
    }


    void scheduleTraversals() {
        if (!mTraversalScheduled) {
            mTraversalScheduled = true;
            //发了个消息,所以我们看看mTraversalRunnable写了什么
            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();
            mChoreographer.postCallback(
                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);
            ...
        }
    }

 final class TraversalRunnable implements Runnable {
        @Override
        public void run() {
            //继续
            doTraversal();
        }
    }

   void doTraversal() {
        if (mTraversalScheduled) {
            mTraversalScheduled = false;
            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);

            if (mProfile) {
                Debug.startMethodTracing("ViewAncestor");
            }

            //看这个！！！这是我们熟悉的方法啊！！这能触发绘制！！！
            performTraversals();

            if (mProfile) {
                Debug.stopMethodTracing();
                mProfile = false;
            }
        }
    }

 private void performTraversals() {      
     //这就是我们的DecorVIew
        final View host = mView;
     
     try {

    	relayoutResult= //①关键函数relayoutWindow，标记为C

		relayoutWindow(params, viewVisibility,insetsPending);
   }

......

		performDraw()// ②开始绘制
 }

~~~

我们先看performDraw方法做了什么

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java  
 private void performDraw() {
          ....
        try {
           //这个！！！
            draw(fullRedrawNeeded);
        } finally {
            mIsDrawing = false;
            Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        }
     ...
 }


private void draw(boolean fullRedrawNeeded) {
    	//surface????
        Surface surface = mSurface;
        if (!surface.isValid()) {
            return;
        }
    ...

        //这个！！！
          if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) {
                    return;
         }
    ...

     }


   private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff,
            boolean scalingRequired, Rect dirty) {

        // 看到这个的时候，虎躯一震！这不就是画布吗！！！！
        final Canvas canvas;
        try {
         
            ...

            //锁住
            canvas = mSurface.lockCanvas(dirty);

      ....
          		//绘制！！！
                mView.draw(canvas);

       ...
            
        } finally {
            try {
                //解锁
                surface.unlockCanvasAndPost(canvas);
            }
            ...
        }
        return true;
    }

~~~

我们很清楚的知道view.draw（）方法里面做了些什么，不就是“四大金刚”相互合作，这四大金刚是：

·  Bitmap：用于存储像素，也就是画布。可把它当做一块数据存储区域。

·  Canvas：用于记载画图的动作，比如画一个圆，画一个矩形等。Canvas类提供了这些基本的绘图函数。

·  Drawing primitive：绘图基元，例如矩形、圆、弧线、文本、图片等。

·  Paint：它用来描述绘画时使用的颜色、风格（如实线、虚线等）等。

在一般情况下，Canvas会封装一块Bitmap，而作图就是基于这块Bitmap的。前面说的画布，其实指的就是Canvas中的这块Bitmap。动动脑子想想，显示器这个硬件设备肯定不是java层去直接控制的，我们现在要研究的不是java层的那些个抽象方法调来调去，具体的绘制实现肯定在native层，一定要把它揪出来。

## Surface初现！

我们可以看到在调用view的draw之前，跑出来了一个surface,不知道是什么？看看图吧

![img](https://lc-gold-cdn.xitu.io/89bc05cb52100766ea5d.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

一个WIndow有着一个Surface，一个Surface相当于画纸，用来给我们的应用程序画画的！我们上面可以看到canvas就是从Surface的lockCanvas得到的呀！！！我们看看他的初始化

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java  
final Surface mSurface = new Surface();
~~~

看看surface的构造函数

~~~java
//home/ba/Android/Sdk/sources/android-25/android/view/Surface.java
//注意这个
 private final Canvas mCanvas = new CompatibleCanvas();
public Surface() {
    }
~~~

空的！！那还能咋办呀？只能看看他的lockCanvas方法干了些什么

~~~java
//home/ba/Android/Sdk/sources/android-25/android/view/Surface.java
public Canvas lockCanvas(Rect inOutDirty)
            throws Surface.OutOfResourcesException, IllegalArgumentException {
        synchronized (mLock) {
            checkNotReleasedLocked();
            if (mLockedObject != 0) {
                // Ideally, nativeLockCanvas() would throw in this situation and prevent the
                // double-lock, but that won't happen if mNativeObject was updated.  We can't
                // abandon the old mLockedObject because it might still be in use, so instead
                // we just refuse to re-lock the Surface.
                throw new IllegalArgumentException("Surface was already locked");
            }
            //是个JNI方法
            mLockedObject = nativeLockCanvas(mNativeObject, mCanvas, inOutDirty);
            //返回了CompatibleCanvas
            return mCanvas;
        }
    }
~~~

这个mCanvas的实际类型为CompatibleCanvas，可以看到调了个JNI函数，很激动吧！！终于看到有native的影子了！所以我们要找到注册的地方，但是我搜索了Serface类，没有调用init方法。但是！！注意看nativeLockCanvas方法传入的参数！mNativeObject！！这是什么？？

~~~java
//home/ba/Android/Sdk/sources/android-25/android/view/Surface.java
long mNativeObject; 
~~~

指针耶！说明这个东西的具体对象其实是在c++层！我们使用surfece的函数时候mNativeObject;都要作为参数传进去，那他是怎么来的?他的真正类型是什么？那就找他的来源吧！

~~~java
//home/ba/Android/Sdk/sources/android-25/android/view/Surface.java
public void copyFrom(SurfaceControl other) {
        if (other == null) {
            throw new IllegalArgumentException("other must not be null");
        }

     	//这里！！！！
        long surfaceControlPtr = other.mNativeObject;
        if (surfaceControlPtr == 0) {
            throw new NullPointerException(
                    "SurfaceControl native object is null. Are you using a released SurfaceControl?");
        }
        long newNativeObject = nativeCreateFromSurfaceControl(surfaceControlPtr);

        synchronized (mLock) {
            if (mNativeObject != 0) {
                nativeRelease(mNativeObject);
            }
            setNativeObjectLocked(newNativeObject);
        }
    }
~~~

这个copyFrom什么时候调用的？？我们在绘制之前，还调用了一个方法在标记C处：relayoutWindow()，他会不会就是去准备SurfaceControl这个对象？

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java   
private int relayoutWindow(WindowManager.LayoutParams params, int viewVisibility,
            boolean insetsPending) throws RemoteException {

       ...
         //注意看最后一个参数，mSurface！！！传进去的原因可能就是去方便调用Surface的方法，说不定就是copyFrom方法！
        int relayoutResult = mWindowSession.relayout(
                mWindow, mSeq, params,
                (int) (mView.getMeasuredWidth() * appScale + 0.5f),
                (int) (mView.getMeasuredHeight() * appScale + 0.5f),
                viewVisibility, insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : 0,
                mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets,
                mPendingStableInsets, mPendingOutsets, mPendingBackDropFrame, mPendingConfiguration,
                mSurface);

        mPendingAlwaysConsumeNavBar =
                (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_CONSUME_ALWAYS_NAV_BAR) != 0;

      ...
        return relayoutResult;
    }
~~~

这个mWindowSession又是什么东西？？到目前为止已经出现了两次进程通信了！！!在VIewRootImp的setVIew方法出现了一次，在relayoutWindow又出现了一次。

## 蛛丝马迹

我们回到ViewRootImp的构造函数仔细看看

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java    
public ViewRootImpl(Context context, Display display) {
      ...
        mWindowSession = WindowManagerGlobal.getWindowSession();
      ...
        mWindow = new W(this);
      
        ...
     
    }

~~~

我们先看getWindowSession

~~~java
//home/ba/Android/Sdk/sources/android-25/android/view/WindowManagerGlobal.java    
public static IWindowSession getWindowSession() {
        synchronized (WindowManagerGlobal.class) {
            if (sWindowSession == null) {
                try {
                    InputMethodManager imm = InputMethodManager.getInstance();
                    IWindowManager windowManager = getWindowManagerService();
                    sWindowSession = windowManager.openSession(
                            new IWindowSessionCallback.Stub() {
                                @Override
                                public void onAnimatorScaleChanged(float scale) {
                                    ValueAnimator.setDurationScale(scale);
                                }
                            },
                            imm.getClient(), imm.getInputContext());
                } catch (RemoteException e) {
                    throw e.rethrowFromSystemServer();
                }
            }
            return sWindowSession;
        }
    }
~~~

可以看到这一次openSession的进程通信的目的端是WMS！我们看看这个openSession干了什么

~~~java
//media/ba/sd/aosp/frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java   
@Override
    public IWindowSession openSession(IWindowSessionCallback callback, IInputMethodClient client,
            IInputContext inputContext) {
        if (client == null) throw new IllegalArgumentException("null client");
        if (inputContext == null) throw new IllegalArgumentException("null inputContext");
        Session session = new Session(this, callback, client, inputContext);
        return session;
    }
~~~

说明了IWindowSession对象是WMS的Bn代理！！！那W类型的mWindow是什么？

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java    
static class W extends IWindow.Stub {
        private final WeakReference<ViewRootImpl> mViewAncestor;
        private final IWindowSession mWindowSession;

        W(ViewRootImpl viewAncestor) {
            mViewAncestor = new WeakReference<ViewRootImpl>(viewAncestor);
            mWindowSession = viewAncestor.mWindowSession;
        }
        
        ...
    }
~~~

嗯，他也是用来进程通信的！他的类型是IWindow，我们后面再讲这个IWindow。我们回到ViewRootImp的setVIew方法

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java
public void setView(View view, WindowManager.LayoutParamsattrs,

                        View panelParentView){//第一个参数view是DecorView

      ......

       mView= view;//保存这个view

       synchronized (this) {

           requestLayout(); 

               try {

                    //调用IWindowSession的add函数，第一个参数是mWindow

                       res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,
                            getHostVisibility(), mDisplay.getDisplayId(),
                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,
                            mAttachInfo.mOutsets, mInputChannel);

               }

          ......

}
~~~

我们先小结一下：

+ 我们在Activity的onCreate阶段进行了装饰我们通过setCotentView方法设置进去的VIew，生成DecorVIew
+ 然后为这个Activity绑定了一个PhoneWindow和WindowMananger
+ 然后在Activity的onResume阶段通过WindowMananger生成了一个ViewRootImp，用来管理我们的DecorVIew

- 我们new了ViewRootImp后就去和WMS进行了进程通信，其实就是先和WMS建立起联系，也算是初始化Binder通信
- 然后调用了VIewRootImp的setVIew方法，这里面做了两件事
- 从requestLayout走到了VIew的draw方法，但是在draw前，进行了一次进程通信，因为有个surface对象和绘制有着莫大的联系，但是我们查看Surface的代码发现他在里面就是一直调用native层的方法，这点我们知道绘制肯定是在native层，有意思的是，在Surface对象里面保存了一个叫做nativeObject的指针，他的类型不是对象，而是long。所以他的真实对象类型我们不清楚，当我们找他的来源时，停在了copyFrom方法，我们不知道谁去调用了这个方法，所以我们猜想是在draw前的进程通信那里做了手脚！！
- 在requestLayout()方法里面post了一个Runable后，又进行了一次进程通信sWindowSession.addToDisplay（）
- 所以我们现在卡在了两次进程通信！！只要搞明白这两次进程通信就能搞明白Surface到底和绘制有着什么关系。

## 两次进程通信

一个WIndow的作用就两个：行为和外观！  requestLayout(); 方法里面进行了VIew的draw，这里虽然进行了一次进程通信，但是我们相信这一次进程通信是绘制前的准备工作，毕竟他传入了个mSurface对象，所以我觉得requestLayout这里负责外观。

但是走完requestLayout的时候，就又进行了一次进程通信sWindowSession.add，这一次，我觉得是负责行为（也就是按键事件），因为他传入了个mWindow，要知道这个可是一个BInder对象，鉴于IWindowSession是WMS的BInder，所以类型为IWindow的mWindow很有可能就是给WMS回调的Bn端，为什么要回调？按键事件肯定是从WMS来的，WIndow只能等WMS告诉你！！！；

我们先分析sWindowSession.addToDisplay（）因为Surface才是重头戏，我们要放后面讲IWindowSession.aidl的具体实现是Session

~~~java
    //media/ba/sd/aosp/frameworks/base/services/core/java/com/android/server/wm/Session.java
   

    @Override
    public int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs,
            int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets,
            Rect outOutsets, InputChannel outInputChannel) {
        return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId,
                outContentInsets, outStableInsets, outOutsets, outInputChannel);
    }

~~~

可以看到，调用的是服务端的addWindow方法，也就是WMS的addWindow方法

~~~java
//media/ba/sd/aosp/frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java   
public int addWindow(Session session, IWindow client, int seq,
            WindowManager.LayoutParams attrs, int viewVisibility, int displayId,
            Rect outContentInsets, Rect outStableInsets, Rect outOutsets,
            InputChannel outInputChannel) {
      ...
        //创建一个WindowState
            WindowState win = new WindowState(this, session, client, token,
                    attachedWindow, appOp[0], seq, attrs, viewVisibility, displayContent);
           
           ...
        //这个很重要
            win.attach();
        ...

        return res;
    }
~~~



~~~java
//media/ba/sd/aosp/frameworks/base/services/core/java/com/android/server/wm/WindowState.java
void attach() {
        if (WindowManagerService.localLOGV) Slog.v(
            TAG, "Attaching " + this + " token=" + mToken
            + ", list=" + mToken.windows);
        mSession.windowAddedLocked();
    }
~~~

其实就是Session的windowAddedLocked方法

~~~java
//media/ba/sd/aosp/frameworks/base/services/core/java/com/android/server/wm/Session.java 
void windowAddedLocked() {
    //做了一个判断，说明WMS只会为一个进程打开一个SurfaceSession
        if (mSurfaceSession == null) {
            if (WindowManagerService.localLOGV) Slog.v(
                TAG_WM, "First window added to " + this + ", creating SurfaceSession");
            //注意！！！这里
            mSurfaceSession = new SurfaceSession();
            if (SHOW_TRANSACTIONS) Slog.i(
                    TAG_WM, "  NEW SURFACE SESSION " + mSurfaceSession);
            mService.mSessions.add(this);
            if (mLastReportedAnimatorScale != mService.getCurrentAnimatorScale()) {
                mService.dispatchNewAnimatorScaleLocked(this);
            }
        }
        mNumWindow++;
    }
~~~

这里居然生成了个SurfaceSession？？？懵逼！难道我们猜错了？？？这里不是按键处理？？不信这个邪，我们先把这个SurfaceSession放一边，现在我们代码走到了这里，把IWindow放进了WindowState里面，我觉得这样太麻烦了，我们直接看IWIndow的具体代码不就好了！！

~~~java
oneway interface IWindow {
    /**
     * ===== NOTICE =====
     * The first method must remain the first method. Scripts
     * and tools rely on their transaction number to work properly.
     */

    /**
     * Called for wallpaper windows when their offsets change.
     */
    void dispatchWallpaperOffsets(float x, float y, float xStep, float yStep, boolean sync);
    
    void dispatchWallpaperCommand(String action, int x, int y,
            int z, in Bundle extras, boolean sync);

    /**
     * Drag/drop events
     */
    void dispatchDragEvent(in DragEvent event);

    /**
     * Pointer icon events
     */
    void updatePointerIcon(float x, float y);

    /**
     * System chrome visibility changes
     */
    void dispatchSystemUiVisibilityChanged(int seq, int globalVisibility,
            int localValue, int localChanges);

    /**
     * Called for non-application windows when the enter animation has completed.
     */
    void dispatchWindowShown();
}

~~~

明白了？这里的事件指的就是按键、触屏等事件。那么，一个按键事件是如何被分发的呢？下面是它大致的流程：

·  WMS所在的SystemServer进程接收到按键事件。

·  WMS找到UI位于屏幕顶端的进程所对应的IWindow对象，这是一个Bp端对象。

·  调用这个IWindow对象的dispatchKey。IWindow对象的Bn端位于ViewRoot中，ViewRoot再根据内部View的位置信息找到真正处理这个事件的View，最后调用dispatchKey函数完成按键的处理。

其实这些按键事件的分发机制可以拿Windows的UI编程来做类比，在Windows中应用程序的按键处理流程是：

·  每一个按键事件都会转化成一个消息，这个消息将由系统加入到对应进程的消息队列中。该进程的消息在派发处理时，会根据消息的句柄找到对应的Window（窗口），继而该消息就由这个Window处理了。

注意：上面的描述实际上大大简化了真实的处理流程，读者可在了解大体知识后进行更深入的研究。

所以可以看出，这次通信的目的之一就是去注册这个按键，但是我们看到创建了一个SurfaceSession！！说明这次进程通信还进行了一些动西的初始化，但是现在问题来了，我们这次分析的进程通信是在addToDisplay，我们看看下面的代码

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java
public void setView(View view, WindowManager.LayoutParamsattrs,

                        View panelParentView){//第一个参数view是DecorView

      ......

       mView= view;//保存这个view

       synchronized (this) {

           //这里面会有一个进程通信
           requestLayout(); 

               try {

                    //刚刚我们分析的是这个进程通信

                       res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,
                            getHostVisibility(), mDisplay.getDisplayId(),
                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,
                            mAttachInfo.mOutsets, mInputChannel);

               }

          ......

}
~~~

所以问题就很大了，为什么初始化的过程居然在requestLayout方法的后面？？我们知道requestLayout方法就是去绘制界面了，都绘制了后才来初始化，有什么用？？所以我们肯定漏了什么东西，我们回到绘制的方法里面

~~~java
    void scheduleTraversals() {
        if (!mTraversalScheduled) {
            mTraversalScheduled = true;
            //发了个消息
            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();
            mChoreographer.postCallback(
                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);
            ...
        }
    }
~~~

我们刚刚是直接分析一发消息就去执行mTraversalRunnable的方法，但是现在看来并不是这样的，这个事件发送出去后，requestLayout方法就结束了！就到addToDisplay了，真正绘制的过程还没有发生！！因为mTraversalRunnable，还没被执行，这样似乎就说的通了，所以说这个mTraversalRunnable是会在合适的时候被调用（这里和垂直同步有关，在讲绘制的时候我们再详细学习），我们先看一下时序图

![image](http://wiki.jikexueyuan.com/project/deep-android-v1/images/chapter8/image007.png)

看到5和6，5的add在安卓7.0代码中对应的是addToDisplay()，我们上面分析代码是requestlayout()先，6的relayout()是在mTraversalRunnable里面的，而mTraversalRunnable是在requestlayout()方法被发送出去的，但是还没被执行就到了addToDisplay()方法，所以上面的时序图是正确的，第五步我们生成了一个SurfaceSession，这个可以看出是在第二次进程通信里面要用到，我们先不管mTraversalRunnable是被什么条件触发后执行（很后面会讲），现在只需要知道他是在addToDisplay方法后被执行就好了，我们现在就看看mTraversalRunnable被执行后进行的第二次进程通信做了什么！！！

第二次进程通信是在

~~~java
 private void performTraversals() {      
     //这就是我们的DecorVIew
        final View host = mView;
     
     try {

         //这里！！！
    	relayoutResult= 

		relayoutWindow(params, viewVisibility,insetsPending);
   }

......

		performDraw()// ②开始绘制
 }
~~~

在这里我们是有疑惑的，Surface的nativeObject到底是什么？那就要看是谁调用了copyFrom方法？relayoutWindow肯定是对Surface对象进行初始化设置的，一起解密吧！！！

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java   
private int relayoutWindow(WindowManager.LayoutParams params, int viewVisibility,
            boolean insetsPending) throws RemoteException {

       ...
         //注意看最后一个参数，mSurface！！！传进去的原因可能就是去方便调用Surface的方法，说不定就是copyFrom方法！
        int relayoutResult = mWindowSession.relayout(
                mWindow, mSeq, params,
                (int) (mView.getMeasuredWidth() * appScale + 0.5f),
                (int) (mView.getMeasuredHeight() * appScale + 0.5f),
                viewVisibility, insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : 0,
                mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets,
                mPendingStableInsets, mPendingOutsets, mPendingBackDropFrame, mPendingConfiguration,
                mSurface);

        mPendingAlwaysConsumeNavBar =
                (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_CONSUME_ALWAYS_NAV_BAR) != 0;

      ...
        return relayoutResult;
    }
~~~

这里就是时序图中的第6步，relayout！！按照Binder的设计，我们应该找到IWindowSession的具体实现：也就是我们说的Bp，我找不到，按照书上说的，就应该去编译这个AIDL文件，就能得到了。

### 标记Ｄ

~~~java
//这个类应该叫BpWindowSession.java
public int relayout(android.view.IWindow window,

                 android.view.WindowManager.LayoutParams attrs,

                  int requestedWidth, intrequestedHeight,

                 int viewVisibility, boolean insetsPending,

                 android.graphics.Rect outFrame,

                 android.graphics.Rect outContentInsets,

                 android.graphics.Rect outVisibleInsets,

                 android.content.res.Configuration outConfig,

                 android.view.Surface outSurface)//outSurface是第11个参数

                                    throwsandroid.os.RemoteException

{

   android.os.Parcel_data = android.os.Parcel.obtain();

   android.os.Parcel_reply = android.os.Parcel.obtain();

   int_result;

   try {

      _data.writeInterfaceToken(DESCRIPTOR);

     _data.writeStrongBinder((((window!=null))?(window.asBinder()):(null)));

     if((attrs!=null)) {

       _data.writeInt(1);

       attrs.writeToParcel(_data,0);

     }

    else {

    _data.writeInt(0);

   }

  _data.writeInt(requestedWidth);

  _data.writeInt(requestedHeight);

  _data.writeInt(viewVisibility);

  _data.writeInt(((insetsPending)?(1):(0)));

 //奇怪，outSurface的信息没有写到请求包_data中，就直接发送请求消息了，我们先研究这里

  mRemote.transact(Stub.TRANSACTION_relayout,_data, _reply, 0);

  _reply.readException();

  _result= _reply.readInt();

  if((0!=_reply.readInt())) {

   outFrame.readFromParcel(_reply);

  }

  ....

  if((0!=_reply.readInt())) {

//从Parcel中读取信息来填充outSurface,这里等下我们再看，标记为D
     outSurface.readFromParcel(_reply);

    }

  }

  ......

  return_result;

}
~~~

可以看到上面是没有把ourSurface写到数据包就发送了，但是在等待答复的时候却对outSurface进行了操作，我们先去看看Bn端的接收端发生了什么(这个Bn端的代码按照谷歌的风格应该也是放在IWindowSession的具体实现类里面的)。

### 标记E

~~~java
public boolean onTransact(int code,android.os.Parcel data,

                               android.os.Parcelreply, int flags)

                    throwsandroid.os.RemoteException

{

  switch(code)

  {

    caseTRANSACTION_relayout:

    {

      data.enforceInterface(DESCRIPTOR);

      android.view.IWindow_arg0;

      android.view.Surface_arg10;

      //刚才讲了，Surface信息并没有传过来，那么在relayOut中看到的outSurface是怎么

      //出来的呢？看下面这句可知，原来在服务端这边竟然new了一个新的Surface!!!这个new出来的Surface只是一个中转而已。

      _arg10= new android.view.Surface();
      
      //然后去调用了具体实现的relayout方法，我们等下先讲这个

      int_result = this.relayout(_arg0, _arg1, _arg2, _arg3, _arg4,

      _arg5,_arg6, _arg7, _arg8, _arg9, _arg10);
      
      
      //下面是回复应用进程的代码，我们等下再看，标记为Ｅ

      reply.writeNoException();

      reply.writeInt(_result);

      //_arg10就是调用copyFrom的那个outSurface，那怎么传到客户端呢？

      if((_arg10!=null)) {

           reply.writeInt(1);

           //调用Surface的writeToParcel，把信息写到reply包中。

           _arg10.writeToParcel(reply,

                 android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);

        }

    }

    ......

   return true;

}
~~~

具体实现应该就是Session里面的代码

~~~java
///media/ba/sd/aosp/frameworks/base/services/core/java/com/android/server/wm/Session.java    
public int relayout(IWindow window, int seq, WindowManager.LayoutParams attrs,
            int requestedWidth, int requestedHeight, int viewFlags,
            int flags, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,
            Rect outVisibleInsets, Rect outStableInsets, Rect outsets, Rect outBackdropFrame,
            Configuration outConfig, Surface outSurface) {
        if (false) Slog.d(TAG_WM, ">>>>>> ENTERED relayout from "
                + Binder.getCallingPid());
        //看这里
        int res = mService.relayoutWindow(this, window, seq, attrs,
                requestedWidth, requestedHeight, viewFlags, flags,
                outFrame, outOverscanInsets, outContentInsets, outVisibleInsets,
                outStableInsets, outsets, outBackdropFrame, outConfig, outSurface);
        if (false) Slog.d(TAG_WM, "<<<<<< EXITING relayout to "
                + Binder.getCallingPid());
        return res;
    }
~~~

这里要注意这个outSurface并不是我们从ViewRootImp传过来的！

~~~java
//media/ba/sd/aosp/frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java   
public int relayoutWindow(Session session, IWindow client, int seq,
            WindowManager.LayoutParams attrs, int requestedWidth,
            int requestedHeight, int viewVisibility, int flags,
            Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,
            Rect outVisibleInsets, Rect outStableInsets, Rect outOutsets, Rect outBackdropFrame,
            Configuration outConfig, Surface outSurface) {
        int result = 0;
        boolean configChanged;
        boolean hasStatusBarPermission =
                mContext.checkCallingOrSelfPermission(android.Manifest.permission.STATUS_BAR)
                        == PackageManager.PERMISSION_GRANTED;

        long origId = Binder.clearCallingIdentity();
        synchronized(mWindowMap) {
            //注意看这个，去查找WIndowState！这个WindowState在上一次进程通信的时候就生成了！
            WindowState win = windowForClientLocked(session, client, false);
            if (win == null) {
                return 0;
            }

           ...

    
   
              if (viewVisibility == View.VISIBLE &&
                    (win.mAppToken == null || !win.mAppToken.clientHidden)) {
                result = relayoutVisibleWindow(outConfig, result, win, winAnimator, attrChanges,
                        oldVisibility);
                try {
                    //我们看这一句，虽然下面的代码也有getSession，但是我觉得从这里入手比较好
                    result = createSurfaceControl(outSurface, result, win, winAnimator);
                } catch (Exception e) {
                    mInputMonitor.updateInputWindowsLw(true /*force*/);

                    Slog.w(TAG_WM, "Exception thrown when creating surface for client "
                             + client + " (" + win.mAttrs.getTitle() + ")",
                             e);
                    Binder.restoreCallingIdentity(origId);
                    return 0;
                }
        
                  //这里有用到，但是上面的方法可以看到surfaceController的创建，所以我们还是分析上面的方法吧
                final WindowSurfaceController surfaceController = winAnimator.mSurfaceController;
                if (viewVisibility == View.VISIBLE && surfaceController != null) {
                    // We already told the client to go invisible, but the message may not be
                    // handled yet, or it might want to draw a last frame. If we already have a
                    // surface, let the client use that, but don't create new surface at this point.
                    surfaceController.getSurface(outSurface);
                } else {
                   ...
        return result;
    }
                  
                  
 private int createSurfaceControl(Surface outSurface, int result, WindowState win,
            WindowStateAnimator winAnimator) {
        if (!win.mHasSurface) {
            result |= RELAYOUT_RES_SURFACE_CHANGED;
        }
     	//先看这个
        WindowSurfaceController surfaceController = winAnimator.createSurfaceLocked();
        if (surfaceController != null) {
            //这个等再看
            surfaceController.getSurface(outSurface);
            if (SHOW_TRANSACTIONS) Slog.i(TAG_WM, "  OUT SURFACE " + outSurface + ": copied");
        } else {
            // For some reason there isn't a surface.  Clear the
            // caller's object so they see the same state.
            Slog.w(TAG_WM, "Failed to create surface control for " + win);
            outSurface.release();
        }
        return result;
    }
~~~

~~~~java
//media/ba/sd/aosp/frameworks/base/services/core/java/com/android/server/wm/WindowStateAnimator.java  
WindowSurfaceController createSurfaceLocked() {
        final WindowState w = mWin;
      
...
      	//这里！！可以看到他把SurfaceSession传了进去！我还一直纳闷前面生成的这个东西没有用呢!原来用在这里了！！！！
        mSurfaceController = new WindowSurfaceController(mSession.mSurfaceSession,
                    attrs.getTitle().toString(),
                    width, height, format, flags, this);

            w.setHasSurface(true);

           ...
        return mSurfaceController;
    }

~~~~

现在只能看WindowSurfaceController的构造函数了！！

~~~java
//media/ba/sd/aosp/frameworks/base/services/core/java/com/android/server/wm/WindowSurfaceController.java   
public WindowSurfaceController(SurfaceSession s,
            String name, int w, int h, int format, int flags, WindowStateAnimator animator) {
        mAnimator = animator;

        mSurfaceW = w;
        mSurfaceH = h;

        title = name;

  
        // For opaque child windows placed under parent windows,
        // we use a special SurfaceControl which mirrors commands
        // to a black-out layer placed one Z-layer below the surface.
        // This prevents holes to whatever app/wallpaper is underneath.
        if (animator.mWin.isChildWindow() &&
                animator.mWin.mSubLayer < 0 &&
                animator.mWin.mAppToken != null) {
            mSurfaceControl = new SurfaceControlWithBackground(s,
                    name, w, h, format, flags, animator.mWin.mAppToken);
        } else if (DEBUG_SURFACE_TRACE) {
            mSurfaceControl = new SurfaceTrace(
                    s, name, w, h, format, flags);
        } else {
            //这个
            mSurfaceControl = new SurfaceControl(
                    s, name, w, h, format, flags);
        }
    }
~~~

wtf。。。服了，，我们看最后一个

~~~java
///media/ba/sd/aosp/frameworks/base/core/java/android/view/SurfaceControl.java   
public SurfaceControl(SurfaceSession session,
            String name, int w, int h, int format, int flags)
                    throws OutOfResourcesException {
        if (session == null) {
            throw new IllegalArgumentException("session must not be null");
        }
        if (name == null) {
            throw new IllegalArgumentException("name must not be null");
        }

        if ((flags & SurfaceControl.HIDDEN) == 0) {
            Log.w(TAG, "Surfaces should always be created with the HIDDEN flag set "
                    + "to ensure that they are not made visible prematurely before "
                    + "all of the surface's properties have been configured.  "
                    + "Set the other properties and make the surface visible within "
                    + "a transaction.  New surface name: " + name,
                    new Throwable());
        }

        mName = name;
    	//看这里！怎么又多了一个mNativeObject，说明SurfaceConteol也有一个native层对应的对象！！！
        mNativeObject = nativeCreate(session, name, w, h, format, flags);
        if (mNativeObject == 0) {
            throw new OutOfResourcesException(
                    "Couldn't allocate SurfaceControl native object");
        }

        mCloseGuard.open("release");
    }

~~~

现在让我们回到surfaceController.getSurface(outSurface);方法

~~~java
//media/ba/sd/aosp/frameworks/base/services/core/java/com/android/server/wm/WindowSurfaceController.java 
void getSurface(Surface outSurface) {
        outSurface.copyFrom(mSurfaceControl);
    }
~~~

这里需要注意！！这个outSurface不是我们VIewRootImp里面的Surface对象，而是在Bn端直接new出来的，但是我们知道这个copyFrom对象就是把mSurfaceControl配置好的一些东西设置到outSurface里面去，尤其是那两个nativeObject！但是里面还是会调用到JNI的方法，我们先不管JNI层的调用！现在我们回到标记E

~~~java
public boolean onTransact(int code,android.os.Parcel data,

                               android.os.Parcelreply, int flags)

                    throwsandroid.os.RemoteException

{      
...
    
      reply.writeNoException();

      reply.writeInt(_result);

      //_arg10就是调用copyFrom的那个outSurface，那怎么传到客户端呢？

      if((_arg10!=null)) {

           reply.writeInt(1);

           //调用Surface的writeToParcel，把信息写到reply包中。

           //注意最后一个参数为PARCELABLE_WRITE_RETURN_VALUE

           _arg10.writeToParcel(reply,

                 android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);

        }

    }

    ......

   return true;

}
~~~

我们看看Surface的writeToParcel方法

~~~java
//home/ba/Android/Sdk/sources/android-25/android/view/Surface.java    
@Override
    public void writeToParcel(Parcel dest, int flags) {
        if (dest == null) {
            throw new IllegalArgumentException("dest must not be null");
        }
        synchronized (mLock) {
            // NOTE: This must be kept synchronized with the native parceling code
            // in frameworks/native/libs/Surface.cpp
            dest.writeString(mName);
            dest.writeInt(mIsSingleBuffered ? 1 : 0);
            nativeWriteToParcel(mNativeObject, dest);
        }
        if ((flags & Parcelable.PARCELABLE_WRITE_RETURN_VALUE) != 0) {
            release();
        }
    }
~~~

又是跑到JNI调用，okok，我们先不分析JNI的东西，这一步无非就是把信息写过去而已，现在回到Bp端,就是标记D处

~~~java
//这个类应该叫BpWindowSession.java
public int relayout(android.view.IWindow window,

                 android.view.WindowManager.LayoutParams attrs,

                  int requestedWidth, intrequestedHeight,

                 int viewVisibility, boolean insetsPending,

                 android.graphics.Rect outFrame,

                 android.graphics.Rect outContentInsets,

                 android.graphics.Rect outVisibleInsets,

                 android.content.res.Configuration outConfig,

                 android.view.Surface outSurface)//outSurface是第11个参数

                                    throwsandroid.os.RemoteException

{

  ...
  if((0!=_reply.readInt())) {

//这里！！
     outSurface.readFromParcel(_reply);

    }

  }

  ......

  return_result;

}
~~~

标记E处的readFromParcel里面肯定也是jni层的调用，其实就是把Bn端的数据搞过来，现在我们小结一下再进行JNI层的分析

+ 这次进程通信，经历了步骤如下
+ IWindowSession的Bp，进行打包数据，但是没有把我们当前进程VIewRootImp的surface打包进去
+ 然后调用了transact方法和WMS进行通信
+ Bn端收到请求后先是生成了一个新的surface，然后再传到具体的实现方法，Session的relayout（），Session的relayout方法里面又会把处理交给WMS的relayoutWindow()方法处理。
+ WMS的relayoutWindow()方法会先生成SurfaceControl
+ 然后调用SurfaceControl的nativeCreate方法（SurfaceSession作为参数），通过JNI函数生成一个native的SurfaceControl。
+ 然后SurfaceControl的getSurface方法，实际是调用我们新生成的java层的surface对象的copyFrom方法
+ 这个copyFrom会通过SurfaceControl，从native层里面拿到我们native对应的Surface
+ 现在所有的数据，都放在了新生成的surface对象中，Bn端通过该surface的WriteToParcel()打包数据到reply（就是我们的标记D），再通过Binder把数据返回给我们进程的Bp端
+ Bp端收到结果和数据包后，通过我们进程的VIewRootImp生成的Surface的readFromParcel()方法把内容读出来（就是我们的标记E），填充自己

+ 我们现在知道了Surface里面的NativeObject就是Native层的Surface对象，但是SurfaceSession作为参数WMS生成这个NativeObject是SurfaceControl的nativeObject对象，参照java层的设计，native层也是把Surface对象放在了SurfaceControl里面

下面我们开始看JNI层的代码，下面是我们分析的步骤

+ 分析SurfaceControl生成对应native层的NativeObject的代码
+ 分析在WMS所处进程的Surface的copyFrom函数做了什么
+ 分析在WMS所处进程的Surface的WriteToParcel函数做了什么
+ 分析在我们进程VIewRootImp的Surface的readFromParcel函数做了什么

一步一步来，我们先看创建SurfaceControl里面的NativeObject创建的方法

~~~java
public class SurfaceControl {
    private static final String TAG = "SurfaceControl";

    private static native long nativeCreate(SurfaceSession session, String name,
            int w, int h, int format, int flags);
}
~~~

按照JNI技术的命名，我们直接找native层对应的代码

~~~java
//media/ba/sd/aosp/frameworks/base/core/jni/android_view_SurfaceControl.cpp
static jlong nativeCreate(JNIEnv* env, jclass clazz, jobject sessionObj,
        jstring nameStr, jint w, jint h, jint format, jint flags) {
    ScopedUtfChars name(env, nameStr);
    
    //先看这，通过SurfaceSession对象获取一个SurfaceComposerClient，这就说明在SurfaceSession构造函数里面就有去创建这个native层的SurfaceComposerClient对象了，代码我就不给出来了
    sp<SurfaceComposerClient> client(android_view_SurfaceSession_getClient(env, sessionObj));
    
    //这里要注意！说是创建Surface，但是实际创建的是SurfaceControl,这个地方其实是跨进程调用，我们后面再讲，只需要知道当前就是实例化一个SurfaceControl
      sp<SurfaceControl> surface = client->createSurface(
            String8(name.c_str()), w, h, format, flags);
    if (surface == NULL) {
        jniThrowException(env, OutOfResourcesException, NULL);
        return 0;
    }
    surface->incStrong((void *)nativeCreate);
    
    //主要看这个，很熟悉吧！！！又是偷偷的转换指针
    //einterpret_cast是个很强大的运算符，因为它可以无视种族隔离，随便搞。但就像生物的准则，不符合自然规律的随意杂交只会得到不能长久生存的物种。随意在不同类型之间使用reinterpret_cast，也之后造成程序的破坏和不能使用。其实就是转成jlong类型
    return reinterpret_cast<jlong>(surface.get());
    
}
~~~

### 标记为G

~~~c
sp<SurfaceControl> SurfaceComposerClient::createSurface(
        const String8& name,
        uint32_t w,
        uint32_t h,
        PixelFormat format,
        uint32_t flags)
{
    sp<SurfaceControl> sur;
    if (mStatus == NO_ERROR) {
        sp<IBinder> handle;
        sp<IGraphicBufferProducer> gbp;
        //这里其实是跨进程通信，我们后面会讲，要很后面了！这里标记为G，你现在只需要知道这个就是创建SurfaceControl对象就好
        status_t err = mClient->createSurface(name, w, h, format, flags,
                &handle, &gbp);
        ALOGE_IF(err, "SurfaceComposerClient::createSurface error %s", strerror(-err));
        if (err == NO_ERROR) {
            sur = new SurfaceControl(this, handle, gbp);
        }
    }
    return sur;
}
~~~

这里就是创建WMS进程的SurfaceControl对象以及SurfaceControl的native对象的过程

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/Surface.java 
public void copyFrom(SurfaceControl other) {
        if (other == null) {
            throw new IllegalArgumentException("other must not be null");
        }

        long surfaceControlPtr = other.mNativeObject;
        if (surfaceControlPtr == 0) {
            throw new NullPointerException(
                    "SurfaceControl native object is null. Are you using a released SurfaceControl?");
        }
    
    //可以看到从native层的SurfaceControl创建native层的Surface！！！
        long newNativeObject = nativeCreateFromSurfaceControl(surfaceControlPtr);

        synchronized (mLock) {
            if (mNativeObject != 0) {
                nativeRelease(mNativeObject);
            }
            setNativeObjectLocked(newNativeObject);
        }
    }
~~~

这个方法是在native层jni的Surface类

~~~c
//media/ba/sd/aosp/frameworks/base/core/jni/android_view_Surface.cpp
static jlong nativeCreateFromSurfaceControl(JNIEnv* env, jclass clazz,
        jlong surfaceControlNativeObj) {
    /*
     * This is used by the WindowManagerService just after constructing
     * a Surface and is necessary for returning the Surface reference to
     * the caller. At this point, we should only have a SurfaceControl.
     */

    sp<SurfaceControl> ctrl(reinterpret_cast<SurfaceControl *>(surfaceControlNativeObj));
    //你看这里就生成了native的surface！！！！
    sp<Surface> surface(ctrl->getSurface());
    if (surface != NULL) {
        surface->incStrong(&sRefBaseOwner);
    }
    return reinterpret_cast<jlong>(surface.get());
}

~~~

看看这个getSurface,这个getSurface不是JNI的方法了！！！而是native层的SurfaceControl的方法

~~~c
///media/ba/sd/aosp/frameworks/native/libs/gui/SurfaceControl.cpp
sp<Surface> SurfaceControl::getSurface() const
{
    Mutex::Autolock _l(mLock);
    if (mSurfaceData == 0) {
        // This surface is always consumed by SurfaceFlinger, so the
        // producerControlledByApp value doesn't matter; using false.
        //生成一个native层的Surface
         mSurfaceData = new Surface(mGraphicBufferProducer, false);
    }
    return mSurfaceData;
}

~~~

到了这里，WMS临时生成的Surface对象，已经万事俱备了！！！接下来就是分析在WMS所处进程的Surface的WriteToParcel函数做了什么

### 标记F

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/Surface.java    
@Override
    public void writeToParcel(Parcel dest, int flags) {
        if (dest == null) {
            throw new IllegalArgumentException("dest must not be null");
        }
        synchronized (mLock) {
            dest.writeString(mName);
            //调用了jni的方法
            nativeWriteToParcel(mNativeObject, dest);
        }
        
        //注意这个方法！！等下会讲，标记为F
        if ((flags & Parcelable.PARCELABLE_WRITE_RETURN_VALUE) != 0) {
            release();
        }
    }
~~~

~~~c
//media/ba/sd/aosp/frameworks/base/core/jni/android_view_Surface.cpp
static void nativeWriteToParcel(JNIEnv* env, jclass clazz,
        jlong nativeObject, jobject parcelObj) {
    Parcel* parcel = parcelForJavaObject(env, parcelObj);
    if (parcel == NULL) {
        doThrowNPE(env);
        return;
    }
    sp<Surface> self(reinterpret_cast<Surface *>(nativeObject));
    android::view::Surface surfaceShim;
    if (self != nullptr) {
        surfaceShim.graphicBufferProducer = self->getIGraphicBufferProducer();
    }
    // Calling code in Surface.java has already written the name of the Surface
    // to the Parcel
    surfaceShim.writeToParcel(parcel, /*nameAlreadyWritten*/true);
}
~~~

可以看到调用了native层的Surface的方法

~~~c
//media/ba/sd/aosp/frameworks/native/libs/gui/Surface.cpp
status_t Surface::writeToParcel(Parcel* parcel, bool nameAlreadyWritten) const {
    if (parcel == nullptr) return BAD_VALUE;

    status_t res = OK;

    if (!nameAlreadyWritten) res = parcel->writeString16(name);

    if (res == OK) {
        res = parcel->writeStrongBinder(
                IGraphicBufferProducer::asBinder(graphicBufferProducer));
    }
    return res;
}
~~~

看吧！就是打包发送数据而已。我们先看看上面的标记F

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/Surface.java    
@Override
    public void writeToParcel(Parcel dest, int flags) {
        if (dest == null) {
            throw new IllegalArgumentException("dest must not be null");
        }
        synchronized (mLock) {
            dest.writeString(mName);
                     nativeWriteToParcel(mNativeObject, dest);
        }
        
  
        if ((flags & Parcelable.PARCELABLE_WRITE_RETURN_VALUE) != 0) {
            release();
        }
    }
~~~

这个方法就是去释放native层的Surface而已。我们看看代码

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/Surface.java  
/**
     * Release the local reference to the server-side surface.
     * Always call release() when you're done with a Surface.
     * This will make the surface invalid.
     */
    public void release() {
        synchronized (mLock) {
            if (mNativeObject != 0) {
                //这里
                nativeRelease(mNativeObject);
                setNativeObjectLocked(0);
            }
            if (mHwuiContext != null) {
                mHwuiContext.destroy();
                mHwuiContext = null;
            }
        }
    }
~~~

看看jni层

~~~c
static void nativeRelease(JNIEnv* env, jclass clazz, jlong nativeObject) {
    //干掉native层的Surface的强指针！！
    sp<Surface> sur(reinterpret_cast<Surface *>(nativeObject));
    sur->decStrong(&sRefBaseOwner);
}

~~~



接下来分析在我们进程VIewRootImp的Surface的readFromParcel函数做了什么

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/Surface.java    
public void readFromParcel(Parcel source) {
        if (source == null) {
            throw new IllegalArgumentException("source must not be null");
        }

        synchronized (mLock) {
            // nativeReadFromParcel() will either return mNativeObject, or
            // create a new native Surface and return it after reducing
            // the reference count on mNativeObject.  Either way, it is
            // not necessary to call nativeRelease() here.
            mName = source.readString();
            setNativeObjectLocked(nativeReadFromParcel(mNativeObject, source));
        }
    }
~~~

就是读数据，填充自己啦！！

## 小结

两次进程通信和我们猜想的是一样的，直接看时序图

![image](http://wiki.jikexueyuan.com/project/deep-android-v1/images/chapter8/image007.png)

经过这次分析，我们终于看到了JNI技术在安卓的使用！！可以说是实战了一次，在之前学习JNI技术的时候可是无聊的很呀！而且这里还涉及到智能指针，你可以看到无处不是，只是因为作用域的分析太困难，但是我们可以看到很多地方去增加计数！！释放sp的地方也有，我特地讲了，还记得吗？就是Surface的releass方法！在标记F。

我们看看这两次进程通信都生成了哪些重要的对象

+ SurfaceSession（这个上面我们并没有很详细的分析，因为他是重头戏，后面会慢慢分析，目前我们知道就是创建Surface的时候作为参数传进去）
+ SurfaceComposerClient（这个在创建SurfaceControl的时候用到）
+ SurfaceControl（创建Surface）
+ Surface（这个我目前就知道要创建他，知道他和画图有关）

上面的对象都有大用，而 我们现在对他们一无所知，也就是说我们才刚刚创建完他们，为他们初始化！！！！气吧！讲了1万多字才完成了初始化，继续看下去吧！！

## Surface和画图（第二次想分析绘制）

经历了长长无趣的分析，我们终于知道VIewRootImp的Surface是怎么来的啦！！现在让我们回到绘制的代码

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java  
private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff,
            boolean scalingRequired, Rect dirty) {

        // 看到这个的时候，虎躯一震！这不就是画布吗！！！！
        final Canvas canvas;
        try {
         
            ...

            //锁住
            canvas = mSurface.lockCanvas(dirty);

      ....
          		//绘制！！！
                mView.draw(canvas);

       ...
            
        } finally {
            try {
                //解锁
                surface.unlockCanvasAndPost(canvas);
            }
            ...
        }
        return true;
    }

~~~

三步走：

+ lockCanvas
+ draw
+ unlockCanvasAndPost

该过程就是获得一块存储区域，然后绑定给Canvas。在第二步的VIew.draw（）中的ui操作都是在这块存储区域记录的。接下来的第三步就是把这些数据给到对应的引擎去处理然后放到显示设备显示。这里面的东西我们后面会很详细的讲解。（这也是我们开篇的目的！）

现在我们要回到上一次的小结中，把哪些未知的对象给搞懂。为什么呢？上面其实我们都是在走流程，知道了代码的基本走向，但是很具体的技术我们并没有学到，java层都只是在调接口，我们分析了半天就是在研究流程，研究流程的好处就是：我们把安卓WIndow到Surface的架构搞懂了，我是很贪心的，我想知道Surface和绘制到底有什么关系，所以为了了解深入一点，我们需要按照下面的流程图，对代码进行更加深入的分析！！看图

![image](http://wiki.jikexueyuan.com/project/deep-android-v1/images/chapter8/image009.png)

按照这个流程图，我们最终就会知道安卓系统是怎么绘制的，工欲善必先利其器，我们先要把用到的对象给搞清楚！！

## SurfaceComposerClient

很早就出现了这个东西，到底是个什么呢？你看他中文翻译多厉害：Compser-作曲家！其实真正处理图像混合的东西叫：SurfaceFlinger。SurfaceComposerClient和SurfaceFlinger到底有什么关系呢？SurfaceFlinger继承于SurfaceComposer！！！！！现在你知道他们是什么关系了吧？

与SurfaceFlinger相关的基础知识：

> SurfaceFlinger的作用主要是merge Surface,用于接受多个来源的图形显示数据，然后将他们合称发送到显示设备。
>
> SurfaceFlinger 是一个独立的Service， 它接收所有Window的Surface作为输入，根据ZOrder， 透明度，大小，位置等参数，计算出每个Surface在最终合成图像中的位置，然后交由HWComposer或OpenGL生成最终的显示Buffer, 然后显示到特定的显示设备上。
>
> 在Android底层绘制系统中，SurfaceFlinger 为App进程创建具体的Surface, 在SurfaceFlinger里对应成Layer, 然后负责管理、合成显示。Layer是SurfaceFlinger 进行合成的基本操作单元。Layer是在应用请求创建Surface的时候在SurfaceFlinger内部创建，因此一个Surface对应一个 Layer, 但注意，Surface不一定对应于Window，Android中有些Surface并不跟某个Window相关，而是有程序直接创建，比如说 StrictMode， 一块红色的背景，用于提示示Java代码中的一些异常, 还有SurfaceView, 用于显示有硬件输出的视频内容等。



来自：<http://www.cnblogs.com/samchen2009/p/3364327.html>

我们看看SurfaceComposerClient初始化的地方！

~~~java
public final class SurfaceSession {
    // Note: This field is accessed by native code.
    //看这里，官方注释！！！SurfaceComposerClient*！！！
    private long mNativeClient; // SurfaceComposerClient*

    private static native long nativeCreate();
    private static native void nativeDestroy(long ptr);
    private static native void nativeKill(long ptr);

    /** Create a new connection with the surface flinger. */
    public SurfaceSession() {
        //在这里创建
        mNativeClient = nativeCreate();
    }

    /* no user serviceable parts here ... */
    @Override
    protected void finalize() throws Throwable {
        try {
            if (mNativeClient != 0) {
                nativeDestroy(mNativeClient);
            }
        } finally {
            super.finalize();
        }
    }

    /**
     * Forcibly detach native resources associated with this object.
     * Unlike destroy(), after this call any surfaces that were created
     * from the session will no longer work.
     */
    public void kill() {
        nativeKill(mNativeClient);
    }
}
~~~

SurfaceSession里面的nativeObject居然是SurfaceComposerClient！！！看他对应的JNI函数

~~~java
//media/ba/sd/aosp/frameworks/base/core/jni/android_view_SurfaceSession.cpp
static jlong nativeCreate(JNIEnv* env, jclass clazz) {
    SurfaceComposerClient* client = new SurfaceComposerClient();
     client->incStrong((void*)nativeCreate);
    return reinterpret_cast<jlong>(client);
}
~~~

看构造

~~~java
///media/ba/sd/aosp/frameworks/native/libs/gui/SurfaceComposerClient.cpp
SurfaceComposerClient::SurfaceComposerClient()
    : mStatus(NO_INIT), mComposer(Composer::getInstance())
{
}

~~~

可以看到构造里面是空的，但是！！！onFirstRef方法里面才进行初始化！要不是我学过JNI，就真找不到这个初始化的代码了！！！

~~~c
//media/ba/sd/aosp/frameworks/native/libs/gui/SurfaceComposerClient.cpp
void SurfaceComposerClient::onFirstRef() {
    //没骗你吧！进行通信，拿到ISurfaceComposer，真实对象是BpSurfaceComposer
    sp<ISurfaceComposer> sm(ComposerService::getComposerService());
    if (sm != 0) {
        //进行连接
        sp<ISurfaceComposerClient> conn = sm->createConnection();
        if (conn != 0) {
            mClient = conn;
            mStatus = NO_ERROR;
        }
    }
}
~~~

刚刚我们说过SurfaceFlinger继承与SurfaceComposer，所以这里其实是在和SurfaceFlinger进行Connection！！

~~~c
//media/ba/sd/aosp/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
sp<ISurfaceComposerClient> SurfaceFlinger::createConnection()
{
    //BClient：这是用来Binder通信的，作用是用来接收客户端请求，然后把请求提交给SF处理
    sp<ISurfaceComposerClient> bclient;
    //为什么会有这个？
    sp<Client> client(new Client(this));
    
    //这个方法
    status_t err = client->initCheck();
    if (err == NO_ERROR) {
        //Client继承于ISurfaceComposerClient
        bclient = client;
    }
    return bclient;
}

~~~

可以看到我们客户端这一次生成的WIndow通过createConnection后拿到了    sp<ISurfaceComposerClient> bclient;这样就能和SurfaceFlinger进进程通信了！一个应用程序只具有一个SurfaceComposerClient对象！为什么呢？因为在创建SurfaceSession的时候不就有个判空？如果已经有了我们进程SurfaceSession，WMS进程就不会打开第二个SurfaceSession了！而SurfaceComposerClient又是在SurfaceSession构造函数里面创建的，所以当然是一个进程只有一个！！而且，和SurfaceFlinger进程交互，只需要一个Bp端就够了呀！

接下来我们看看Client是什么： 这个对象十分重要，后面会讲到，它维护这应用程序的渲染核心数据，并负责与`SurfaceFlinger`通信,以及用来创建Surface，销毁Surface，获取和清除Surface信息。我们看看他内容就知道了。

~~~c
//media/ba/sd/aosp/frameworks/native/services/surfaceflinger/Client.h
amespace android {

// ---------------------------------------------------------------------------

   //核心数据
class Layer;
class SurfaceFlinger;

// ---------------------------------------------------------------------------

class Client : public BnSurfaceComposerClient
{
public:
        Client(const sp<SurfaceFlinger>& flinger);
        ~Client();

    status_t initCheck() const;

    
    // protected by SurfaceFlinger::mStateLock
    void attachLayer(const sp<IBinder>& handle, const sp<Layer>& layer);

    void detachLayer(const Layer* layer);

    sp<Layer> getLayerUser(const sp<IBinder>& handle) const;

private:
    // ISurfaceComposerClient interface //创建
    virtual status_t createSurface(
            const String8& name,
            uint32_t w, uint32_t h,PixelFormat format, uint32_t flags,
            sp<IBinder>* handle,
            sp<IGraphicBufferProducer>* gbp);

    //销毁
    virtual status_t destroySurface(const sp<IBinder>& handle);

    //清除信息
    virtual status_t clearLayerFrameStats(const sp<IBinder>& handle) const;

    //获取信息
    virtual status_t getLayerFrameStats(const sp<IBinder>& handle, FrameStats* outStats) const;
    virtual status_t getTransformToDisplayInverse(
            const sp<IBinder>& handle, bool* outTransformToDisplayInverse) const;

    //和SurfaceFlinger通信
    virtual status_t onTransact(
        uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags);

    // constant
    sp<SurfaceFlinger> mFlinger;

    // protected by mLock 这个后面会讲
    DefaultKeyedVector< wp<IBinder>, wp<Layer> > mLayers;

    // thread-safe
    mutable Mutex mLock;
};

// ---------------------------------------------------------------------------
}; // namespace android

#endif // ANDROID_SF_CLIENT_H

~~~

到这里SurfaceComposerClient就初始化完成了！

### 小结

其实就是去生成或者获取到SurfaceFlinger的代理端，一个程序只有一个SurfaceComposerClient，也就是一个SurfaceSession！而在很前面的时候我们的进程是和WMS进行进程通信，SurfaceFlinger进程依附于SystemService的服务，我们的进程通过和WMS的进程通信，要求WMS进程去给我们开启一个SurfaceSession，其实就是去和SurfaceFlinger进程进行connection。就是获取到SurfaceFlinger的Bp端，然后返回给我们的进程，这里我们可以看出安卓系统的一个架构：当我们java层的进程需要用到一些系统级别（但是不想暴露给上层）的进程服务时，都是通过我们的jave中的SystemService里面的WMS或者PMS。。。。这些服务为我们去获取到目标进程的Bp端，然后返回到我们的进程，这样我们的进程就能使用到这些进程的服务了。

我们回到流程图

![image](http://wiki.jikexueyuan.com/project/deep-android-v1/images/chapter8/image009.png)

## SurfaceControl

现在我们看看SurfaceControl是怎么创建的，我们上面并没有详细讲SurfaceControl是怎么创建的，现在我们来看看

~~~c
//media/ba/sd/aosp/frameworks/base/core/jni/android_view_SurfaceControl.cpp
static jlong nativeCreate(JNIEnv* env, jclass clazz, jobject sessionObj,
        jstring nameStr, jint w, jint h, jint format, jint flags) {
    ScopedUtfChars name(env, nameStr);
    
  ...
    sp<SurfaceComposerClient> client(android_view_SurfaceSession_getClient(env, sessionObj));
    
    //就是这里，我们上次说他这里是进行进程通信，经过上面的分析后现在我们知道他是和谁进程通信了！！！！
      sp<SurfaceControl> surface = client->createSurface(
            String8(name.c_str()), w, h, format, flags);
    if (surface == NULL) {
        jniThrowException(env, OutOfResourcesException, NULL);
        return 0;
    }
 ..
    return reinterpret_cast<jlong>(surface.get());
    
}

~~~

通过SurfaceFlinger创建SurfaceControl对象，这一次我们就不看Bp端的内容了，因为Bp端肯定又是直接new个SurfaceControl出来，等这次进程通信完后从数据包拿数据进行填充，所以这次进程通信我们直接看SurfaceFlinger的对应方法看他里面到底干了什么就好了

~~~c
status_t Client::createSurface(
        const String8& name,
        uint32_t w, uint32_t h, PixelFormat format, uint32_t flags,
        sp<IBinder>* handle,
        sp<IGraphicBufferProducer>* gbp)
{
    /*
     * createSurface must be called from the GL thread so that it can
     * have access to the GL context.，这里写的很清楚了，就是为了保证可以使用GL的Context，所以才要post到那个 线程，其实这里就是通知SurfaceFlinger去创建Surface啦！
     */

    class MessageCreateLayer : public MessageBase {
        SurfaceFlinger* flinger;
        Client* client;
        sp<IBinder>* handle;
        sp<IGraphicBufferProducer>* gbp;
        status_t result;
        const String8& name;
        uint32_t w, h;
        PixelFormat format;
        uint32_t flags;
    public:
        MessageCreateLayer(SurfaceFlinger* flinger,
                const String8& name, Client* client,
                uint32_t w, uint32_t h, PixelFormat format, uint32_t flags,
                sp<IBinder>* handle,
                sp<IGraphicBufferProducer>* gbp)
            : flinger(flinger), client(client),
              handle(handle), gbp(gbp), result(NO_ERROR),
              name(name), w(w), h(h), format(format), flags(flags) {
        }
        status_t getResult() const { return result; }
        virtual bool handler() {
            //注意这句！！！为什么是创建Layer？？这里注意一下最后的参数，Handle和gbp
            result = flinger->createLayer(name, client, w, h, format, flags,
                    handle, gbp);
            return true;
        }
    };

    //注意里面参数的This！！这个this，就是我们createConnection方法生成的那个！！
    sp<MessageBase> msg = new MessageCreateLayer(mFlinger.get(),
            name, this, w, h, format, flags, handle, gbp);
    mFlinger->postMessageSync(msg);
    //他返回的对象是Layer！！！！说明surface对应着一个Layer，其实Surface的功能主要是Layer做的！，这个status_t其实就是一个整形值用来判断结果是否正确而已
    return static_cast<MessageCreateLayer*>( msg.get() )->getResult();
}
~~~

现在我们是在是没有办法了！必须要讲Layer是什么东西了！！！ 

### Layer

#### 显示层（Layer）和屏幕组成

你了解屏幕显示的漂亮界面是如何组织的吗？来看图8-10所展示的屏幕组成示意图：

![image](http://wiki.jikexueyuan.com/project/deep-android-v1/images/chapter8/image010.png)

图8-10  屏幕组成示意图

从图8-10中可以看出：

·  屏幕位于一个三维坐标系中，其中Z轴从屏幕内指向屏幕外。

·  编号为①②③的矩形块叫显示层（Layer）。每一层有自己的属性，例如颜色、透明度、所处屏幕的位置、宽、高等。除了属性之外，每一层还有自己对应的显示内容，也就是需要显示的图像。

在Android中，Surface系统工作时，会由SurfaceFlinger对这些按照Z轴排好序的显示层进行图像混合，混合后的图像就是在屏幕上看到的美妙画面了。这种按Z轴排序的方式符合我们在日常生活中的体验，例如前面的物体会遮挡住后面的物体。

注意，Surface系统中定义了一个名为Layer类型的类，为了区分广义概念上的Layer和代码中的Layer，这里称广义层的Layer为显示层，以免混淆。

Surface系统提供了三种属性，一共四种不同的显示层。简单介绍一下：

·  第一种属性是eFXSurfaceNormal属性，大多数的UI界面使用的就是这种属性。它有两种模式：

​       1）Normal模式，这种模式的数据，是通过前面的mView.draw(canvas)画上去的。这也是绝大多数UI所采用的方式。

​       2）PushBuffer模式，这种模式对应于视频播放、摄像机摄录/预览等应用场景。以摄像机为例，当摄像机运行时，来自Camera的预览数据直接push到Buffer中，无须应用层自己再去draw了。

·  第二种属性是eFXSurfaceBlur属性，这种属性的UI有点朦胧美，看起来很像隔着一层毛玻璃。

·  第三种属性是eFXSurfaceDim属性，这种属性的UI看起来有点暗，好像隔了一层深色玻璃。从视觉上讲，虽然它的UI看起来有点暗，但并不模糊。而eFXSurfaceBlur不仅暗，还有些模糊。

图8-11展示了最后两种类型的视觉效果图，其中左边的是Blur模式，右边的是Dim模式。

​           

![image](http://wiki.jikexueyuan.com/project/deep-android-v1/images/chapter8/image011.png)![image](http://wiki.jikexueyuan.com/project/deep-android-v1/images/chapter8/image012.png)

图8-11  Blur和Dim效果图

注意，关于Surface系统的显示层属性定义，读者可参考ISurfaceComposer.h。

现在我们知道Layer是什么东西了，现在让我们看看Layer创建的代码

### 标记H

~~~c
status_t SurfaceFlinger::createLayer(
        const String8& name,
        const sp<Client>& client,
        uint32_t w, uint32_t h, PixelFormat format, uint32_t flags,
        sp<IBinder>* handle, sp<IGraphicBufferProducer>* gbp)
{
    ...

      //等下我们生成的Layer将要放在这里面
    sp<Layer> layer;

    //果然是创建不同的显示层效果霍
    switch (flags & ISurfaceComposerClient::eFXSurfaceMask) {
        case ISurfaceComposerClient::eFXSurfaceNormal:
            //我们注意看这个，这个就是我们上面说的普通效果的显示层，注意！这里也用到了handle和gbp
            result = createNormalLayer(client,
                    name, w, h, flags, format,
                    handle, gbp, &layer);
            break;
        case ISurfaceComposerClient::eFXSurfaceDim:
            result = createDimLayer(client,
                    name, w, h, flags,
                    handle, gbp, &layer);
            break;
        default:
            result = BAD_VALUE;
            break;
    }

    if (result != NO_ERROR) {
        return result;
    }

    //这个方法我们等下讲，标记为H，注意这个Client，上面有说过的！
    result = addClientLayer(client, *handle, *gbp, layer);
    if (result != NO_ERROR) {
        return result;
    }

    setTransactionFlags(eTransactionNeeded);
    return result;
}
~~~

我们看看createNormalLayer方法

~~~c
status_t SurfaceFlinger::createNormalLayer(const sp<Client>& client,
        const String8& name, uint32_t w, uint32_t h, uint32_t flags, PixelFormat& format,
        sp<IBinder>* handle, sp<IGraphicBufferProducer>* gbp, sp<Layer>* outLayer)
{
    // initialize the surfaces
    switch (format) {
    case PIXEL_FORMAT_TRANSPARENT:
    case PIXEL_FORMAT_TRANSLUCENT:
        format = PIXEL_FORMAT_RGBA_8888;
        break;
    case PIXEL_FORMAT_OPAQUE:
        format = PIXEL_FORMAT_RGBX_8888;
        break;
    }

    *outLayer = new Layer(this, client, name, w, h, flags);
    status_t err = (*outLayer)->setBuffers(w, h, format, flags); //把新建的layer的指针拷贝给outLayer,这样outLayer就指向了新建的Layer
    if (err == NO_ERROR) {
       //这里等下会讲
        *handle = (*outLayer)->getHandle();//获取 handle
        *gbp = (*outLayer)->getProducer(); //获取 生产者

    }

    ALOGE_IF(err, "createNormalLayer() failed (%s)", strerror(-err));
    return err;
}

~~~

主要做了4步

+ 构造函数

+ setBuffers
+ 获取  handle
+ 获取 IGraphicBufferProducer

构造函数,没有我想关注的东西，看onFirstRef函数

### 标记I

~~~c

//media/ba/sd/aosp/frameworks/native/services/surfaceflinger/Layer.cpp
void Layer::onFirstRef() {
    
    //注意看这两个东西一个是生产者一个是消费者，他们是两个Buffer，
    // Creates a custom BufferQueue for SurfaceFlingerConsumer to use
    sp<IGraphicBufferProducer> producer;
    sp<IGraphicBufferConsumer> consumer;
       BufferQueue::createBufferQueue(&producer, &consumer);
    
    
    //MonitoredProducer是对BufferQueueProducer的封装，其目的，就是Producer销毁时，能通知SurfaceFlinger。这就是取名Monitored的愿意。余下的，MonitoredProducer的很多接口都是直接调，对应的BufferQueueProducer的实现。
    mProducer = new MonitoredProducer(producer, mFlinger);

    //标记I
    mSurfaceFlingerConsumer = new SurfaceFlingerConsumer(consumer, mTextureName,
            this);
    mSurfaceFlingerConsumer->setConsumerUsageBits(getEffectiveUsage(0));
   
    mSurfaceFlingerConsumer->setContentsChangedListener(this);
    mSurfaceFlingerConsumer->setName(mName);

#ifdef TARGET_DISABLE_TRIPLE_BUFFERING
#warning "disabling triple buffering"
#else
    
   //这里是指生产者最大可以申请两个缓冲区，这里很重要，后面会详细讲
    mProducer->setMaxDequeuedBufferCount(2);
#endif

    
    const sp<const DisplayDevice> hw(mFlinger->getDefaultDisplayDevice());
    updateTransformHint(hw);
}
~~~

我们可以看到基本都是在处理Buffer，到了这里，我们就要正式开始介绍SurfaceFlinger和图像缓冲的知识了，这里引用一个大佬的讲解：

> 我们将App绘图类比为向画板中画画，但是与画画不同的是，我们的绘制UI其实是写入UI的像素数据，这些数据最终将被渲染到屏幕上，屏幕上的像素点显示对应坐标的像素值。那么问题来了，我们怎么向屏幕中写入数据呢？别忘了，Android是基于Linux的，Linux系统有个Framebuffer，我们只要向这个FrameBuffer中写入数据，系统就会在一个合适的时机从Framebuffer中取出数据，渲染到屏幕上。那么我们是不是只要将app的UI数据写入到这个FrameBuffer就可以了呢？
>
> 事实上，这是不可取的，因为Android系统里安装了很多app，每个App又会有很多Surface，可是屏幕只有一个，如果大家同时都往屏幕上直接写数据，岂不是乱套了，所以Android就搞了一个SurfaceFlinger，专门来负责这件事。屏幕相当于学校里的的画廊，SurfaceFlinger就是负责画廊的老师，它给每个学生发了一张纸，告诉大家将自己的画画在自己的纸上，最后再交给老师（SurfaceFlinger），老师再将大家的画整理一下，按照一定顺序贴到画廊（屏幕）上。
>
> 画画的例子告诉我们，老师会给每个学生都发一张纸，所以SurfaceFlinger也会给每个Activity分配一个缓冲区来绘制UI，这些缓冲区叫图形缓冲区，而上面的Framebuffer叫帧缓冲区。但是事实上，学校里有很多学生（Surface），每个学生画完一张，交给SurfaceFlinger后，SurfaceFlinger又要接着给他再发一张，如果负责画廊的老师（SurfaceFlinger）一个个去给每个学生（Surface）收发画纸（缓冲区），岂不要累死，所以每个学生（Surface）又会有个助理老师来负责发画纸，收画纸这件事，而这个助理就是BufferQueue。
>
> **BufferQueue采用了生产者-消费者的模式：**其中生产者为BufferQueueProducer，通过调用dequeBuffer（）获取到一个空闲的缓冲区，并填入要绘制的图形数据，接着调用queueBuffer（）将Buffer重新返回给BufferQueue。而消费者则为BufferQueueConsumer，通过调用acquireBuffer（）从BufferQueue中拿到一个被填满的缓冲区并消费。（这里说明这三者都是有回调监听的！）
>
> Surface并不关心消费者，因为它应该不管这件事，它的责任是拿到空闲的缓冲区，并绘制自己的UI数据，所以它需要的是空闲缓冲区的生产者，及BufferQueueProducer。
> 
> 来源：<https://zhuanlan.zhihu.com/p/30535788>

所以我们现在终于知道IGraphicBufferProducer是什么了，这也 能解释了为什么在创建完Layer后，我们给SurfaceControl的是生产者，而不是消费者了，正如上面说的，surface只关注生产就好了！！！不记得了？我们看看代码

~~~c
status_t SurfaceFlinger::createNormalLayer(const sp<Client>& client,
        const String8& name, uint32_t w, uint32_t h, uint32_t flags, PixelFormat& format,
        sp<IBinder>* handle, sp<IGraphicBufferProducer>* gbp, sp<Layer>* outLayer)
{
    // initialize the surfaces
    switch (format) {
    case PIXEL_FORMAT_TRANSPARENT:
    case PIXEL_FORMAT_TRANSLUCENT:
        format = PIXEL_FORMAT_RGBA_8888;
        break;
    case PIXEL_FORMAT_OPAQUE:
        format = PIXEL_FORMAT_RGBX_8888;
        break;
    }

   
    *outLayer = new Layer(this, client, name, w, h, flags);
    status_t err = (*outLayer)->setBuffers(w, h, format, flags); 
    if (err == NO_ERROR) {
        *handle = (*outLayer)->getHandle();//获取 handle
        *gbp = (*outLayer)->getProducer(); //看这里！！！！给的是生产者

    }

    ALOGE_IF(err, "createNormalLayer() failed (%s)", strerror(-err));
    return err;
}
~~~

我们就知道BufferQueue的作用就好了，后面会详细讲他！！为我们的Layer绑定了生产者后，绑定各种监听了，因为生产者和消费者和BufferQueue之间需要相互通信呀！！！具体我们后详细的讲。

现在我们回到为SurfaceControl生成Layer后的代码

我们看看标记H处的addClientLayer(handle)做了什么，因为他传了这个Handle和layer过去

~~~java
status_t SurfaceFlinger::addClientLayer(const sp<Client>& client,
        const sp<IBinder>& handle,
        const sp<IGraphicBufferProducer>& gbc,
        const sp<Layer>& lbc)
{
    // add this layer to the current state list
    {
        Mutex::Autolock _l(mStateLock);
        if (mCurrentState.layersSortedByZ.size() >= MAX_LAYERS) {
            return NO_MEMORY;
        }
        //将当前显示层添加到z轴！！！
        mCurrentState.layersSortedByZ.add(lbc);
        //把创建的Layer加入这个GBp集合里面
        mGraphicBufferProducerList.add(IInterface::asBinder(gbc));
    }

    // attach this layer to the client
    //这个Client就是前面createConnection方法里面生成的Client，
    client->attachLayer(handle, lbc);

    return NO_ERROR;
}
~~~

我们现在看看attachLayer，做了什么

~~~java
//media/ba/sd/aosp/frameworks/native/services/surfaceflinger/Client.h
void Client::attachLayer(const sp<IBinder>& handle, const sp<Layer>& layer)
{
    Mutex::Autolock _l(mLock);
    mLayers.add(handle, layer);
}

~~~

这里就是加入到Client（一个程序进程对应一个！）里面的集合，这个你有没发现我们生成的Layer并没有存到我们的Surface中，而是放在了这个client的mLayers集合里面？说白了我们的应用程序是建立多了Layer，SurfaceFlinger不仅没有明确限制，还替他应用程序进行了Layer的管理。需要注意的是，创建Layer的时候我们是传了个handle，这个handle到底有什么用呢？他是这个Layer的句柄，是便于后面查找对应的Layer！那SurfaceControl就初始化成功了!小结一下

### 小结

这个SurfaceControl真的名不虚传，他生成的时候去生成一个Layer，然后把Layer放在Client中（我们程序的所有Layer都放在这个CLient中），这个Layer我们说过叫显示层，还有一个：BufferQueue。而且这个BufferQueue还分配了生产者和消费者，生产者就是自己要用的，而消费者是和SurfaceFlinger进行传输数据用的。到这里你其实就发现一个问题：安卓中的jave层所有与native有关的东西，真正的具体功能实现都是native的对象完成，java层的都是封装而已，最后都是通过JNI技术去让在Native层的对象去实现。

这里需要注意的有几个点：

+ 生产者是给我们的应用程序进程进行调用的，他其实就是一个Bp端，对应的Bn端在SurfaceFlinger进程里面，而Bn端肯定是把画好的缓冲区放到BufferQueue里面，然后BufferQueue再通知消费者，所以他们肯定是互相有监听回调的，但是我们上面没有讲，因为篇幅太长了，后面讲到绘制的时候肯定会经历这个步骤的，所以我们后面再讲。

回到流程图：那现在就是去看看



![image](http://wiki.jikexueyuan.com/project/deep-android-v1/images/chapter8/image009.png)



## 回到Surface的创建实现

在很前面我们讲的是Native层的Surface是被SurfaceControl的下面这个方法创建的

~~~c
///media/ba/sd/aosp/frameworks/native/libs/gui/SurfaceControl.cpp
sp<Surface> SurfaceControl::getSurface() const
{
    Mutex::Autolock _l(mLock);
    if (mSurfaceData == 0) {
        // This surface is always consumed by SurfaceFlinger, so the
        // producerControlledByApp value doesn't matter; using false.
        //生成一个native层的Surface，
         mSurfaceData = new Surface(mGraphicBufferProducer, false);
    }
    return mSurfaceData;
}
~~~

上面可以看到getSurface接口，根据bufferProducer代理对象创建了surface对象。这样有了mGraphicBufferProducer代理对象后，后续申请buffer就方便了。生产者代理对象，本地对象，Layer对象的关系如下图所示。应用的所有Layer都是放在Client里面的。 



![image](https://img-blog.csdn.net/20170617171421596?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXJtd2luZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)



就像前面说的，纸张已经发给学生了，现在就等学生画画啦！现在Surface对象就初始化好了！！！！

## 真正的大餐来了（缓冲区和绘图）

这部分书上写的不好，因为书上是安卓2.3的源码，我在网上找到个写的很好的，正好可以贯穿我们上面一些没有交代清楚的东西。

经历了上面的小菜，现在我们要上主食了！！我们理一下图像显示的流程，图像数据流动分为三个层

![image](https://lc-gold-cdn.xitu.io/853a307ead97cb002092.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)上层就是我们的应用层，先不管上层，我们先看下层，显示屏：

显示屏上的内容，是从硬件帧缓冲区读取的，大致读取过程为：从Buffer的起始地址开始，从上往下，从左往右扫描整个Buffer，将内容映射到显示屏上：

![img](https://lc-gold-cdn.xitu.io/48a317b3d397fc76cf3e.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)屏幕与帧缓冲区关系图1



当然，屏幕上的内容需要需要不断的更新，如果在同一个Buffer进行读取和写入（合成）操作，将会导致屏幕显示多帧内容。所以硬件层除了提供一个Buffer用于屏幕显示，还提供了一个Buffer用于后台的图形合成，也就是我们常说的双缓冲：

![img](https://lc-gold-cdn.xitu.io/62bd216a289d49f6eb7d.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)屏幕与帧缓冲区关系图2

上图中包含两个缓冲区：

前缓冲区：

用来显示内容到屏幕的帧缓冲区

后缓冲区：

用于后台合成下一帧图形的帧缓冲区



假设前一帧显示完毕，后一帧准备好了，屏幕将会开始读取下一帧的内容，也就是开始读取上图中的后缓冲区的内容：

![img](https://lc-gold-cdn.xitu.io/4dd66de09f421ea7a774.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)屏幕与帧缓冲区关系图途2



此时，前后缓冲区进行一次角色互换，之前的后缓冲区变为前缓冲区，进行图形的显示，之前的前缓冲区则变为后缓冲区，进行图形的合成。

然而，理想很丰满，现实很骨感，上面假设“当前一帧显示完毕，后一帧准备好了”的情况，在现实中这两个事件并非同时完成。那么，屏幕扫描缓冲区的速度和系统合成帧的速度之间有什么关系呢，带着这个疑惑我们看看下面两个概念：
**屏幕刷新率（HZ）：**代表屏幕在一秒内刷新屏幕的次数，Android手机一般为60HZ（也就是1秒刷新60帧，大约16.67毫秒刷新1帧）
**系统帧速率（FPS）：**代表了系统在一秒内合成的帧数，该值的大小由系统算法和硬件决定。

我们用以下两个假设来分析两者的关系：
① 屏幕刷新速率比系统帧速率快
此时，在前缓冲区内容全部映射到屏幕上之后，后缓冲区尚未准备好下一帧，屏幕将无法读取下一帧，所以只能继续显示当前一帧的图形，**造成一帧显示多次，也就是卡顿。**
② 系统帧速率比屏幕刷新率快
此时，屏幕未完全把前缓冲区的一帧映射到屏幕，而系统已经在后缓冲区准备好了下一帧，并要求读取下一帧到屏幕，将会导致屏幕上半部分是上一帧的图形，而下半部分是下一帧的图形，**造成屏幕上显示多帧，也就是屏幕撕裂。**

上面两种情况，都会导致问题，根本原因就是两个缓冲区的操作速率不一致，解决办法就是让屏幕控制前后缓冲区的切换，让系统帧速率配合屏幕刷新率的节奏。

那么屏幕是如何控制这个节奏的呢？

**垂直同步（VSync）：**当屏幕从缓冲区扫描完一帧到屏幕上之后，开始扫描下一帧之前，发出的一个同步信号，该信号用来切换前缓冲区和后缓冲区。

通过上面的分析可以看出，屏幕的显示节奏是固定的，操作系统需要配合屏幕的显示，在固定的时间内准备好下一帧，以供屏幕进行显示。两者通过VSync信号来实现同步。



如果说屏幕是消费者，那么SurfaceFlinger相对屏幕来说就是生产者，其具有如下特性：

- 作为上层应用的消费者，硬件层的生产者。
- 负责图形的合成
- 和ActivityManagerService一样，是一个系统服务

为了更好的理解SurfaceFlinger这个服务的工作内容，以及他是如何做到一个承上启下的作用，我们通过下面的这个界面分析：

![img](https://lc-gold-cdn.xitu.io/e862799fa448e939bf1a.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)这里写图片描述



界面很简单，拆开来看，包含微信、悬浮工具箱、通知栏、底部虚拟按键栏：

![img](https://lc-gold-cdn.xitu.io/89bc05cb52100766ea5d.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)界面对应的surface



我们可以先这样理解上面这幅图，上层每一个界面，其实都对应SufaceFlinger里的一个Surface对象，上层将自己的内容绘制在对应的Surface内，接着，SufaceFlinger需要将所有上层对应的Surface内的图形进行合成，具体看下图：

![img](https://lc-gold-cdn.xitu.io/4464feef355cd5bdf381.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)SurfaceFlinger合成过程



没错，SurfaceFlinger就是将多个Surface里的内容进行合成，最后提交到屏幕的后缓冲区，等待屏幕的下一个垂直同步信号的到来，再显示到屏幕上。

我们会发现SufaceFlinger通过屏幕后缓冲区与屏幕建立联系。同时通过Surface与上层建立联系。从而起到一个承上启下的作用，是Android图形系统结构中的关键组成部分。所以这个数据流动，真正的经历过程是这样的：

![image](https://lc-gold-cdn.xitu.io/bc253fdf3d5cc6f9b999.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



frameWork和显示屏的Buffer就是我们说的FramBuffer（帧缓冲），这个帧缓冲，已经讲的很清楚了，就是一个前帧和后帧。而这个上层和Framework的Buffer就是我们前面说的BufferQueue，他可以为Surface提供最大64个Buffer！怎么看出来的呢？

~~~c

#ifndef ANDROID_GUI_BUFFERQUEUECOREDEFS_H
#define ANDROID_GUI_BUFFERQUEUECOREDEFS_H

#include <gui/BufferSlot.h>

namespace android {
    class BufferQueueCore;

    namespace BufferQueueDefs {
        // BufferQueue will keep track of at most this value of buffers.
        // Attempts at runtime to increase the number of buffers past this
        // will fail.只能有64个缓冲区！！
        enum { NUM_BUFFER_SLOTS = 64 };

        typedef BufferSlot SlotsType[NUM_BUFFER_SLOTS];
    } // namespace BufferQueueDefs
} // namespace android

~~~

但是！！一个应用程序可不止一个Surface呀，我们回到图

![img](https://lc-gold-cdn.xitu.io/89bc05cb52100766ea5d.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

是不是很多呀！！而且我们在看创建Layer的时候也看到生产者最大只能拿到两个Buffer

~~~c
//media/ba/sd/aosp/frameworks/native/services/surfaceflinger/Layer.cpp
void Layer::onFirstRef() {
    
   ...

 //这一句官方注解等下会讲。而且非常重要
#ifdef TARGET_DISABLE_TRIPLE_BUFFERING
#warning "disabling triple buffering"
#else
    
   //这里是指生产者最大可以申请两个缓冲区，作为后帧，这里我们需要理解一下，因为现在是Buffer队列了，意味着你的Layer放入了一个Buffer到队列里面，放入的那个属于前帧了，取出空闲那个属于后帧，这里设置的意思就是可以取出两个后帧！！！！
    mProducer->setMaxDequeuedBufferCount(2);
#endif
    const sp<const DisplayDevice> hw(mFlinger->getDefaultDisplayDevice());
    updateTransformHint(hw);
}
~~~

这也同时说明一个Client最大只能放31个Layer！！为什么一个Layer能同时申请两个Buffer作为后帧呢？在安卓4,1以前Layer的Buffer的设计是和FrameBuffer一样的，只有一个前帧和一个后帧。

我们先假设我们的Layer只能申请一个空闲的Buffer，正常的情况就是这样的：

+ 我们的App通过先拿到一个空闲Buffer，然后调用Draw进行绘制
+ 绘制完后放回队列，同时又拿另一个空闲的Buffer出来进行绘制
+ 这个时候消费者正常取出要消费的Buffer
+ 然后我们的App进程绘制完后放回队列，同时又拿另一个空闲的Buffer出来进行绘制
+ 这个时候消费者正常取出要消费的Buffer

往复循环，好像没什么问题嚯，这属于一个前帧一个后帧了吧！现在我们就看在只有一个前帧和一个后帧的Layer的绘制流程。后面我们再讲有两个后帧的Layer的绘制流程！！！

## 垂直同步信号

还记得前面说的（VSync）垂直同步吗？在安卓4.1前我们的垂直同步是这样的：

![image](https://lc-gold-cdn.xitu.io/78c6579ffd792d84e129.jpg?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

这个图什么意思呢？cpu和gpu代表我们的程序和SurfaceFlinger，Composite代表SurfaceFlinger合成好的帧，后面两个就是FrameBuffer的前帧和后帧，我们的显示屏会发出一个垂直同步信号。这个信号会给到应用层和FrameBuffer，我们先看FrameBuffer的，一旦同步信号到了FrameBuffer，就会把前帧和后帧调换，显示器显示后帧内容，SurfaceFlinger作为消费者从BufferQueue拿到数据合成后把合成的Composite写到“新后帧”里面。我们现在一帧一帧分析

+ 上面的流程中，存在一个问题，屏幕的VSync信号只是用来控制帧缓冲区的切换，并未控制应用层的绘制节奏，也就是说应用层的生产节奏和屏幕的显示节奏是脱离的：

![image](https://lc-gold-cdn.xitu.io/a4f410466d58f8ac14ec.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



上图中，横轴表示时间，纵轴表示Layer的后帧Buffer的使用者，每个长方形表示Layer后帧Buffer的使用，长方形的宽度代表使用时长，VSync代表垂直同步信号，两个VSync信号之间间隔16.6ms。此图描述了Android在4.1系统版本之前，上层的绘图流程在没有VSync信号的时候，出现的绘制问题。



我们从时间为0开始看，当前屏幕显示第0帧，应用层的draw方法和SurfaceFlinger进行数据处理（上层CPU开始计算第1帧的纹理，计算完成后，交由GPU进行栅格化）。当下一个垂直同步信号到来，屏幕显示下一帧，这时候，上层CPU并未马上开始准备下一帧，而当CPU开始准备下一帧的时候已经太晚了(这里是指我们的程序没有调用draw方法的时间不对，我们手动调用draw方法就能马上触发绘制，他没有一套和显示器一样在规定时间交换前后帧，处理前后帧数据的机制，这就导致了我们draw的时机和屏幕Vsync信号不同步),下一个VSync信号来临的时候，GPU未能绘制完第二帧的处理，导致屏幕再次显示上一帧，造成卡顿：

![image](https://lc-gold-cdn.xitu.io/d0680ca4858f9182b50d.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

因为上层不知道VSync信号已经发出，导致上层未能开始CPU的计算。google在Android 4.1系统中加入了上层接收垂直同步信号的逻辑，大致流程如下：

## 升级版的垂直同步

![image](https://lc-gold-cdn.xitu.io/60c10f0847f270b5c10b.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

也就是说，屏幕在显示完一帧后，发出的垂直同步除了通知帧缓冲区的切换之外，该消息还会发送到上层，通知上层开始绘制下一帧。

那么，上层是如何接受这个VSync消息的呢？Google为上层设计了一个Choreographer类，翻译成中文是“编舞者”，是希望通过它来控制上层的绘制（舞蹈）节奏。既然是上层的App的draw方法，那肯定是在VIewRootImp里面，因为他管理了VIew的整个绘制过程，我们回到前面我们一直有疑惑的地方：我们当时研究的是正常的Activity显示，在很前面有疑惑了为什么绘制会发一个Runnable，而且是异步消息，而不是直接执行！！让我们回到绘制的代码：

```java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java   
void scheduleTraversals() {
        if (!mTraversalScheduled) {
            mTraversalScheduled = true;
            //打开了同步屏障
            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();
            //把一个Runnable放进他的队列里面，注意这里的类型是CALLBACK_TRAVERSAL
            mChoreographer.postCallback(
                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);
            if (!mUnbufferedInputDispatch) {
                scheduleConsumeBatchedInput();
            }
            notifyRendererOfFramePending();
            pokeDrawLockIfNeeded();
        }
    }
```

这个方法我们熟悉的不能再熟悉了吧！！这里我们当时还纳闷为什么不是直接绘制，而是放在一个消息队列里面等待绘制，还搞了个同步屏障？？？**设置了同步屏障之后，Handler只会处理异步消息。再换句话说，同步屏障为Handler消息机制增加了一种简单的优先级机制，异步消息的优先级要高于同步消息。**

但是哪里看出我们发出的是异步消息？

```java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/Choreographer.java  
public void postCallback(int callbackType, Runnable action, Object token) {
    //是注意最后一个参数是0
        postCallbackDelayed(callbackType, action, token, 0);
    }

    private void postCallbackDelayedInternal(int callbackType,
            Object action, Object token, long delayMillis) {
        if (DEBUG_FRAMES) {
            Log.d(TAG, "PostCallback: type=" + callbackType
                    + ", action=" + action + ", token=" + token
                    + ", delayMillis=" + delayMillis);
        }

        synchronized (mLock) {
            final long now = SystemClock.uptimeMillis();
            final long dueTime = now + delayMillis;
            //注意看这里，他把Runnable放进去了！！
            mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);

            if (dueTime <= now) {
                //如果信号已经到了马上就绘制
                scheduleFrameLocked(now);
            } else {
                //打包消息
                Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);
                msg.arg1 = callbackType;
                //设置为异步消息！
                msg.setAsynchronous(true);
                //因为传进来的时间是0耶，马上执行？
                mHandler.sendMessageAtTime(msg, dueTime);
            }
        }
    }

//再看看他的处理消息的方法
private final class FrameHandler extends Handler {
    public FrameHandler(Looper looper) {
        super(looper);
    }

    @Override
    public void handleMessage(Message msg) {
        switch (msg.what) {
            case MSG_DO_FRAME:
                doFrame(System.nanoTime(), 0);
                break;
            case MSG_DO_SCHEDULE_VSYNC:
                doScheduleVsync();
                break;
                //现在应该走到这里
            case MSG_DO_SCHEDULE_CALLBACK:
                doScheduleCallback(msg.arg1);
                break;
        }
    }
}

    void doScheduleCallback(int callbackType) {
        synchronized (mLock) {
            if (!mFrameScheduled) {
                final long now = SystemClock.uptimeMillis();
                if (mCallbackQueues[callbackType].hasDueCallbacksLocked(now)) {
                    //走到这里
                    scheduleFrameLocked(now);
                }
            }
        }
    }



   private void scheduleFrameLocked(long now) {
        if (!mFrameScheduled) {
            mFrameScheduled = true;
            //如果系统开启了垂直同步就走这里
            if (USE_VSYNC) {
                if (DEBUG_FRAMES) {
                    Log.d(TAG, "Scheduling next frame on vsync.");
                }

                // If running on the Looper thread, then schedule the vsync immediately,
                // otherwise post a message to schedule the vsync from the UI thread
                // as soon as possible.
                if (isRunningOnLooperThreadLocked()) {
                    scheduleVsyncLocked();
                } else {
                    //可以看到又设置了一个异步消息，但是类型改了，回到上面的消息处理，可以看到调用这个doScheduleVsync();
                    Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);
                    msg.setAsynchronous(true);
                    mHandler.sendMessageAtFrontOfQueue(msg);
                }
            } else {
               ....
            }
        }
       
       //就是这个
    void doScheduleVsync() {
        synchronized (mLock) {
            if (mFrameScheduled) {
                //继续
                scheduleVsyncLocked();
            }
        }
    }
       
       
       //到这里
     private void scheduleVsyncLocked() {
        mDisplayEventReceiver.scheduleVsync();
    }
       
       
       
    }

```

现在跑到了垂直同步接收器里面去了，我看过他的内容，没有什么东西，我们直接看他的父类

```java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/DisplayEventReceiver.java
    /**
     * Schedules a single vertical sync pulse to be delivered when the next
     * display frame begins.
     */
    public void scheduleVsync() {
        if (mReceiverPtr == 0) {
            Log.w(TAG, "Attempted to schedule a vertical sync pulse but the display event "
                    + "receiver has already been disposed.");
        } else {
            //这个方法是去注册下回一个同步信号
            nativeScheduleVsync(mReceiverPtr);
        }
    }

```

好家伙，搞了大半天，居然是直接入队！那入队后怎么办？就是在等垂直同步信号呗！等到下层的同步信号一来！就马上进行绘制！我们什么时候初始化的垂直同步接收器？看看VIewRootImp的构造函数：

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java
    public ViewRootImpl(Context context, Display display) {
      ...
        
        mChoreographer = Choreographer.getInstance();//这里
        ...
    }
~~~

看看Choreographer的构造

~~~java
public final class Choreographer {
    // Enable/disable vsync for animations and drawing.
    private static final boolean USE_VSYNC = SystemProperties.getBoolean(
            "debug.choreographer.vsync", true);
    
	//单例
	public static Choreographer getInstance() {
        return sThreadInstance.get();
    }

    //每个线程一个Choreographer实例
    private static final ThreadLocal<Choreographer> sThreadInstance =
            new ThreadLocal<Choreographer>() {
        @Override
        protected Choreographer initialValue() {
            Looper looper = Looper.myLooper();
            if (looper == null) {
                throw new IllegalStateException("The current thread must have a looper!");
            }
            return new Choreographer(looper);
        }
    };

    private Choreographer(Looper looper) {
        mLooper = looper;
        //创建handle对象，用于处理消息，其looper为当前的线程的消息队列
        mHandler = new FrameHandler(looper);
        //创建VSYNC的信号接受对象
        mDisplayEventReceiver = USE_VSYNC ? new FrameDisplayEventReceiver(looper) : null;
        //初始化上一次frame渲染的时间点
        mLastFrameTimeNanos = Long.MIN_VALUE;
        //计算帧率，也就是一帧所需的渲染时间，getRefreshRate是刷新率，一般是60
        mFrameIntervalNanos = (long)(1000000000 / getRefreshRate());
        //创建消息处理队列
        mCallbackQueues = new CallbackQueue[CALLBACK_LAST + 1];
        for (int i = 0; i <= CALLBACK_LAST; i++) {
            mCallbackQueues[i] = new CallbackQueue();
        }
    }
}
~~~

可以看出他是一个线程级别的单例，每个线程都有一个。他还new了一个Handle,这个Handle到底是干嘛的？

~~~java
private final class FrameHandler extends Handler {
    public FrameHandler(Looper looper) {
        super(looper);
    }

    @Override
    public void handleMessage(Message msg) {
        switch (msg.what) {
            case MSG_DO_FRAME:
                doFrame(System.nanoTime(), 0);
                break;
            case MSG_DO_SCHEDULE_VSYNC:
                doScheduleVsync();
                break;
            case MSG_DO_SCHEDULE_CALLBACK:
                doScheduleCallback(msg.arg1);
                break;
        }
    }
}
~~~

原来是处理三种消息的，我们看到了熟悉的字眼，第二个，这代表着是收到了同步信号的意思！！然后他还创建了一个VSync的接收器

~~~java

private final class FrameDisplayEventReceiver extends DisplayEventReceiver implements Runnable {

    public FrameDisplayEventReceiver(Looper looper) {
        super(looper); //调用他父类的方法！！
    }
}

public DisplayEventReceiver(Looper looper) {
    mMessageQueue = looper.getQueue(); //获取主线程的消息队列
   //这一步就是去注册
    mReceiverPtr = nativeInit(new WeakReference<DisplayEventReceiver>(this), mMessageQueue);
}
~~~

经过JNI调用进入如下Native方法。

~~~java
static jlong nativeInit(JNIEnv* env, jclass clazz, jobject receiverWeak, jobject messageQueueObj) {
    sp<MessageQueue> messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);
    ...
    //获取一个native的对象
    sp<NativeDisplayEventReceiver> receiver = new NativeDisplayEventReceiver(env,
            receiverWeak, messageQueue);
    //初始化
    status_t status = receiver->initialize();
    ...

    //获取DisplayEventReceiver对象的引用
    receiver->incStrong(gDisplayEventReceiverClassInfo.clazz); 
    return reinterpret_cast<jlong>(receiver.get());
}
~~~

我们一步一步来

~~~java
NativeDisplayEventReceiver::NativeDisplayEventReceiver(JNIEnv* env,
        jobject receiverWeak, const sp<MessageQueue>& messageQueue) :
        mReceiverWeakGlobal(env->NewGlobalRef(receiverWeak)),
        mMessageQueue(messageQueue), mWaitingForVsync(false) {
    ALOGV("receiver %p ~ Initializing display event receiver.", this);
}
~~~

NativeDisplayEventReceiver继承于LooperCallback对象，此处mReceiverWeakGlobal记录的是Java层 DisplayEventReceiver对象的全局引用。我们再看初始化做了什么

~~~java
status_t NativeDisplayEventReceiver::initialize() {
    //mReceiver为DisplayEventReceiver类型
    status_t result = mReceiver.initCheck();
    ...
    //监听mReceiver的所获取的文件句柄。
    int rc = mMessageQueue->getLooper()->addFd(mReceiver.getFd(), 0, Looper::EVENT_INPUT,
            this, NULL);
    ...
    
    return OK;
}
~~~

 监听mReceiver的所获取的文件句柄，一旦有数据到来，则回调this(此处NativeDisplayEventReceiver)中所复写LooperCallback对象的 handleEvent。这里种回调我还没详细学过，大致了解一点，其实就是监听一个文件，当有人改了文件的内容就会通过epoll机制回调我们设置的回调，这里监听的内容应该就是VSync信号了！！我们看看handleEvent方法

~~~c
int NativeDisplayEventReceiver::handleEvent(int receiveFd, int events, void* data) {
    ...
    nsecs_t vsyncTimestamp;
    int32_t vsyncDisplayId;
    uint32_t vsyncCount;
    //清除所有的pending事件，只保留最后一次vsync
    if (processPendingEvents(&vsyncTimestamp, &vsyncDisplayId, &vsyncCount)) {
        mWaitingForVsync = false;
        //分发Vsync
        dispatchVsync(vsyncTimestamp, vsyncDisplayId, vsyncCount);
    }
    return 1;
}
~~~

当有多个信号的时候只处理最近的一个

~~~c
bool NativeDisplayEventReceiver::processPendingEvents(
        nsecs_t* outTimestamp, int32_t* outId, uint32_t* outCount) {
    bool gotVsync = false;
    DisplayEventReceiver::Event buf[EVENT_BUFFER_SIZE];
    ssize_t n;
    while ((n = mReceiver.getEvents(buf, EVENT_BUFFER_SIZE)) > 0) {
        for (ssize_t i = 0; i < n; i++) {
            const DisplayEventReceiver::Event& ev = buf[i];
            switch (ev.header.type) {
            case DisplayEventReceiver::DISPLAY_EVENT_VSYNC:
                gotVsync = true; //获取VSync信号
                *outTimestamp = ev.header.timestamp;
                *outId = ev.header.id;
                *outCount = ev.vsync.count;
                break;
            case DisplayEventReceiver::DISPLAY_EVENT_HOTPLUG:
                dispatchHotplug(ev.header.timestamp, ev.header.id, ev.hotplug.connected);
                break;
            default:
                break;
            }
        }
    }
    return gotVsync;
}
~~~

遍历所有的事件，当有多个VSync事件到来，则只关注最近一次的事件。好！到这里我们的VIewRootImp已经进行了监听VSync信号了！那么当拿到信号的时候是不是就开始执行我们在绘制的时候放进队列的Runnable呢？看下去！

当拿到事件的时候就进行分发dispatchVsync（）

~~~c
oid NativeDisplayEventReceiver::dispatchVsync(nsecs_t timestamp, int32_t id, uint32_t count) {
    JNIEnv* env = AndroidRuntime::getJNIEnv();

    ScopedLocalRef<jobject> receiverObj(env, jniGetReferent(env, mReceiverWeakGlobal));
    if (receiverObj.get()) {
        //通过JNI回调Java的方法
        env->CallVoidMethod(receiverObj.get(),
                gDisplayEventReceiverClassInfo.dispatchVsync, timestamp, id, count);
    }

    mMessageQueue->raiseAndClearException(env, "dispatchVsync");
}
~~~



```java
//[-> DisplayEventReceiver.java]
private void dispatchVsync(long timestampNanos, int builtInDisplayId, int frame) {
   //Choreographer对象实例化的过程，创建的对象是DisplayEventReceiver子类 FrameDisplayEventReceiver对象。
    onVsync(timestampNanos, builtInDisplayId, frame);
}
```

~~~java
private final class FrameDisplayEventReceiver extends DisplayEventReceiver implements Runnable {
    private boolean mHavePendingVsync;
    private long mTimestampNanos;
    private int mFrame;

    @Override
    public void onVsync(long timestampNanos, int builtInDisplayId, int frame) {
        //忽略来自第二显示屏的Vsync
        if (builtInDisplayId != SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) {
            scheduleVsync();
            return;
        }
        ...
        
        mTimestampNanos = timestampNanos;
        mFrame = frame;
        //该消息的callback为当前对象FrameDisplayEventReceiver
        Message msg = Message.obtain(mHandler, this);
        //发送一个异步消息！！！这里很重要！！
        msg.setAsynchronous(true);
        //此处mHandler为FrameHandler
        mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);
    }

    @Override
    public void run() {
        mHavePendingVsync = false;
        doFrame(mTimestampNanos, mFrame); //【见小节2.8】
    }
}
~~~

可见onVsync()过程是通过FrameHandler向主线程Looper发送了一个自带callback的消息，这个消息还是异步的！！！ callback为FrameDisplayEventReceiver。 还记得我们前面打开的同步屏障吗？而为了保证信号到来的时候马上绘制，就设置了个同步屏障！同步屏障是由系统发送，一般用于刷新UI(如16ms刷新一次界面)。当设置了同步屏障之后，next函数将会忽略所有的同步消息，返回异步消息。当主线程Looper执行到该消息时，则调用FrameDisplayEventReceiver.run()方法，紧接着便是调用doFrame，如下

~~~java
///[-> Choreographer.java]
void doFrame(long frameTimeNanos, int frame) {
    final long startNanos;
    synchronized (mLock) {
        if (!mFrameScheduled) {
            return; // mFrameScheduled=false，则直接返回。
        }

        long intendedFrameTimeNanos = frameTimeNanos; //原本计划的绘帧时间点
        startNanos = System.nanoTime();
        final long jitterNanos = startNanos - frameTimeNanos;
        if (jitterNanos >= mFrameIntervalNanos) {
            
            final long skippedFrames = jitterNanos / mFrameIntervalNanos;
            //当掉帧个数超过30，则输出相应log
            if (skippedFrames >= SKIPPED_FRAME_WARNING_LIMIT) {
                Log.i(TAG, "Skipped " + skippedFrames + " frames! "
                        + "The application may be doing too much work on its main thread.");
            }
            final long lastFrameOffset = jitterNanos % mFrameIntervalNanos;
            frameTimeNanos = startNanos - lastFrameOffset; //对齐帧的时间间隔
        }

        if (frameTimeNanos < mLastFrameTimeNanos) {
            scheduleVsyncLocked();
            return;
        }

        mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos);
        mFrameScheduled = false;
        mLastFrameTimeNanos = frameTimeNanos;
    }

    //注意看这里
    try {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, "Choreographer#doFrame");

        mFrameInfo.markInputHandlingStart();
        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);

        mFrameInfo.markAnimationsStart();
        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);

        mFrameInfo.markPerformTraversalsStart();
        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);

        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
}
~~~

1. 每调用一次scheduleFrameLocked()，则mFrameScheduled为true，能执行一次 doFrame()操作。

2. 最终有4个回调方法，依次为如下：

   - INPUT：输入事件
   - ANIMATION：动画
   - TRAVERSAL：窗口刷新 ，这个是我们现在在看的
   - COMMIT

   参考：<http://gityuan.com/2017/02/25/choreographer/>

现在明白了呀！！！我们的绘制操作并不是在一调用requestLayout方法或者invalidate方法就马上进行的，而是当我们调用了后会放到Choreographer的队列里面等带VSycn信号的到来再进行绘制的！！！现在我们上层的绘制时机和下层显示器是同步的了！！

### 小结

我们小结一下：

一般，上层需要绘制新的UI都是因为View的requestLayout或者是invalidate方法被调用触发的，我们以这个为起点，跟踪上层View的绘制流程：



1. requestLayout或者invalidate触发更新视图请求
2. 更新请求传递到ViewRootImpl中，ViewRootImpl向主线程MessageQueue中加入一个阻塞器，该阻塞器将会拦截所有同步消息，也就是说此时，我们再通过Handler向主线程MessageQueue发送的所有Message都将无法被执行。
3. ViewRootImpl向Choreographer注册下一个VSync信号
4. Choreographer通过DisplayEventReceiver向framework层注册下一个VSync信号
5. 当底层产生下一个VSync消息时，该信号将会发送给DisplayEventReceiver，最后传递给Choreographer
6. Choreographer收到VSync信号之后，向主线程MessageQueue发送了一个异步消息，我们在第二步提到，ViewRootImpl向MessageQueue发送了一个同步消息阻塞器。这里Choreographer发送的异步消息，是不会被阻塞器拦截的。
7. 最后，异步消息的执行者是ViewRootImpl，也就是真正开始绘制下一帧了,绘制的过程就变成下面的啦！！

![image](https://lc-gold-cdn.xitu.io/108a4b92aa1629b39403.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

时间从屏幕显示第0帧开始，CPU开始准备第1帧图形的处理，好了之后交给GPU进行处理，在上层收到下一个VSync之后，CPU立马开始第2帧的处理，VIewRootImp的绘图和SurfaceFlinger向BufferQueue拿处理好的数据的节奏就和VSync信号保持一致了，整个绘图非常流畅。

## CPU和GPU不给力！

然而，理想很丰满，现实很骨感，如果CPU和GPU没能在下一个VSync信号到来之前完成下一帧的绘制工作（就是说我们的在VIewRootImp绘制的时间太长了！！！），又会是怎么样的呢？哇！！

![image](https://lc-gold-cdn.xitu.io/556fb634ca4cf7713bd8.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



还是从屏幕显示第A帧开始，时间进入第一个16.6ms，CPU和GPU合成第B帧，当下一个VSync信号到来的时候，GPU未能及时完成第B帧的绘制，此时，GPU占有一个Surface里的Buffer，而同时SurfaceFlinger又持有一个Buffer用于合成显示下一帧到屏幕，因为我们前面假设了生产者能拿到的最大空闲缓冲区为1个。此时SurfaceFlinger只能使用第A帧已经准备好的Buffer来合成，GPU继续在另一个缓冲区中合成第B帧，此时CPU无法开始下一帧的合成，因为他向BufferQueue要缓冲区，BuffQueue不给他！！

另外一个不好的事情是CPU只有在VSync信号来的时候才开始绘制下一帧，也是就是说在第二个16.6ms时间内，CPU一直处于空闲状态，未进行下一帧的计算。
只有等到第二个VSync信号来了之后，CPU才开始在绘制下一帧。如果CPU和GPU需要合成的图形太多，将会导致连续性的卡顿，如果CPU和GPU大部分时候都无法在16.6ms完成一帧的绘制，将会导致连续的卡顿现象。

看吧！！这就是因为Layer只有一个后帧Buffer的后果！！！！那我们回到安卓7的代码

~~~java
//media/ba/sd/aosp/frameworks/native/services/surfaceflinger/Layer.cpp
void Layer::onFirstRef() {
    
   ...

 //这一句官方注解等下会讲。而且非常重要
#ifdef TARGET_DISABLE_TRIPLE_BUFFERING
#warning "disabling triple buffering"
#else
    
   //这里是指生产者最大可以申请两个缓冲区，作为后帧，这里我们需要理解一下，因为现在是Buffer队列了，意味着你的Layer放入了一个Buffer到队列里面，放入的那个属于前帧了，取出空闲那个属于后帧，这里设置的意思就是可以取出两个后帧！！！！
    mProducer->setMaxDequeuedBufferCount(2);
#endif
    const sp<const DisplayDevice> hw(mFlinger->getDefaultDisplayDevice());
    updateTransformHint(hw);
}
~~~

给Layer两个后帧Buffer！！！

![image](https://lc-gold-cdn.xitu.io/47a962b7b7e477e031f2.png?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



从上图可以看出，在第一个VSync到来时，尽管SurfaceFlinger占了一个Buffer，GPU又占了一个Buffer，CPU仍然可以在第三个Buffer中开始下一帧的计算，整个显示过程就开始时卡顿了一帧，之后都是流畅的。我们会发现，上图中，GPU处理好的图形，需要跨越两个VSync信号，才能显示。这样的话，给用户的影响是一个延迟的现象。所以我们自己也要注意绘制的内容不能太花里胡哨哦！！！

## 第三次想分析绘制

这已经是我们第三次跑回这里的代码了，每一次想研究他，都发现还有东西没有学会，现在我们已经差不多了，功力已经足够了，应该可以研究了吧！！

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java  
private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff,
            boolean scalingRequired, Rect dirty) {

        // 看到这个的时候，虎躯一震！这不就是画布吗！！！！
        final Canvas canvas;
        try {
         
            ...

            //1.锁住
            canvas = mSurface.lockCanvas(dirty);

      ....
          		//2.绘制！！！
                mView.draw(canvas);

       ...
            
        } finally {
            try {
                //3.解锁
                surface.unlockCanvasAndPost(canvas);
            }
            ...
        }
        return true;
    }

~~~

我们一步一步来

### 获取一个后帧Buffer

mSurface的lockvas方法

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/Surface.java    
public Canvas lockCanvas(Rect inOutDirty)
            throws Surface.OutOfResourcesException, IllegalArgumentException {
        synchronized (mLock) {
            checkNotReleasedLocked();
            if (mLockedObject != 0) {
                // Ideally, nativeLockCanvas() would throw in this situation and prevent the
                // double-lock, but that won't happen if mNativeObject was updated.  We can't
                // abandon the old mLockedObject because it might still be in use, so instead
                // we just refuse to re-lock the Surface.
                throw new IllegalArgumentException("Surface was already locked");
            }
            mLockedObject = nativeLockCanvas(mNativeObject, mCanvas, inOutDirty);
            return mCanvas;
        }
    }
~~~

对应的JNI函数

### 标记J

~~~c
//media/ba/sd/aosp/frameworks/base/core/jni/android_view_Surface.cpp
static jlong nativeLockCanvas(JNIEnv* env, jclass clazz,
        jlong nativeObject, jobject canvasObj, jobject dirtyRectObj) {
    //指针转换，转换成我们native的Surface对象
    sp<Surface> surface(reinterpret_cast<Surface *>(nativeObject));

    if (!isSurfaceValid(surface)) {
        doThrowIAE(env);
        return 0;
    }

    //这里是向Surface里面取出要重新绘制的矩形区域，为什么叫脏矩形呢？应该是指没用的数据吧，所以要重新绘制？
    Rect dirtyRect(Rect::EMPTY_RECT);
    Rect* dirtyRectPtr = NULL;

    if (dirtyRectObj) {
        dirtyRect.left   = env->GetIntField(dirtyRectObj, gRectClassInfo.left);
        dirtyRect.top    = env->GetIntField(dirtyRectObj, gRectClassInfo.top);
        dirtyRect.right  = env->GetIntField(dirtyRectObj, gRectClassInfo.right);
        dirtyRect.bottom = env->GetIntField(dirtyRectObj, gRectClassInfo.bottom);
        dirtyRectPtr = &dirtyRect;
    }

    //通过Surface的Lock函数获取一块空闲的Buffer，这里我们等下很详细的讲，标记为J
    ANativeWindow_Buffer outBuffer;
    status_t err = surface->lock(&outBuffer, dirtyRectPtr);
    if (err < 0) {
        const char* const exception = (err == NO_MEMORY) ?
                OutOfResourcesException :
                "java/lang/IllegalArgumentException";
        jniThrowException(env, exception, NULL);
        return 0;
    }


    //这里应该是去设置绘图的宽高，颜色格式，就是去设置Bitmap的配置信息
    SkImageInfo info = SkImageInfo::Make(outBuffer.width, outBuffer.height,
                                         convertPixelFormat(outBuffer.format),
                                         outBuffer.format == PIXEL_FORMAT_RGBX_8888 ?
                                         kOpaque_SkAlphaType : kPremul_SkAlphaType);

    
    //这里为什么是SKBitmap呢？是因为这里用的是SKia绘图库，这里我们只需要知道是通过刚刚设置的配置信息生成一个Sk类型的Bitmap，然后吧我们获取到的缓冲区和这个Bitmap绑定
    SkBitmap bitmap;
    ssize_t bpr = outBuffer.stride * bytesPerPixel(outBuffer.format);
    bitmap.setInfo(info, bpr);
    if (outBuffer.width > 0 && outBuffer.height > 0) {
        bitmap.setPixels(outBuffer.bits);
    } else {
        // be safe with an empty bitmap.
        bitmap.setPixels(NULL);
    }

    //我们在Surface生成的时候不是生成了一个Canvas吗？这里就是取出来，然后和我们上面生成的Bitmap进行绑定
    Canvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);
    nativeCanvas->setBitmap(bitmap);

    if (dirtyRectPtr) {
        nativeCanvas->clipRect(dirtyRect.left, dirtyRect.top,
                dirtyRect.right, dirtyRect.bottom);
    }

    if (dirtyRectObj) {
        env->SetIntField(dirtyRectObj, gRectClassInfo.left,   dirtyRect.left);
        env->SetIntField(dirtyRectObj, gRectClassInfo.top,    dirtyRect.top);
        env->SetIntField(dirtyRectObj, gRectClassInfo.right,  dirtyRect.right);
        env->SetIntField(dirtyRectObj, gRectClassInfo.bottom, dirtyRect.bottom);
    }

    // Create another reference to the surface and return it.  This reference
    // should be passed to nativeUnlockCanvasAndPost in place of mNativeObject,
    // because the latter could be replaced while the surface is locked.
    sp<Surface> lockedSurface(surface);
    lockedSurface->incStrong(&sRefBaseOwner);
    //返回我们的Canvas
    return (jlong) lockedSurface.get();
}
~~~

我们前面讲过Surface持有一个BufferQueue的生成者，上面的标记J处就是通过这个生产者拿到一块空闲的Buffer！我们详细看看

~~~java
//media/ba/sd/aosp/frameworks/native/libs/gui/Surface.cpp
status_t Surface::lock(
        ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds)
{
    ...

    if (!mConnectedToCpu) {
        int err = Surface::connect(NATIVE_WINDOW_API_CPU);
        if (err) {
            return err;
        }
            //设置usage标志，这个标志在GraphicBuffer分配缓冲时有指导作用
        // we're intending to do software rendering from this point
        setUsage(GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN);
    }

    ANativeWindowBuffer* out;
    int fenceFd = -1;
    //拿到一个ANativeWindowBuffer
    status_t err = dequeueBuffer(&out, &fenceFd);
    ALOGE_IF(err, "dequeueBuffer failed (%s)", strerror(-err));
    if (err == NO_ERROR) {
        //利用刚刚的ANativeWindowBuffer构建一个后帧缓冲区！！
        sp<GraphicBuffer> backBuffer(GraphicBuffer::getSelf(out));
        const Rect bounds(backBuffer->width, backBuffer->height);

        Region newDirtyRegion;
        if (inOutDirtyBounds) {
            newDirtyRegion.set(static_cast<Rect const&>(*inOutDirtyBounds));
            newDirtyRegion.andSelf(bounds);
        } else {
            newDirtyRegion.set(bounds);
        }

        //看！！前帧缓冲区，这里的意思是，我们的界面不一定是需要全部重新绘制的，有时候只是小位置的颜色改变而已，可以拷贝前缓冲区的数据下来，就不用全部重新计数了！
        // figure out if we can copy the frontbuffer back
        const sp<GraphicBuffer>& frontBuffer(mPostedBuffer);
        const bool canCopyBack = (frontBuffer != 0 &&
                backBuffer->width  == frontBuffer->width &&
                backBuffer->height == frontBuffer->height &&
                backBuffer->format == frontBuffer->format);

        if (canCopyBack) {
            // copy the area that is invalid and not repainted this round
            const Region copyback(mDirtyRegion.subtract(newDirtyRegion));
            if (!copyback.isEmpty())
                copyBlt(backBuffer, frontBuffer, copyback);
        } else {
            // if we can't copy-back anything, modify the user's dirty
            // region to make sure they redraw the whole buffer
            newDirtyRegion.set(bounds);
            mDirtyRegion.clear();
            Mutex::Autolock lock(mMutex);
            for (size_t i=0 ; i<NUM_BUFFER_SLOTS ; i++) {
                mSlots[i].dirtyRegion.clear();
            }
        }


      ....
          
         //锁住这块BUffer，并且返回了一个这个BUffer的地址，保证别人不能操作这块缓存
        void* vaddr;
        status_t res = backBuffer->lockAsync(
                GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN,
                newDirtyRegion.bounds(), &vaddr, fenceFd);

        ALOGW_IF(res, "failed locking buffer (handle = %p)",
                backBuffer->handle);

        if (res != 0) {
            err = INVALID_OPERATION;
        } else {
            mLockedBuffer = backBuffer;
            outBuffer->width  = backBuffer->width;
            outBuffer->height = backBuffer->height;
            outBuffer->stride = backBuffer->stride;
            outBuffer->format = backBuffer->format;
            outBuffer->bits   = vaddr; //给了这个！！
        }
    }
    return err;
}

~~~

可以看出`lock`方法，首先通过`dequeueBuffer`来获取一个`ANativeWindowBuffer`,然后利用它构造一个`GraphicBuffer`,它被称为`backBuffer`,然后调用它的`backBuffer->lockAsync(...)`,那么怎么获取一个`ANativeWindowBuffer`呢？

~~~java
int Surface::dequeueBuffer(android_native_buffer_t** buffer, int* fenceFd) {
    ATRACE_CALL();
    ALOGV("Surface::dequeueBuffer");

    uint32_t reqWidth;
    uint32_t reqHeight;
    PixelFormat reqFormat;
    uint32_t reqUsage;

    {
        Mutex::Autolock lock(mMutex);

        reqWidth = mReqWidth ? mReqWidth : mUserWidth;
        reqHeight = mReqHeight ? mReqHeight : mUserHeight;

        reqFormat = mReqFormat;
        reqUsage = mReqUsage;

        if (mSharedBufferMode && mAutoRefresh && mSharedBufferSlot !=
                BufferItem::INVALID_BUFFER_SLOT) {
            sp<GraphicBuffer>& gbuf(mSlots[mSharedBufferSlot].buffer);
            if (gbuf != NULL) {
                *buffer = gbuf.get();
                *fenceFd = -1;
                return OK;
            }
        }
    } // Drop the lock so that we can still touch the Surface while blocking in IGBP::dequeueBuffer

    int buf = -1;
    sp<Fence> fence;
    nsecs_t now = systemTime();
     //看这一句获取空闲Buffer
    status_t result = mGraphicBufferProducer->dequeueBuffer(&buf, &fence,
            reqWidth, reqHeight, reqFormat, reqUsage);
  ...

    return OK;
}
~~~

获取到了空闲的缓冲区后就是开始绘制了，关于View的绘制流程我们已经很熟悉了：把数据写到这个缓冲区。绘制完后就到  surface.unlockCanvasAndPost(canvas);方法了，看吧

~~~c
//media/ba/sd/aosp/frameworks/base/core/jni/android_view_Surface.cpp
static void nativeUnlockCanvasAndPost(JNIEnv* env, jclass clazz,
        jlong nativeObject, jobject canvasObj) {
    sp<Surface> surface(reinterpret_cast<Surface *>(nativeObject));
    if (!isSurfaceValid(surface)) {
        return;
    }

    // detach the canvas from the surface
    Canvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);
    nativeCanvas->setBitmap(SkBitmap());

    // unlock surface 主要是这句
    status_t err = surface->unlockAndPost();
    if (err < 0) {
        doThrowIAE(env);
    }
} 
~~~



~~~c
//media/ba/sd/aosp/frameworks/native/libs/gui/Surface.cpp
status_t Surface::unlockAndPost()
{
    if (mLockedBuffer == 0) {
        ALOGE("Surface::unlockAndPost failed, no locked buffer");
        return INVALID_OPERATION;
    }

   //解锁刚刚锁定的Buffer
    int fd = -1;
    status_t err = mLockedBuffer->unlockAsync(&fd);
    ALOGE_IF(err, "failed unlocking buffer (%p)", mLockedBuffer->handle);

   //把我们的Buffer入队啦！！！ 
    err = queueBuffer(mLockedBuffer.get(), fd);
    ALOGE_IF(err, "queueBuffer (handle=%p) failed (%s)",
            mLockedBuffer->handle, strerror(-err));

    mPostedBuffer = mLockedBuffer;
    mLockedBuffer = 0;
    return err;
}




int Surface::queueBuffer(android_native_buffer_t* buffer, int fenceFd) {
    ATRACE_CALL();
    ALOGV("Surface::queueBuffer");
    Mutex::Autolock lock(mMutex);
    int64_t timestamp;
    bool isAutoTimestamp = false;

  
    //看这，接下来就是去告诉消费者可以去取啦！！也就是我们的SurfaceFlinger要去工作了！
    status_t err = mGraphicBufferProducer->queueBuffer(i, input, &output);
    mLastQueueDuration = systemTime() - now;
   
 ...

    return err;
}

~~~

Surface的工作就做完了，接下来就是SurfaceFlinger的工作了，你一定很想知道SurfaceFlinger是怎么工作的，但是我们上面可以精简了很多流程。省略了很多东西：

+ GraphicBuffer是什么？我们从队列获取的这些所谓的GraphicBuffer是不是用的同一块内存，然后在这内存上进行分析的呢？

+ 为什么没有看到Layer？

  

## GraphicBuffer

我们只能从BufferQueue入手啦，因为我们都是从这里拿的GraphicBuffer！

~~~c
///media/ba/sd/aosp/frameworks/native/services/surfaceflinger/Layer.cpp
void Layer::onFirstRef() {
    // Creates a custom BufferQueue for SurfaceFlingerConsumer to use
    sp<IGraphicBufferProducer> producer;
    sp<IGraphicBufferConsumer> consumer;
    //创建BufferQueue的代码在这里，注意参数只有两个！
    BufferQueue::createBufferQueue(&producer, &consumer);
    mProducer = new MonitoredProducer(producer, mFlinger);
    mSurfaceFlingerConsumer = new SurfaceFlingerConsumer(consumer, mTextureName,
            this);
    mSurfaceFlingerConsumer->setConsumerUsageBits(getEffectiveUsage(0));
    mSurfaceFlingerConsumer->setContentsChangedListener(this);
    mSurfaceFlingerConsumer->setName(mName);

#ifdef TARGET_DISABLE_TRIPLE_BUFFERING
#warning "disabling triple buffering"
#else
    mProducer->setMaxDequeuedBufferCount(2);
#endif

    const sp<const DisplayDevice> hw(mFlinger->getDefaultDisplayDevice());
    updateTransformHint(hw);
}

~~~

~~~c
///media/ba/sd/aosp/frameworks/native/libs/gui/BufferQueue.cpp
void BufferQueue::createBufferQueue(sp<IGraphicBufferProducer>* outProducer,
        sp<IGraphicBufferConsumer>* outConsumer,
        const sp<IGraphicBufferAlloc>& allocator) { //注意这最后一个参数，前面不是只传了两个吗？
    LOG_ALWAYS_FATAL_IF(outProducer == NULL,
            "BufferQueue: outProducer must not be NULL");
    LOG_ALWAYS_FATAL_IF(outConsumer == NULL,
            "BufferQueue: outConsumer must not be NULL");

    //传进去了
    sp<BufferQueueCore> core(new BufferQueueCore(allocator));
    LOG_ALWAYS_FATAL_IF(core == NULL,
            "BufferQueue: failed to create BufferQueueCore");

    sp<IGraphicBufferProducer> producer(new BufferQueueProducer(core));
    LOG_ALWAYS_FATAL_IF(producer == NULL,
            "BufferQueue: failed to create BufferQueueProducer");

    sp<IGraphicBufferConsumer> consumer(new BufferQueueConsumer(core));
    LOG_ALWAYS_FATAL_IF(consumer == NULL,
            "BufferQueue: failed to create BufferQueueConsumer");

    *outProducer = producer;
    *outConsumer = consumer;
}
~~~

但是直接看BufferQueue的参数却有3个！最后一个是IGraphicBufferAlloc显然他是一个Bp端，这个东西就是用来管理Buffer的分配的！我们看看他是哪里来的

~~~c
//media/ba/sd/aosp/frameworks/native/include/gui/BufferQueue.h 
static void createBufferQueue(sp<IGraphicBufferProducer>* outProducer,
            sp<IGraphicBufferConsumer>* outConsumer,
            const sp<IGraphicBufferAlloc>& allocator = NULL);
~~~

空的。。。那我们看BufferQueueCore的构造函数

~~~c
BufferQueueCore::BufferQueueCore(const sp<IGraphicBufferAlloc>& allocator) :
   ...
    mUniqueId(getUniqueId())
{
      //这里初始化，注意有个判空处理，说明一个进程只有一个allocator
    if (allocator == NULL) {
        sp<ISurfaceComposer> composer(ComposerService::getComposerService());
        mAllocator = composer->createGraphicBufferAlloc();
        if (mAllocator == NULL) {
            BQ_LOGE("createGraphicBufferAlloc failed");
        }
    }

    int numStartingBuffers = getMaxBufferCountLocked();
    for (int s = 0; s < numStartingBuffers; s++) {
        mFreeSlots.insert(s);
    }
    for (int s = numStartingBuffers; s < BufferQueueDefs::NUM_BUFFER_SLOTS;
            s++) {
        mUnusedSlots.push_front(s);
    }
}
~~~

我们知道这个ComposerService其实就是SurfaceFlinger，我们去SurfaceFlinger找createGraphicBufferAlloc方法

~~~c
sp<IGraphicBufferAlloc> SurfaceFlinger::createGraphicBufferAlloc()
{
    sp<GraphicBufferAlloc> gba(new GraphicBufferAlloc());
    return gba;
}
~~~

直接new了？？？这里是不是似曾相识？？？像不像ServiceManager？？？是直接new出来然后直接用的Bp端！！！既然这样我们就去看他Bp端里面的方法

~~~c
//media/ba/sd/aosp/frameworks/native/libs/gui/IGraphicBufferAlloc.cpp
class BpGraphicBufferAlloc : public BpInterface<IGraphicBufferAlloc>
{
public:
    BpGraphicBufferAlloc(const sp<IBinder>& impl)
        : BpInterface<IGraphicBufferAlloc>(impl)
    {
    }

    virtual ~BpGraphicBufferAlloc();

//原来BufferQueue是用GraphicBufferAlloc 来获取到Buffer的
    virtual sp<GraphicBuffer> createGraphicBuffer(uint32_t width,
            uint32_t height, PixelFormat format, uint32_t usage,
            std::string requestorName, status_t* error) {
        Parcel data, reply;
        data.writeInterfaceToken(IGraphicBufferAlloc::getInterfaceDescriptor());
        data.writeUint32(width);
        data.writeUint32(height);
        data.writeInt32(static_cast<int32_t>(format));
        data.writeUint32(usage);
        if (requestorName.empty()) {
            requestorName += "[PID ";
            requestorName += std::to_string(getpid());
            requestorName += ']';
        }
        data.writeUtf8AsUtf16(requestorName);
        remote()->transact(CREATE_GRAPHIC_BUFFER, data, &reply);
        sp<GraphicBuffer> graphicBuffer;
        status_t result = reply.readInt32();
        if (result == NO_ERROR) {
        //注意看这里，也是直接new一个空的，然后通过返回的数据填充，说明这个GraphicBuffer是支持流化的
            graphicBuffer = new GraphicBuffer();
            //在这里进行读取数据
            result = reply.read(*graphicBuffer);
            if (result != NO_ERROR) {
                graphicBuffer.clear();
            }
            // reply.readStrongBinder();
            // here we don't even have to read the BufferReference from
            // the parcel, it'll die with the parcel.
        }
        *error = result;
        return graphicBuffer;
    }
};
~~~

看看Bn端

~~~c
///media/ba/sd/aosp/frameworks/native/libs/gui/IGraphicBufferAlloc.cpp
status_t BnGraphicBufferAlloc::onTransact(
    uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)
{
    // codes that don't require permission check

    // BufferReference just keeps a strong reference to a GraphicBuffer until it
    // is destroyed (that is, until no local or remote process have a reference
    // to it).
    class BufferReference : public BBinder {
        sp<GraphicBuffer> mBuffer;
    public:
        BufferReference(const sp<GraphicBuffer>& buffer) : mBuffer(buffer) {}
    };


    switch (code) {
        case CREATE_GRAPHIC_BUFFER: {
            CHECK_INTERFACE(IGraphicBufferAlloc, data, reply);
            uint32_t width = data.readUint32();
            uint32_t height = data.readUint32();
            PixelFormat format = static_cast<PixelFormat>(data.readInt32());
            uint32_t usage = data.readUint32();
            status_t error = NO_ERROR;
            std::string requestorName;
            data.readUtf8FromUtf16(&requestorName);
            //调用具体实现
            sp<GraphicBuffer> result = createGraphicBuffer(width, height,
                    format, usage, requestorName, &error);
            reply->writeInt32(error);
            if (result != 0) {
                //注意这里！！在Bn端，这种操作已经很常见了，说明等下肯定是直接new一个空壳，而我们要传输的数据可以支持流化，然后在Bp端把这些东西读出来，，，，写到Bp端的真实对象
                reply->write(*result);
                // We add a BufferReference to this parcel to make sure the
                // buffer stays alive until the GraphicBuffer object on
                // the other side has been created.
                // This is needed so that the buffer handle can be
                // registered before the buffer is destroyed on implementations
                // that do not use file-descriptors to track their buffers.
                reply->writeStrongBinder( new BufferReference(result) );
            }
            return NO_ERROR;
        }
        default:
            return BBinder::onTransact(code, data, reply, flags);
    }
}
~~~

我们看看具体实现

~~~c
//media/ba/sd/aosp/frameworks/native/libs/gui/GraphicBufferAlloc.cpp
sp<GraphicBuffer> GraphicBufferAlloc::createGraphicBuffer(uint32_t width,
        uint32_t height, PixelFormat format, uint32_t usage,
        std::string requestorName, status_t* error) {
    //也是直接new！对吧，是直接new一个空壳
    sp<GraphicBuffer> graphicBuffer(new GraphicBuffer(
            width, height, format, usage, std::move(requestorName)));
    status_t err = graphicBuffer->initCheck();
    *error = err;
    if (err != 0 || graphicBuffer->handle == 0) {
        if (err == NO_MEMORY) {
            GraphicBuffer::dumpAllocationsToSystemLog();
        }
        ALOGE("GraphicBufferAlloc::createGraphicBuffer(w=%d, h=%d) "
             "failed (%s), handle=%p",
                width, height, strerror(-err), graphicBuffer->handle);
        return 0;
    }
    return graphicBuffer;
}
~~~

按照前面的猜想，buffer应该是共享的，是所有程序共享一块内存，然后通过这块内存划分出Buffer，我们看看构造函数

~~~c
class GraphicBuffer
    : public ANativeObjectBase< ANativeWindowBuffer, GraphicBuffer, RefBase >,
      public Flattenable<GraphicBuffer>//声明GraphicBuffer可流化
{}

GraphicBuffer::GraphicBuffer(uint32_t inWidth, uint32_t inHeight,
        PixelFormat inFormat, uint32_t inUsage, std::string requestorName)
    : BASE(), mOwner(ownData), mBufferMapper(GraphicBufferMapper::get()),//这里等下会讲
      mInitCheck(NO_ERROR), mId(getUniqueId()), mGenerationNumber(0)
{
    width  =
    height =
    stride =
    format =
    usage  = 0;
    handle = NULL;
     //initSize？？？说明我们new出来的GraphicBuffer是空壳。现在才去申请一定大小的内存！！！
    mInitCheck = initSize(inWidth, inHeight, inFormat, inUsage,
            std::move(requestorName));
}

status_t GraphicBuffer::initSize(uint32_t inWidth, uint32_t inHeight,
        PixelFormat inFormat, uint32_t inUsage, std::string requestorName)
{
    //嗯！！！！多了个东西！！！很眼熟吧！！这个才是真正的内存分配管理者！！！一看到这个get就知道是个单例模式。
    GraphicBufferAllocator& allocator = GraphicBufferAllocator::get();
    uint32_t outStride = 0;
    //当我们看到Handle的时候就明白了，他和Fd的意义是一样的，并且放在handle!!!然后肯定会用这个句柄去进行内存的映射，就是把这个buffer的内存映射到我们应用程序的进程
    status_t err = allocator.allocate(inWidth, inHeight, inFormat, inUsage,
            &handle, &outStride, mId, std::move(requestorName));
    if (err == NO_ERROR) {
        width = static_cast<int>(inWidth);
        height = static_cast<int>(inHeight);
        format = inFormat;
        usage = static_cast<int>(inUsage);
        stride = static_cast<int>(outStride);
    }
    return err;
}

~~~

GraphicBufferAllocator是个单例模式，按照我的猜想。他应该是和某个设备有关，而我们用到的Buffer的内存应该是从那个设备获取的，我们看看GraphicBufferAllocator里面是不是和我们猜的一样

~~~c
GraphicBufferAllocator::GraphicBufferAllocator()
  : mLoader(std::make_unique<Gralloc1::Loader>()),
    mDevice(mLoader->getDevice()) {}
~~~

当看到Device字样的时候，我就觉得是八九不离十了！！！而我们的Device是通过Loader获取的！Loader会去去加载so库，这个库有什么用呢？简言之，就是为了分配一块用于显示的内存，但为什么需要这种层层封装呢？封装的目的就是为了屏蔽不同硬件平台的差别。这里已经不想再分析下去了，因为再下去就涉及到硬件抽象层了。

###  我们小结一下

在前面 `BufferQueueCore` 中创建 `IGraphicBufferAlloc` 时，我们看到这个对象总是会通过 surfacefinger 创建，然后通过 Binder IPC 传递给创建 BufferQueue 的进程一个句柄。后续在创建 BufferQueue 的进程中的生产者要分配 `GraphicBuffer`，则这一分配过程实际也将发生在 surfaceflinger 进程中，创建的 `GraphicBuffer`经过序列化之后，传回给创建 BufferQueue 的进程。在 `GraphicBuffer` 对象真正创建的时候，也会直接为其分配图形缓冲区。也就是说，在 Android 系统中，真正会分配图形缓冲区的进程只有 surfaceflinger，尽管可能会创建 BufferQueue 的进程有多个。

### 疑问

你有没有想过一个问题，这些东西都是在SurfaceFlinger生成的，难道就拿个内存地址就能访问了？当然不是！我们进程在Bp端生成GraphicBuffer其实是填充的（前面有讲），也就是会反序列化，我们看看反序列化的方法

~~~c
status_t GraphicBuffer::unflatten(
        void const*& buffer, size_t& size, int const*& fds, size_t& count) {
    if (size < 11 * sizeof(int)) return NO_MEMORY;

    int const* buf = static_cast<int const*>(buffer);
  


    mOwner = ownHandle;

    //当从IGraphicBufferAlloc拿到Buffer的地址后
    if (handle != 0) {
        //注册？？
        status_t err = mBufferMapper.registerBuffer(this);
        if (err != NO_ERROR) {
            width = height = stride = format = usage = 0;
            handle = NULL;
            ALOGE("unflatten: registerBuffer failed: %s (%d)",
                    strerror(-err), err);
            return err;
        }
    }

 
    return NO_ERROR;
}
~~~

我们看看上面没讲的**GraphicBufferMapper**，

~~~c
GraphicBufferMapper::GraphicBufferMapper()
  : mLoader(std::make_unique<Gralloc1::Loader>()),
    mDevice(mLoader->getDevice()) {} //他也去加载了库
}
~~~

他这个注册是什么意思，其实你应该猜的到，两个进程间想要操作内存，肯定是内存映射了，就算现在没有内存映射，也是迟早的事，这里就不详细分析了，因为里面的源码我看起来已经有点吃力了，都是调链接库的方法，而我又不懂这个。

有篇文章有讲：

GraphicBuffer` 类的主要职责主要有三块：

1. 主要通过继承自 `ANativeWindowBuffer` 结构体的成员，来描述图形内存块的信息。
2. 分配释放图形内存块。这主要通过 `initSize()` / `reallocate()` / `free_handle()` 等操作完成。
3. 分配的图形内存块未必已经映射到应用程序的虚拟地址空间了。应用程序要想像访问普通内存那样访问图形内存块，还需要通过 **lockXXX** 操作将图形内存块映射到应用程序进程的虚拟地址空间内。应用程序在把图形内存块还回去的时候则需要 **unlockXXX** 操作。

来源：<https://www.wolfcstech.com/2017/09/20/android_graphics_bufferalloc/>

但是书上说的：

registerBuffer有什么用呢？上一步调用unflatten后得到了代表共享内存的文件句柄，regiserBuffer的目的就是对它进行内存映射，代码如下所示：（注意，不同的硬件平台的代码可能不一样的）

****

```c
//GraphicBufferMapper.cpp
status_tsw_gralloc_handle_t::registerBuffer(sw_gralloc_handle_t* hnd)
{
if (hnd->pid != getpid()) {
        //原来是做一次内存映射操作
       void* base = mmap(0, hnd->size, hnd->prot, MAP_SHARED, hnd->fd,0);
        ......
       //base保存着共享内存的起始地址
       hnd->base = intptr_t(base);
    }
    returnNO_ERROR;
}
```

其实你会发现SurfaceFlinger既提供BufferQueue，也是消费者，这个SurfaceFlinger真是兢兢业业啊。我们就看看他是怎么做一个消费者的！

## SurfaceFlinger

缓存的结构讲完了，我们要步入SurfaceFlinger的大门了,因为前面我们讲到生产者把buffer给回到BufferQueue里面，没讲消费者处理的过程。我们也没有去讲BufferQueue如何去管理Buffer的生命周期，有兴趣你你可以自己看看，就是提供几个状态，声明当前的Buffer处于什么状态：被使用中，空闲啊等等。

我不想去分析SurfaceFlinger是怎么和底层的GL啊什么的进行交互，然后绘图的了，你可以自己找找看，这里我们就讲SurfaceFlinger去BufferQueue拿到Layer，然后去消费！











