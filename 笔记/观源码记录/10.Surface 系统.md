[TOC]

# 10. Android 显示系统

安卓的显示系统！这可是非常复杂的一个系统，我们在以前有关于GUI的顶多就玩了下自定义VIew，而且在自定义VIew就学的够呛的了，今天我们不玩自定义View了！研究一下安卓系统是怎么管理和绘制Gui的！

## 从Activity的显示说起

一个应用的GUI的开始，当然是在第一个Activity(假设应用只有一个Activity)创建的时候，从创建进程到ActivityThread的handleLaunchActivity

~~~java
///media/ba/sd/aosp/frameworks/base/core/java/android/app/ActivityThread.java   
private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) {
       ...
        //这里就是去生成Activity，并且调用onCreate()方法
        Activity a = performLaunchActivity(r, customIntent);

        if (a != null) {
           ..
            //这里是调用Acitivty的onResume方法，我们等下再讲这里,
            handleResumeActivity(r.token, false, r.isForward,
                    !r.activity.mFinished && !r.startsNotResumed, r.lastProcessedSeq, reason);
        }

          ...
    }
~~~

看看performLaunchActivity方法

~~~java
///media/ba/sd/aosp/frameworks/base/core/java/android/app/ActivityThread.java

    private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
        
        Activity activity = null;
        try {
            //通过反射生成对应的Activity
            java.lang.ClassLoader cl = r.packageInfo.getClassLoader();
            activity = mInstrumentation.newActivity(
                    cl, component.getClassName(), r.intent);
            StrictMode.incrementExpectedActivityCount(activity.getClass());
            r.intent.setExtrasClassLoader(cl);
            r.intent.prepareToEnterProcess();
            if (r.state != null) {
                r.state.setClassLoader(cl);
            }
        } catch (Exception e) {
            if (!mInstrumentation.onException(activity, e)) {
                throw new RuntimeException(
                    "Unable to instantiate activity " + component
                    + ": " + e.toString(), e);
            }
        }

        try {
            //生成Application
            Application app = r.packageInfo.makeApplication(false, mInstrumentation);

            if (localLOGV) Slog.v(TAG, "Performing launch of " + r);
            if (localLOGV) Slog.v(
                    TAG, r + ": app=" + app
                    + ", appName=" + app.getPackageName()
                    + ", pkg=" + r.packageInfo.getPackageName()
                    + ", comp=" + r.intent.getComponent().toShortString()
                    + ", dir=" + r.packageInfo.getAppDir());

            if (activity != null) {
                //生成BaseContext
                Context appContext = createBaseContextForActivity(r, activity);
                CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());
                Configuration config = new Configuration(mCompatConfiguration);
                if (r.overrideConfig != null) {
                    config.updateFrom(r.overrideConfig);
                }
                if (DEBUG_CONFIGURATION) Slog.v(TAG, "Launching activity "
                        + r.activityInfo.name + " with config " + config);
                Window window = null;
                if (r.mPendingRemoveWindow != null && r.mPreserveWindow) {
                    window = r.mPendingRemoveWindow;
                    r.mPendingRemoveWindow = null;
                    r.mPendingRemoveWindowManager = null;
                }
                
                //给这个Acitivity初始化一些该有的信息，这里很重要，标记为A
                activity.attach(appContext, this, getInstrumentation(), r.token,
                        r.ident, app, r.intent, r.activityInfo, title, r.parent,
                        r.embeddedID, r.lastNonConfigurationInstances, config,
                        r.referrer, r.voiceInteractor, window);
                ...
                
                 //下面就是回调Activity的的onCreate方法
                if (r.isPersistable()) {
                    mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);
                } else {
                    mInstrumentation.callActivityOnCreate(activity, r.state);
                }
                if (!activity.mCalled) {
                    throw new SuperNotCalledException(
                        "Activity " + r.intent.getComponent().toShortString() +
                        " did not call through to super.onCreate()");
                }
              ...

        return activity;
    }

~~~

我们知道onCreate方法里面最重要的就是setContentView！！！这里我们还知道，Activity的生命周期的onCreate方法并不是把界面显示出来，而是去生成属于这个Activity的所有View对象并且设置一个标题栏，这里是装饰模式，我们看下去（在以前的笔记中是有说过这个东西的，本来不打算说下去的，但是没有办法。不说怕你想不通）。

~~~java
///home/ba/Android/Sdk/sources/android-25/android/app/Activity.java 
public void setContentView(@LayoutRes int layoutResID) {
        getWindow().setContentView(layoutResID);
        initWindowDecorActionBar();
    }

 public Window getWindow() {
        return mWindow;
    }
~~~

可以看到我们的给Activity设置的VIew是设置在了这个mWindow中，这个mWindow是什么？以前就说过他具体实现是：PhoneWindow！

鉴于有些人可能搞不懂window和VIew的关系：

+ window是一个抽象基类，用于控制顶层窗口的外观和行为。外观指的是我们setContentView进去后是没有actionBar的，window会帮我们搞定。行为是指：我们的View虽然都有分发触摸事件的方法，但在以前我们一直说是系统调用这些方法，那里面的事件哪里来的？触摸事件肯定是来自系统的其他进程：WMS，WMS是去找符合触摸位置等条件的window，然后给对应的window，然后给window里面的ViewRootImp，然后VIewRootImp再分发到对应的view上的。
+ ViewRootImp以前也讲过，他不是View的子类，他是用来管理一个Window下的所有View。一个WIndow的所有VIew的生命周期都是由ViewRootImp管理的
+ view是一个视图单位，占据着屏幕的一块区域，用来绘制对应的内容。

我们看看这个Window是怎么生成的,不好找，全局搜索后发现在attach方法中，我们回到上面的标记A，也就是Acitivity生成的地方，在这里调用了attach：

~~~java
//home/ba/Android/Sdk/sources/android-25/android/app/Activity.java 
    private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
    ...
          
                //给这个Acitivity初始化一些该有的信息，这里很重要
                activity.attach(appContext, this, getInstrumentation(), r.token,
                        r.ident, app, r.intent, r.activityInfo, title, r.parent,
                        r.embeddedID, r.lastNonConfigurationInstances, config,
                        r.referrer, r.voiceInteractor, window);
    ...
    }
~~~

看看这个attach方法里面有什么

~~~java
//home/ba/Android/Sdk/sources/android-25/android/app/Activity.java、
final void attach(Context context, ActivityThread aThread,
            Instrumentation instr, IBinder token, int ident,
            Application application, Intent intent, ActivityInfo info,
            CharSequence title, Activity parent, String id,
            NonConfigurationInstances lastNonConfigurationInstances,
            Configuration config, String referrer, IVoiceInteractor voiceInteractor,
            Window window) {
        attachBaseContext(context);

        mFragments.attachHost(null /*parent*/);

    ///看这里！！
        mWindow = new PhoneWindow(this, window);
    ...
            mWindow.setWindowManager(
                (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),
                mToken, mComponent.flattenToString(),
                (info.flags & ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);
        if (mParent != null) {
            mWindow.setContainer(mParent.getWindow());
        }
        mWindowManager = mWindow.getWindowManager();
        mCurrentConfig = config;
}
~~~

是PhoneWindow吧！但是他还生成了一个WindowManage,然后set进去了？？

~~~java
 public void setWindowManager(WindowManager wm, IBinder appToken, String appName,
            boolean hardwareAccelerated) {
        mAppToken = appToken;
        mAppName = appName;
        mHardwareAccelerated = hardwareAccelerated
                || SystemProperties.getBoolean(PROPERTY_HARDWARE_UI, false);
        if (wm == null) {
            wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
        }
        mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this);
    }
~~~

哦！可以看到生成了一个WindowManagerImpl，然后就结束了！！但是这个名字一看就很重要啊！说不定后面有大用，我们先标记为B，我们回到SetContentVIew，现在应该看PhoneWindow的setContentVIew了

~~~java
///media/ba/sd/aosp/frameworks/base/core/java/com/android/internal/policy/PhoneWindow.java 
public void setContentView(int layoutResID) {
        // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window
        // decor, when theme attributes and the like are crystalized. Do not check the feature
        // before this happens.mContentParent是null，为什么叫setContentVIew现在明白了吗？
        if (mContentParent == null) {
            //看这里！！！！
            installDecor();
        } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
            mContentParent.removeAllViews();
        }

       ...
    }


 private void installDecor() {
        mForceDecorInstall = false;
        if (mDecor == null) {
            //生成DecorVIew，基类是FramLayout！！！
            mDecor = generateDecor(-1);
            mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);
            mDecor.setIsRootNamespace(true);
            if (!mInvalidatePanelMenuPosted && mInvalidatePanelMenuFeatures != 0) {
                mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);
            }
        } else {
            mDecor.setWindow(this);
        }
        if (mContentParent == null) {
            //然后生成ContentParent，这里其实就是去设置actionBar和WIndow的Style!!
            //具体代码我就不给了。
            mContentParent = generateLayout(mDecor);
    ...
  }
     
     
~~~

我们现在先总结一下：

![image](http://wiki.jikexueyuan.com/project/deep-android-v1/images/chapter8/image004.png)

这张图很完美的看出我们前面在讲的是什么：

+ 我们调用了Activity的setContentVIew后会生成PhoneWindow，和WindowManagerImpl，
+ 然后PhoneWindow会去生成DecorVIew。
+ DecorVIew就是包括了标题栏和我们设置的View！

到这里，Acitivity的onCreate就结束了，我们只是生成了DecorView，我们并没有去绘制这些VIew，这里的所有VIew都是用LayoutInflator生成的！按照Activity的生命周期，我们应该到onResume这个过程了！回到ActivityThread

~~~java
///media/ba/sd/aosp/frameworks/base/core/java/android/app/ActivityThread.java   
private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) {
       ...
        //这里就是去生成Activity，并且调用onCreate()方法
        Activity a = performLaunchActivity(r, customIntent);

        if (a != null) {
           ..
            //这里是调用Acitivty的onResume方法，我们等下再讲这里,我们现在走到了这里！
            handleResumeActivity(r.token, false, r.isForward,
                    !r.activity.mFinished && !r.startsNotResumed, r.lastProcessedSeq, reason);
        }

          ...
    }
~~~

~~~java
///media/ba/sd/aosp/frameworks/base/core/java/android/app/ActivityThread.java   
    final void handleResumeActivity(IBinder token,
            boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) {
        ActivityClientRecord r = mActivities.get(token);
        if (!checkAndUpdateLifecycleSeq(seq, r, "resumeActivity")) {
            return;
        }

        // If we are getting ready to gc after going to the background, well
        // we are back active so skip it.
        unscheduleGcIdler();
        mSomeActivitiesChanged = true;

        //调用Activity的onResume方法
        r = performResumeActivity(token, clearHide, reason);

        if (r != null) {
            //拿到Activity
            final Activity a = r.activity;

       ...

            final int forwardBit = isForward ?
                    WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;

        
            if (r.window == null && !a.mFinished && willBeVisible) {
                //这个Window就是前面生成的PhoneWindow
                r.window = r.activity.getWindow();
                //这里就是我们前面生成的DecorVIew
                View decor = r.window.getDecorView();
                decor.setVisibility(View.INVISIBLE);
                //这个就是我们前面生成的WindowManagerImpl
                ViewManager wm = a.getWindowManager();
               
                
               ....
                   
                 //看这里！！是调用我们的WindowManagerImpl，然后addView！！！
                if (a.mVisibleFromClient && !a.mWindowAdded) {
                    a.mWindowAdded = true;
                    wm.addView(decor, l);
                }
                ...

            }
~~~

在标记B处，就出现了WindowManagerImpl！就说他很重要吧！！终于用到了！！我们看看他的addVIew方法

~~~java
///home/ba/Android/Sdk/sources/android-25/android/view/WindowManagerImpl.java 
@Override
    public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {
        applyDefaultToken(params);
        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);
    }

~~~

跑到了这个mGlobal去了。。。。

~~~java
///home/ba/Android/Sdk/sources/android-25/android/view/WindowManagerImpl.java   
/*

提供与系统窗口管理器的低级通信
  与任何特定上下文无关的操作。
 
  该类仅在内部用于实现全局函数
  调用者已经知道显示和相关的兼容性信息
  为了操作。在大多数情况下，您应该使用{@link WindowManager}
  因为它受到上下文的约束。
*/
private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();
~~~

还是个单例！那就看他的addVIew方法！

~~~java

///home/ba/Android/Sdk/sources/android-25/android/view/WindowManagerGlobal.java
    public void addView(View view, ViewGroup.LayoutParams params,
            Display display, Window parentWindow) {
      ...


        ViewRootImpl root;
        View panelParentView = null;

     /...

         //这里出现了VIewRootImp！！
            root = new ViewRootImpl(view.getContext(), display);

            view.setLayoutParams(wparams);

        
    
            mViews.add(view);
            mRoots.add(root);
            mParams.add(wparams);
        }

        // do this last because it fires off messages to start doing things
        try {
            //重点来了！！！这里把我们前面生成的DecorView设置进VIewRootImp了！！
            root.setView(view, wparams, panelParentView);
        } 
...
    }
~~~

分析到这里，我们终于到了要调用VIew的生命周期的方法了,我们看看ViewRootImp的setView方法

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java
public void setView(View view, WindowManager.LayoutParamsattrs,

                        View panelParentView){//第一个参数view是DecorView

      ......

       mView= view;//保存这个view

       synchronized (this) {

           requestLayout(); //待会先看看这个。

               try {

                    //调用IWindowSession的addToDisplay函数，第一个参数是mWindow

                 res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,
                            getHostVisibility(), mDisplay.getDisplayId(),
                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,
                            mAttachInfo.mOutsets, mInputChannel);

               }
           
          ......

}
~~~

ViewRoot的setView函数做了三件事：

·  保存传入的view参数为mView，这个mView指向PhoneWindow的DecorView。

·  调用requestLayout。

·  调用IWindowSession的addToDisplay函数，这是一个跨进程的Binder通信，第一个参数是mWindow，它是W类型，从IWindow.stub派生。

## 熟悉的绘制流程

我们先看看requestLayout做了什么

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java  
@Override
    public void requestLayout() {
        if (!mHandlingLayoutInLayoutRequest) {
            //检查当前线程是否是UI线程！！！
            checkThread();
            mLayoutRequested = true;
            //是不是就去绘制了？？
            scheduleTraversals();
        }
    }


    void scheduleTraversals() {
        if (!mTraversalScheduled) {
            mTraversalScheduled = true;
            //发了个消息,所以我们看看mTraversalRunnable写了什么
            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();
            mChoreographer.postCallback(
                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);
            ...
        }
    }

 final class TraversalRunnable implements Runnable {
        @Override
        public void run() {
            //继续
            doTraversal();
        }
    }

   void doTraversal() {
        if (mTraversalScheduled) {
            mTraversalScheduled = false;
            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);

            if (mProfile) {
                Debug.startMethodTracing("ViewAncestor");
            }

            //看这个！！！这是我们熟悉的方法啊！！这能触发绘制！！！
            performTraversals();

            if (mProfile) {
                Debug.stopMethodTracing();
                mProfile = false;
            }
        }
    }

 private void performTraversals() {      
     //这就是我们的DecorVIew
        final View host = mView;
     
     try {

    	relayoutResult= //①关键函数relayoutWindow，标记为G

		relayoutWindow(params, viewVisibility,insetsPending);
   }

......

		performDraw()// ②开始绘制
 }

~~~

我们先看performDraw方法做了什么

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java  
 private void performDraw() {
          ....
        try {
           //这个！！！
            draw(fullRedrawNeeded);
        } finally {
            mIsDrawing = false;
            Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        }
     ...
 }


private void draw(boolean fullRedrawNeeded) {
    	//surface????
        Surface surface = mSurface;
        if (!surface.isValid()) {
            return;
        }
    ...

        //这个！！！
          if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) {
                    return;
         }
    ...

     }


   private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff,
            boolean scalingRequired, Rect dirty) {

        // 看到这个的时候，虎躯一震！这不就是画布吗！！！！
        final Canvas canvas;
        try {
         
            ...

            //锁住
            canvas = mSurface.lockCanvas(dirty);

      ....
          		//绘制！！！
                mView.draw(canvas);

       ...
            
        } finally {
            try {
                //解锁
                surface.unlockCanvasAndPost(canvas);
            }
            ...
        }
        return true;
    }

~~~

我们很清楚的知道view.draw（）方法里面做了些什么，不就是“四大金刚”相互合作，这四大金刚是：

·  Bitmap：用于存储像素，也就是画布。可把它当做一块数据存储区域。

·  Canvas：用于记载画图的动作，比如画一个圆，画一个矩形等。Canvas类提供了这些基本的绘图函数。

·  Drawing primitive：绘图基元，例如矩形、圆、弧线、文本、图片等。

·  Paint：它用来描述绘画时使用的颜色、风格（如实线、虚线等）等。

在一般情况下，Canvas会封装一块Bitmap，而作图就是基于这块Bitmap的。前面说的画布，其实指的就是Canvas中的这块Bitmap。动动脑子想想，显示器这个硬件设备肯定不是java层去直接控制的，我们现在要研究的不是java层的那些个抽象方法调来调去，具体的绘制实现肯定在native层，一定要把它揪出来。

## Surface初现！

我们可以看到在调用view的draw之前，跑出来了一个surface！他的值来源于mSurface字段！！那这块Bitmap是不是就是由这个surface准备的？我们看看他的初始化

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java  
final Surface mSurface = new Surface();
~~~

看看surface的构造函数

~~~java
//home/ba/Android/Sdk/sources/android-25/android/view/Surface.java
//注意这个
 private final Canvas mCanvas = new CompatibleCanvas();
public Surface() {
    }
~~~

空的！！那还能咋办呀？只能看看他的lockCanvas方法干了些什么

~~~java
//home/ba/Android/Sdk/sources/android-25/android/view/Surface.java
public Canvas lockCanvas(Rect inOutDirty)
            throws Surface.OutOfResourcesException, IllegalArgumentException {
        synchronized (mLock) {
            checkNotReleasedLocked();
            if (mLockedObject != 0) {
                // Ideally, nativeLockCanvas() would throw in this situation and prevent the
                // double-lock, but that won't happen if mNativeObject was updated.  We can't
                // abandon the old mLockedObject because it might still be in use, so instead
                // we just refuse to re-lock the Surface.
                throw new IllegalArgumentException("Surface was already locked");
            }
            //是个JNI方法
            mLockedObject = nativeLockCanvas(mNativeObject, mCanvas, inOutDirty);
            //返回了CompatibleCanvas
            return mCanvas;
        }
    }
~~~

这个mCanvas的实际类型为CompatibleCanvas，可以看到调了个JNI函数，很激动吧！！终于看到有native的影子了！所以我们要找到注册的地方，但是我搜索了Serface类，没有调用init方法。但是！！注意看nativeLockCanvas方法传入的参数！mNativeObject！！这是什么？？

~~~java
//home/ba/Android/Sdk/sources/android-25/android/view/Surface.java
long mNativeObject; 
~~~

指针耶！说明这个东西的具体对象其实是在c++层！我们使用surfece的函数时候mNativeObject;都要作为参数传进去，那他是怎么来的?他的真正类型是什么？那就找他的来源吧！

~~~java
//home/ba/Android/Sdk/sources/android-25/android/view/Surface.java
public void copyFrom(SurfaceControl other) {
        if (other == null) {
            throw new IllegalArgumentException("other must not be null");
        }

     	//这里！！！！
        long surfaceControlPtr = other.mNativeObject;
        if (surfaceControlPtr == 0) {
            throw new NullPointerException(
                    "SurfaceControl native object is null. Are you using a released SurfaceControl?");
        }
        long newNativeObject = nativeCreateFromSurfaceControl(surfaceControlPtr);

        synchronized (mLock) {
            if (mNativeObject != 0) {
                nativeRelease(mNativeObject);
            }
            setNativeObjectLocked(newNativeObject);
        }
    }
~~~

这个copyFrom什么时候调用的？？我们在绘制之前，还调用了一个方法在标记G处：relayoutWindow()，他会不会就是去准备SurfaceControl这个对象？

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java   
private int relayoutWindow(WindowManager.LayoutParams params, int viewVisibility,
            boolean insetsPending) throws RemoteException {

       ...
         //注意看最后一个参数，mSurface！！！传进去的原因可能就是去方便调用Surface的方法，说不定就是copyFrom方法！
        int relayoutResult = mWindowSession.relayout(
                mWindow, mSeq, params,
                (int) (mView.getMeasuredWidth() * appScale + 0.5f),
                (int) (mView.getMeasuredHeight() * appScale + 0.5f),
                viewVisibility, insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : 0,
                mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets,
                mPendingStableInsets, mPendingOutsets, mPendingBackDropFrame, mPendingConfiguration,
                mSurface);

        mPendingAlwaysConsumeNavBar =
                (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_CONSUME_ALWAYS_NAV_BAR) != 0;

      ...
        return relayoutResult;
    }
~~~

这个mWindowSession又是什么东西？？到目前为止已经出现了两次进程通信了！！!在VIewRootImp的setVIew方法出现了一次，在relayoutWindow又出现了一次。

## 蛛丝马迹

我们回到ViewRootImp的构造函数仔细看看

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java    
public ViewRootImpl(Context context, Display display) {
      ...
        mWindowSession = WindowManagerGlobal.getWindowSession();
      ...
        mWindow = new W(this);
      
        ...
     
    }

~~~

我们先看getWindowSession

~~~java
//home/ba/Android/Sdk/sources/android-25/android/view/WindowManagerGlobal.java    
public static IWindowSession getWindowSession() {
        synchronized (WindowManagerGlobal.class) {
            if (sWindowSession == null) {
                try {
                    InputMethodManager imm = InputMethodManager.getInstance();
                    IWindowManager windowManager = getWindowManagerService();
                    sWindowSession = windowManager.openSession(
                            new IWindowSessionCallback.Stub() {
                                @Override
                                public void onAnimatorScaleChanged(float scale) {
                                    ValueAnimator.setDurationScale(scale);
                                }
                            },
                            imm.getClient(), imm.getInputContext());
                } catch (RemoteException e) {
                    throw e.rethrowFromSystemServer();
                }
            }
            return sWindowSession;
        }
    }
~~~

可以看到这一次openSession的进程通信的目的端是WMS！我们看看这个openSession干了什么

~~~java
//media/ba/sd/aosp/frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java   
@Override
    public IWindowSession openSession(IWindowSessionCallback callback, IInputMethodClient client,
            IInputContext inputContext) {
        if (client == null) throw new IllegalArgumentException("null client");
        if (inputContext == null) throw new IllegalArgumentException("null inputContext");
        Session session = new Session(this, callback, client, inputContext);
        return session;
    }
~~~

说明了IWindowSession对象是WMS的Bn代理！！！那W类型的mWindow是什么？

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java    
static class W extends IWindow.Stub {
        private final WeakReference<ViewRootImpl> mViewAncestor;
        private final IWindowSession mWindowSession;

        W(ViewRootImpl viewAncestor) {
            mViewAncestor = new WeakReference<ViewRootImpl>(viewAncestor);
            mWindowSession = viewAncestor.mWindowSession;
        }
        
        ...
    }
~~~

嗯，他也是用来进程通信的！他的类型是IWindow，我们后面再讲这个IWindow。我们回到ViewRootImp的setVIew方法

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java
public void setView(View view, WindowManager.LayoutParamsattrs,

                        View panelParentView){//第一个参数view是DecorView

      ......

       mView= view;//保存这个view

       synchronized (this) {

           requestLayout(); 

               try {

                    //调用IWindowSession的add函数，第一个参数是mWindow

                       res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,
                            getHostVisibility(), mDisplay.getDisplayId(),
                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,
                            mAttachInfo.mOutsets, mInputChannel);

               }

          ......

}
~~~

我们先小结一下：

+ 我们在Activity的onCreate阶段进行了装饰我们通过setCotentView方法设置进去的VIew，生成DecorVIew
+ 然后为这个Activity绑定了一个PhoneWindow和WindowMananger
+ 然后在Activity的onResume阶段通过WindowMananger生成了一个ViewRootImp，用来管理我们的DecorVIew

- 我们new了ViewRootImp后就去和WMS进行了进程通信，其实就是先和WMS建立起联系，也算是初始化Binder通信
- 然后调用了VIewRootImp的setVIew方法，这里面做了两件事
- 从requestLayout走到了VIew的draw方法，但是在draw前，进行了一次进程通信，因为有个surface对象和绘制有着莫大的联系，但是我们查看Surface的代码发现他在里面就是一直调用native层的方法，这点我们知道绘制肯定是在native层，有意思的是，在Surface对象里面保存了一个叫做nativeObject的指针，他的类型不是对象，而是long。所以他的真实对象类型我们不清楚，当我们找他的来源时，停在了copyFrom方法，我们不知道谁去调用了这个方法，所以我们猜想是在draw前的进程通信那里做了手脚！！
- 在requestLayout()方法里面绘制完后我们又进行了一次进程通信sWindowSession.addToDisplay（）
- 所以我们现在卡在了两次进程通信！！只要搞明白这两次进程通信就能搞明白Surface到底和绘制有着什么关系。

## 两次进程通信

一个WIndow的作用就两个：行为和外观！  requestLayout(); 方法里面进行了VIew的draw，这里虽然进行了一次进程通信，但是我们相信这一次进程通信是绘制前的准备工作，毕竟他传入了个mSurface对象，所以我觉得requestLayout这里负责外观。

但是走完requestLayout的时候，就又进行了一次进程通信sWindowSession.add，这一次，我觉得是负责行为（也就是按键事件），因为他传入了个mWindow，要知道这个可是一个BInder对象，鉴于IWindowSession是WMS的BInder，所以类型为IWindow的mWindow很有可能就是给WMS回调的Bn端，为什么要回调？按键事件肯定是从WMS来的，WIndow只能等WMS告诉你！！！；

我们先分析sWindowSession.addToDisplay（）因为Surface才是重头戏，我们要放后面讲IWindowSession.aidl的具体实现是Session

~~~java
    //media/ba/sd/aosp/frameworks/base/services/core/java/com/android/server/wm/Session.java
   

    @Override
    public int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs,
            int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets,
            Rect outOutsets, InputChannel outInputChannel) {
        return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId,
                outContentInsets, outStableInsets, outOutsets, outInputChannel);
    }

~~~

可以看到，调用的是服务端的addWindow方法，也就是WMS的addWindow方法

~~~java
//media/ba/sd/aosp/frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java   
public int addWindow(Session session, IWindow client, int seq,
            WindowManager.LayoutParams attrs, int viewVisibility, int displayId,
            Rect outContentInsets, Rect outStableInsets, Rect outOutsets,
            InputChannel outInputChannel) {
      ...
        //创建一个WindowState
            WindowState win = new WindowState(this, session, client, token,
                    attachedWindow, appOp[0], seq, attrs, viewVisibility, displayContent);
           
           ...
        //这个很重要
            win.attach();
        ...

        return res;
    }
~~~



~~~java
//media/ba/sd/aosp/frameworks/base/services/core/java/com/android/server/wm/WindowState.java
void attach() {
        if (WindowManagerService.localLOGV) Slog.v(
            TAG, "Attaching " + this + " token=" + mToken
            + ", list=" + mToken.windows);
        mSession.windowAddedLocked();
    }
~~~

其实就是Session的windowAddedLocked方法

~~~java
//media/ba/sd/aosp/frameworks/base/services/core/java/com/android/server/wm/Session.java 
void windowAddedLocked() {
        if (mSurfaceSession == null) {
            if (WindowManagerService.localLOGV) Slog.v(
                TAG_WM, "First window added to " + this + ", creating SurfaceSession");
            //注意！！！这里
            mSurfaceSession = new SurfaceSession();
            if (SHOW_TRANSACTIONS) Slog.i(
                    TAG_WM, "  NEW SURFACE SESSION " + mSurfaceSession);
            mService.mSessions.add(this);
            if (mLastReportedAnimatorScale != mService.getCurrentAnimatorScale()) {
                mService.dispatchNewAnimatorScaleLocked(this);
            }
        }
        mNumWindow++;
    }
~~~

这里居然生成了个SurfaceSession？？？懵逼！难道我们猜错了？？？这里不是按键处理？？不信这个邪，我们先把这个SurfaceSession放一边，现在我们代码走到了这里，把IWindow放进了WindowState里面，我觉得这样太麻烦了，我们直接看IWIndow的具体代码不就好了！！

~~~java
oneway interface IWindow {
    /**
     * ===== NOTICE =====
     * The first method must remain the first method. Scripts
     * and tools rely on their transaction number to work properly.
     */

    /**
     * Called for wallpaper windows when their offsets change.
     */
    void dispatchWallpaperOffsets(float x, float y, float xStep, float yStep, boolean sync);
    
    void dispatchWallpaperCommand(String action, int x, int y,
            int z, in Bundle extras, boolean sync);

    /**
     * Drag/drop events
     */
    void dispatchDragEvent(in DragEvent event);

    /**
     * Pointer icon events
     */
    void updatePointerIcon(float x, float y);

    /**
     * System chrome visibility changes
     */
    void dispatchSystemUiVisibilityChanged(int seq, int globalVisibility,
            int localValue, int localChanges);

    /**
     * Called for non-application windows when the enter animation has completed.
     */
    void dispatchWindowShown();
}

~~~

明白了？这里的事件指的就是按键、触屏等事件。那么，一个按键事件是如何被分发的呢？下面是它大致的流程：

·  WMS所在的SystemServer进程接收到按键事件。

·  WMS找到UI位于屏幕顶端的进程所对应的IWindow对象，这是一个Bp端对象。

·  调用这个IWindow对象的dispatchKey。IWindow对象的Bn端位于ViewRoot中，ViewRoot再根据内部View的位置信息找到真正处理这个事件的View，最后调用dispatchKey函数完成按键的处理。

其实这些按键事件的分发机制可以拿Windows的UI编程来做类比，在Windows中应用程序的按键处理流程是：

·  每一个按键事件都会转化成一个消息，这个消息将由系统加入到对应进程的消息队列中。该进程的消息在派发处理时，会根据消息的句柄找到对应的Window（窗口），继而该消息就由这个Window处理了。

注意：上面的描述实际上大大简化了真实的处理流程，读者可在了解大体知识后进行更深入的研究。

所以可以看出，这次通信的目的之一就是去注册这个按键，但是我们看到创建了一个SurfaceSession！！说明这次进程通信还进行了一些动西的初始化，但是现在问题来了，我们这次分析的进程通信是在addToDisplay，我们看看下面的代码

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java
public void setView(View view, WindowManager.LayoutParamsattrs,

                        View panelParentView){//第一个参数view是DecorView

      ......

       mView= view;//保存这个view

       synchronized (this) {

           //这里面会有一个进程通信
           requestLayout(); 

               try {

                    //刚刚我们分析的是这个进程通信

                       res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,
                            getHostVisibility(), mDisplay.getDisplayId(),
                            mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,
                            mAttachInfo.mOutsets, mInputChannel);

               }

          ......

}
~~~

所以问题就很大了，为什么初始化的过程居然在requestLayout方法的后面？？我们知道requestLayout方法就是去绘制界面了，都绘制了后才来初始化，有什么用？？所以我们肯定漏了什么东西，我们回到绘制的方法里面

~~~java
    void scheduleTraversals() {
        if (!mTraversalScheduled) {
            mTraversalScheduled = true;
            //发了个消息
            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();
            mChoreographer.postCallback(
                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);
            ...
        }
    }
~~~

我们刚刚是直接分析一发消息就去执行mTraversalRunnable的方法，但是现在看来并不是这样的，这个事件发送出去后，requestLayout方法就结束了！就到addToDisplay了，真正绘制的过程还没有发生！！因为mTraversalRunnable，还没被执行，这样似乎就说的通了，所以说这个mTraversalRunnable是会在合适的时候被调用，我们先看一下时序图

![image](http://wiki.jikexueyuan.com/project/deep-android-v1/images/chapter8/image007.png)

看到5和6，5的add在安卓7.0代码中对应的是addToDisplay()，我们上面分析代码是requestlayout()先，6的relayout()是在mTraversalRunnable里面的，而mTraversalRunnable是在requestlayout()方法被发送出去的，但是还没被执行就到了addToDisplay()方法，所以上面的时序图是正确的，第五步我们生成了一个SurfaceSession，这个可以看出是在第二次进程通信里面要用到，我们先不管mTraversalRunnable是被什么条件触发后执行，现在只需要知道他是在addToDisplay方法后被执行就好了，我们现在就看看mTraversalRunnable被执行后进行的第二次进程通信做了什么！！！

第二次进程通信是在

~~~java
 private void performTraversals() {      
     //这就是我们的DecorVIew
        final View host = mView;
     
     try {

         //这里！！！
    	relayoutResult= 

		relayoutWindow(params, viewVisibility,insetsPending);
   }

......

		performDraw()// ②开始绘制
 }
~~~

在这里我们是有疑惑的，Surface的nativeObject到底是什么？那就要看是谁调用了copyFrom方法？relayoutWindow肯定是对Surface对象进行初始化设置的，一起解密吧！！！

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/android/view/ViewRootImpl.java   
private int relayoutWindow(WindowManager.LayoutParams params, int viewVisibility,
            boolean insetsPending) throws RemoteException {

       ...
         //注意看最后一个参数，mSurface！！！传进去的原因可能就是去方便调用Surface的方法，说不定就是copyFrom方法！
        int relayoutResult = mWindowSession.relayout(
                mWindow, mSeq, params,
                (int) (mView.getMeasuredWidth() * appScale + 0.5f),
                (int) (mView.getMeasuredHeight() * appScale + 0.5f),
                viewVisibility, insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : 0,
                mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets,
                mPendingStableInsets, mPendingOutsets, mPendingBackDropFrame, mPendingConfiguration,
                mSurface);

        mPendingAlwaysConsumeNavBar =
                (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_CONSUME_ALWAYS_NAV_BAR) != 0;

      ...
        return relayoutResult;
    }
~~~

这里就是时序图中的第6步，relayout！！按照Binder的设计，我们应该找到IWindowSession的具体实现：也就是我们说的Bp，我找不到，按照书上说的，就应该去编译这个AIDL文件，就能得到了。

~~~java
//这个类应该叫BpWindowSession.java
public int relayout(android.view.IWindow window,

                 android.view.WindowManager.LayoutParams attrs,

                  int requestedWidth, intrequestedHeight,

                 int viewVisibility, boolean insetsPending,

                 android.graphics.Rect outFrame,

                 android.graphics.Rect outContentInsets,

                 android.graphics.Rect outVisibleInsets,

                 android.content.res.Configuration outConfig,

                 android.view.Surface outSurface)//outSurface是第11个参数

                                    throwsandroid.os.RemoteException

{

   android.os.Parcel_data = android.os.Parcel.obtain();

   android.os.Parcel_reply = android.os.Parcel.obtain();

   int_result;

   try {

      _data.writeInterfaceToken(DESCRIPTOR);

     _data.writeStrongBinder((((window!=null))?(window.asBinder()):(null)));

     if((attrs!=null)) {

       _data.writeInt(1);

       attrs.writeToParcel(_data,0);

     }

    else {

    _data.writeInt(0);

   }

  _data.writeInt(requestedWidth);

  _data.writeInt(requestedHeight);

  _data.writeInt(viewVisibility);

  _data.writeInt(((insetsPending)?(1):(0)));

 //奇怪，outSurface的信息没有写到请求包_data中，就直接发送请求消息了，我们先研究这里

  mRemote.transact(Stub.TRANSACTION_relayout,_data, _reply, 0);

  _reply.readException();

  _result= _reply.readInt();

  if((0!=_reply.readInt())) {

   outFrame.readFromParcel(_reply);

  }

  ....

  if((0!=_reply.readInt())) {

//从Parcel中读取信息来填充outSurface,这里等下我们再看，标记为O
     outSurface.readFromParcel(_reply);

    }

  }

  ......

  return_result;

}
~~~

可以看到上面是没有把ourSurface写到数据包就发送了，但是在等待答复的时候却对outSurface进行了操作，我们先去看看Bn端的接收端发生了什么(这个Bn端的代码按照谷歌的风格应该也是放在IWindowSession的具体实现类里面的)。

~~~java
public boolean onTransact(int code,android.os.Parcel data,

                               android.os.Parcelreply, int flags)

                    throwsandroid.os.RemoteException

{

  switch(code)

  {

    caseTRANSACTION_relayout:

    {

      data.enforceInterface(DESCRIPTOR);

      android.view.IWindow_arg0;

      android.view.Surface_arg10;

      //刚才讲了，Surface信息并没有传过来，那么在relayOut中看到的outSurface是怎么

      //出来的呢？看下面这句可知，原来在服务端这边竟然new了一个新的Surface!!!这个new出来的Surface只是一个中转而已。

      _arg10= new android.view.Surface();
      
      //然后去调用了具体实现的relayout方法，我们等下先讲这个

      int_result = this.relayout(_arg0, _arg1, _arg2, _arg3, _arg4,

      _arg5,_arg6, _arg7, _arg8, _arg9, _arg10);
      
      
      //下面是回复应用进程的代码，我们等下再看，标记为P

      reply.writeNoException();

      reply.writeInt(_result);

      //_arg10就是调用copyFrom的那个outSurface，那怎么传到客户端呢？

      if((_arg10!=null)) {

           reply.writeInt(1);

           //调用Surface的writeToParcel，把信息写到reply包中。

           //注意最后一个参数为PARCELABLE_WRITE_RETURN_VALUE

           _arg10.writeToParcel(reply,

                 android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);

        }

    }

    ......

   return true;

}
~~~

具体实现应该就是Session里面的代码

~~~java
///media/ba/sd/aosp/frameworks/base/services/core/java/com/android/server/wm/Session.java    
public int relayout(IWindow window, int seq, WindowManager.LayoutParams attrs,
            int requestedWidth, int requestedHeight, int viewFlags,
            int flags, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,
            Rect outVisibleInsets, Rect outStableInsets, Rect outsets, Rect outBackdropFrame,
            Configuration outConfig, Surface outSurface) {
        if (false) Slog.d(TAG_WM, ">>>>>> ENTERED relayout from "
                + Binder.getCallingPid());
        //看这里
        int res = mService.relayoutWindow(this, window, seq, attrs,
                requestedWidth, requestedHeight, viewFlags, flags,
                outFrame, outOverscanInsets, outContentInsets, outVisibleInsets,
                outStableInsets, outsets, outBackdropFrame, outConfig, outSurface);
        if (false) Slog.d(TAG_WM, "<<<<<< EXITING relayout to "
                + Binder.getCallingPid());
        return res;
    }
~~~

这里要注意这个outSurface并不是我们从ViewRootImp传过来的！

~~~java
//media/ba/sd/aosp/frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java   
public int relayoutWindow(Session session, IWindow client, int seq,
            WindowManager.LayoutParams attrs, int requestedWidth,
            int requestedHeight, int viewVisibility, int flags,
            Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,
            Rect outVisibleInsets, Rect outStableInsets, Rect outOutsets, Rect outBackdropFrame,
            Configuration outConfig, Surface outSurface) {
        int result = 0;
        boolean configChanged;
        boolean hasStatusBarPermission =
                mContext.checkCallingOrSelfPermission(android.Manifest.permission.STATUS_BAR)
                        == PackageManager.PERMISSION_GRANTED;

        long origId = Binder.clearCallingIdentity();
        synchronized(mWindowMap) {
            //注意看这个，去查找WIndowState！这个WindowState在上一次进程通信的时候就生成了！
            WindowState win = windowForClientLocked(session, client, false);
            if (win == null) {
                return 0;
            }

           ...

    
   
              if (viewVisibility == View.VISIBLE &&
                    (win.mAppToken == null || !win.mAppToken.clientHidden)) {
                result = relayoutVisibleWindow(outConfig, result, win, winAnimator, attrChanges,
                        oldVisibility);
                try {
                    //我们看这一句，虽然下面的代码也有getSession，但是我觉得从这里入手比较好
                    result = createSurfaceControl(outSurface, result, win, winAnimator);
                } catch (Exception e) {
                    mInputMonitor.updateInputWindowsLw(true /*force*/);

                    Slog.w(TAG_WM, "Exception thrown when creating surface for client "
                             + client + " (" + win.mAttrs.getTitle() + ")",
                             e);
                    Binder.restoreCallingIdentity(origId);
                    return 0;
                }
        
                  //这里有用到，但是上面的方法可以看到surfaceController的创建，所以我们还是分析上面的方法吧
                final WindowSurfaceController surfaceController = winAnimator.mSurfaceController;
                if (viewVisibility == View.VISIBLE && surfaceController != null) {
                    // We already told the client to go invisible, but the message may not be
                    // handled yet, or it might want to draw a last frame. If we already have a
                    // surface, let the client use that, but don't create new surface at this point.
                    surfaceController.getSurface(outSurface);
                } else {
                   ...
        return result;
    }
                  
                  
 private int createSurfaceControl(Surface outSurface, int result, WindowState win,
            WindowStateAnimator winAnimator) {
        if (!win.mHasSurface) {
            result |= RELAYOUT_RES_SURFACE_CHANGED;
        }
     	//先看这个
        WindowSurfaceController surfaceController = winAnimator.createSurfaceLocked();
        if (surfaceController != null) {
            //这个等再看
            surfaceController.getSurface(outSurface);
            if (SHOW_TRANSACTIONS) Slog.i(TAG_WM, "  OUT SURFACE " + outSurface + ": copied");
        } else {
            // For some reason there isn't a surface.  Clear the
            // caller's object so they see the same state.
            Slog.w(TAG_WM, "Failed to create surface control for " + win);
            outSurface.release();
        }
        return result;
    }
~~~

~~~~java
//media/ba/sd/aosp/frameworks/base/services/core/java/com/android/server/wm/WindowStateAnimator.java  
WindowSurfaceController createSurfaceLocked() {
        final WindowState w = mWin;
      
...
      	//这里！！可以看到他把SurfaceSession传了进去！我还一直纳闷前面生成的这个东西没有用呢!原来用在这里了！！！！
        mSurfaceController = new WindowSurfaceController(mSession.mSurfaceSession,
                    attrs.getTitle().toString(),
                    width, height, format, flags, this);

            w.setHasSurface(true);

           ...
        return mSurfaceController;
    }

~~~~

现在只能看WindowSurfaceController的构造函数了！！

~~~java
//media/ba/sd/aosp/frameworks/base/services/core/java/com/android/server/wm/WindowSurfaceController.java   
public WindowSurfaceController(SurfaceSession s,
            String name, int w, int h, int format, int flags, WindowStateAnimator animator) {
        mAnimator = animator;

        mSurfaceW = w;
        mSurfaceH = h;

        title = name;

  
        // For opaque child windows placed under parent windows,
        // we use a special SurfaceControl which mirrors commands
        // to a black-out layer placed one Z-layer below the surface.
        // This prevents holes to whatever app/wallpaper is underneath.
        if (animator.mWin.isChildWindow() &&
                animator.mWin.mSubLayer < 0 &&
                animator.mWin.mAppToken != null) {
            mSurfaceControl = new SurfaceControlWithBackground(s,
                    name, w, h, format, flags, animator.mWin.mAppToken);
        } else if (DEBUG_SURFACE_TRACE) {
            mSurfaceControl = new SurfaceTrace(
                    s, name, w, h, format, flags);
        } else {
            mSurfaceControl = new SurfaceControl(
                    s, name, w, h, format, flags);
        }
    }
~~~

wtf。。。服了，，我们看最后一个

~~~java
///media/ba/sd/aosp/frameworks/base/core/java/android/view/SurfaceControl.java   
public SurfaceControl(SurfaceSession session,
            String name, int w, int h, int format, int flags)
                    throws OutOfResourcesException {
        if (session == null) {
            throw new IllegalArgumentException("session must not be null");
        }
        if (name == null) {
            throw new IllegalArgumentException("name must not be null");
        }

        if ((flags & SurfaceControl.HIDDEN) == 0) {
            Log.w(TAG, "Surfaces should always be created with the HIDDEN flag set "
                    + "to ensure that they are not made visible prematurely before "
                    + "all of the surface's properties have been configured.  "
                    + "Set the other properties and make the surface visible within "
                    + "a transaction.  New surface name: " + name,
                    new Throwable());
        }

        mName = name;
    	//看这里！原来在ViewRootImp的surface的nativeObject是这里创建的，而且还是个JNI方法，我们先不分析这个JNI方法，我们标记为T，我们现在还是不知道mNativeObject这个动动是什么类型的，但是大概可以猜到他就是Native层的Surface！！！
        mNativeObject = nativeCreate(session, name, w, h, format, flags);
        if (mNativeObject == 0) {
            throw new OutOfResourcesException(
                    "Couldn't allocate SurfaceControl native object");
        }

        mCloseGuard.open("release");
    }

~~~

现在让我们回到surfaceController.getSurface(outSurface);方法

~~~java
//media/ba/sd/aosp/frameworks/base/services/core/java/com/android/server/wm/WindowSurfaceController.java 
void getSurface(Surface outSurface) {
        outSurface.copyFrom(mSurfaceControl);
    }
~~~

这里需要注意！！这个outSurface不是我们VIewRootImp里面的Surface对象，而是在Bn端直接new出来的，但是我们知道这个copyFrom对象就是把mSurfaceControl配置好的一些东西设置到outSurface里面去，尤其是那个nativeObject！，但是里面还是会调用到JNI的方法，我们先不管JNI层的调用！现在我们回到标记P

~~~java
public boolean onTransact(int code,android.os.Parcel data,

                               android.os.Parcelreply, int flags)

                    throwsandroid.os.RemoteException

{      
...
      //，标记为P

      reply.writeNoException();

      reply.writeInt(_result);

      //_arg10就是调用copyFrom的那个outSurface，那怎么传到客户端呢？

      if((_arg10!=null)) {

           reply.writeInt(1);

           //调用Surface的writeToParcel，把信息写到reply包中。

           //注意最后一个参数为PARCELABLE_WRITE_RETURN_VALUE

           _arg10.writeToParcel(reply,

                 android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);

        }

    }

    ......

   return true;

}
~~~

我们看看Surface的writeToParcel方法

~~~java
//home/ba/Android/Sdk/sources/android-25/android/view/Surface.java    
@Override
    public void writeToParcel(Parcel dest, int flags) {
        if (dest == null) {
            throw new IllegalArgumentException("dest must not be null");
        }
        synchronized (mLock) {
            // NOTE: This must be kept synchronized with the native parceling code
            // in frameworks/native/libs/Surface.cpp
            dest.writeString(mName);
            dest.writeInt(mIsSingleBuffered ? 1 : 0);
            nativeWriteToParcel(mNativeObject, dest);
        }
        if ((flags & Parcelable.PARCELABLE_WRITE_RETURN_VALUE) != 0) {
            release();
        }
    }
~~~

又是跑到JNI调用，okok，我们先不分析JNI的东西，这一步无非就是把信息写过去而已，现在回到Bp端,就是标记O处

~~~java
//这个类应该叫BpWindowSession.java
public int relayout(android.view.IWindow window,

                 android.view.WindowManager.LayoutParams attrs,

                  int requestedWidth, intrequestedHeight,

                 int viewVisibility, boolean insetsPending,

                 android.graphics.Rect outFrame,

                 android.graphics.Rect outContentInsets,

                 android.graphics.Rect outVisibleInsets,

                 android.content.res.Configuration outConfig,

                 android.view.Surface outSurface)//outSurface是第11个参数

                                    throwsandroid.os.RemoteException

{

   android.os.Parcel_data = android.os.Parcel.obtain();

   android.os.Parcel_reply = android.os.Parcel.obtain();

   int_result;

   try {

      _data.writeInterfaceToken(DESCRIPTOR);

     _data.writeStrongBinder((((window!=null))?(window.asBinder()):(null)));

     if((attrs!=null)) {

       _data.writeInt(1);

       attrs.writeToParcel(_data,0);

     }

    else {

    _data.writeInt(0);

   }

  _data.writeInt(requestedWidth);

  _data.writeInt(requestedHeight);

  _data.writeInt(viewVisibility);

  _data.writeInt(((insetsPending)?(1):(0)));

 //奇怪，outSurface的信息没有写到请求包_data中，就直接发送请求消息了，我们先研究这里

  mRemote.transact(Stub.TRANSACTION_relayout,_data, _reply, 0);

  _reply.readException();

  _result= _reply.readInt();

  if((0!=_reply.readInt())) {

   outFrame.readFromParcel(_reply);

  }

  ....

  if((0!=_reply.readInt())) {

//标记为O
     outSurface.readFromParcel(_reply);

    }

  }

  ......

  return_result;

}
~~~

这个readFromParcel里面肯定也是jni层的调用，其实就是把Bn端的数据搞过来，现在我们小结一下再进行JNI层的分析

+ 我们猜想这个NativeObject就是Native层的Surface对象，SurfaceSession作为参数WMS生成这个NativeObject
+ 然后传回到我们进程的Surface对象中
+ 所以这一次进程通信就是为了生成Native层的Surface对象，但是整个Surface转移的过程可谓是非常复杂

下面我们开始看JNI层的代码，下面是我们分析的步骤

+ 分析生成NativeObject的代码
+ 



































































