[TOC]

# 正式开始学习源码

今天正式开始系统的学习安卓的源码，学习的书籍是 邓凡平《深入理解ANDROID 卷1》

# 安卓系统架构

这就要从安卓系统的架构开始说起了，安卓架构相信大家都看过一张图

![](https://img-my.csdn.net/uploads/201209/30/1348969664_7187.jpg) 

蓝色部分的开发语言是java,绿色和红色是c++/c，那绿色是什么东西？

绿色部分叫动态链接库 ，我们称作为native层，一般指的是c/c++写的函数，这些函数可以调用上层的java的代码。而java也可以调用这些c/c++ 写的函数。而红色部分就是linux内核驱动。

书上的例子十分准确，为了能记住我直接打一遍：

java程序是运行在JVM(虚拟机)中，这样就可以实现平台不相关性，java程序就能跑在不同的系统环境下。那JVM是属于哪层？就是native层，系统环境属于红色的部分，因为安卓其实就是linux，所以图中是linux，假设安卓底层是window，那红色部分就是window！我们知道，不同的系统环境对于文件或者其他设备的操作肯定是不一样的，所以需要JVM去适配，去兼容。

现在知道为什么安卓的结构是这样了吧！那你会疑问：为什么不直接用c++语言编写安卓的应用程序？那样安卓不就是一个llinux了吗？那没有那么多层的转换，不是运行效率会更加快吗？道理是这么个道理，那你问问自己：为什么你要学java不专攻c++？还有，你看linux做了这么多年，软件还是少的可怜，这种环境下，安卓当然选择拥抱java了！而且虽然一门编程语言兴起，但是不代表另一门语言会消失，早在java出生前，很多程序都是c++/c写的,所有想改朝换代不是那么的容易，所以安卓高搞这种架构也是一种折中的方案。

# 了解JNI

那就有一个问题啦，java是如何去调用c++/c的代码？？反过来呢？这里就要说到JNI了。JNI是一种技术，是方便java与c++之间相互调用对方代码的技术。（就是上图中蓝色的java和绿色的native部分怎么相互沟通的技术）。

看看下面：

~~~jva

java世界  <------ 使用JNI技术通信  --------->   native（c++）世界  ------> 对linux系统的操作。 
~~~

假设java想要调用native层的函数，就必须通过一个位于JNI层的动态链接库来实现，动态链接库就是运行时加载的库，也就是说，在java代码里面加载对应的库，就能通过java代码调用native层的的具体代码！！！！

## 从MediaScanner下手

这个是安卓中用java写的MediaScanner类，他的作用就是扫描媒体文件等等。

看看下面的关系：

~~~java
JAVA（MediaScanner） <-------JNI(libmedia_jni.so)----->Native(libmedia.so)
~~~

+ MediaScanner

  > 他是java层的一个java类

+ libmedia_jni.so

  > 他是JNI层的一个动态链接库，他里面包含了有关MediaScanner和libmedia.so关系的文件。也是c++写的

+ libmedia.so

  > 他是具体实现一些你调用的native层函数的库

我们先看看java层的代码

~~~java
public class MediaScanner implements AutoCloseable {
    ....
    static {
        System.loadLibrary("media_jni");
        native_init();
    }
    ....
}
~~~

呐呐呐！！！写在静态代码块里面，类一加载就去加载JNI层对应的动态链接库！！！这个JNI库加载时机是：任何地方，任何时候都可以加载！那什么时候用呢？别急，我们先看看java调用native层的代码在哪里

~~~java
public class MediaScanner implements AutoCloseable {
    ....
    static {
        System.loadLibrary("media_jni");
        native_init();
    }
 
    ....
        
        
    public void scanDirectories(String[] directories) {
        ...

            for (int i = 0; i < directories.length; i++) {
                processDirectory(directories[i], mClient);
            }
        
        ...
    }
    
    ...
        
        
    private native void processDirectory(String path, MediaScannerClient client);
}

~~~

仔细观察上面的两个函数。scanDirectories()是常见的java函数，他是扫描文件夹用的，但是前面说了，你操作文件系统这种东西，肯定是操作系统级别干的，那就是说是native层干的，可以看到他调用了processDirectory()函数，而这个函数他并没有具体的实现代码，还多了个native的标识,但是java就是调用这个方法去实现扫描文件夹的功能啊！怎么会什么都没有实现呢？别急！函数带有native标识 ，是为了声明这个函数将会由JNI层实现。那我们就看看JNI层的这两个函数的具体实现，看他是怎么去调用native层的c++函数。

MediaScanner的JNI层代码是在frameworks/base/media/jni/android_media_MediaScanner.cpp这个文件里面，你注意一下这个文件的名字。其实他这样命名真正的含义是：这个文件对应的java层是在包： android.media.MediaScanner.java

那我们看看他里面有没有对应java层的processDirectory()函数

~~~java

static void
android_media_MediaScanner_processDirectory(
        JNIEnv *env, jobject thiz, jstring path, jobject client)
{
    ALOGV("processDirectory");
    MediaScanner *mp = getNativeScanner_l(env, thiz);
    if (mp == NULL) {
        jniThrowException(env, kRunTimeException, "No scanner available");
        return;
    }

    if (path == NULL) {
        jniThrowException(env, kIllegalArgumentException, NULL);
        return;
    }

    const char *pathStr = env->GetStringUTFChars(path, NULL);
    if (pathStr == NULL) {  // Out of memory
        return;
    }

    MyMediaScannerClient myClient(env, client);
    MediaScanResult result = mp->processDirectory(pathStr, myClient);
    if (result == MEDIA_SCAN_RESULT_ERROR) {
        ALOGE("An error occurred while scanning directory '%s'.", pathStr);
    }
    env->ReleaseStringUTFChars(path, pathStr);
}
~~~

还真的有！！！ 一堆巴拉巴拉的代码，我们可以先不管他怎么去实现的，也不管JNI层是怎样去调用native层的函数，现在出现了一个最大的问题就是：java层的MediaScanner.java里面带有native标识的函数是如何和jNI层的android_media_MediaScanner.cpp的对应函数进行关联的？？？？

就好比你知道学生需要老师的教导，你找到了一堆学生，也找到了一堆老师，但是学生和老师是怎么关联起来的？你怎么知道其中的某一个学生是哪个老师教的？

## JNI层和Java层的关联

在书上说的关联方式有两种：

+ 静态注册
+ 动态注册

ps：注册的意思就是怎么把Java层标有native的函数和JNI层的函数关联起来。

### 静态注册

静态其实无非就是一开始就注册好（这里我理解为：就是有个声明关系的公用文件，类似于索引？），当你真的需要用到的时候就已经关联好了。我们可以发现java层的文件对应的JNI的文件的名字是很有规律的？说不定他就是根据名字来关联的？对的！但是他需要Java的工具程序javah参与，流程如下

+ 我们先编写代码，编译生产.class文件
+ 然后使用javah来生成一个叫output.h的文件，例如这个命令是：javah -o output packagename.classname  。他就会生成output.h文件，这个文件里面声明了对应的JNI层函数，只要实现里面的函数即可。

咦！那你会觉得很奇怪，我们上面没有说到什么头文件啊！也没有看到有讲到什么.h文件吧？而且不是说JNI层是android_media_MediaScanner.cpp吗？里面不是有实现java对应的函数吗？为什么突然变成在什么什么头文件里面实现了？？？

嗯。。别急，其实只是正好，MediaScanner这个类他和JNI层关联的方法不是静态方法，你在源码搜索android_media_MediaScanner.h这个文件也是搜索不到的。但是你能搜索到其他的类对应的头文件，说明注册的方法也是各有各的缺点的，需要根据具体的情况进行使用。但是我们还是要看看静态注册的流程：

> 当java层调用native标识的函数时，java虚拟机会从对应的JNI库中找到对应的函数(这里就是根据名字了，就是根据前面生成的.h头文件查询)，如果找到就会为java层和JNI层的对应函数进行关联，这个关联动作就是虚拟机保存JNI层的对应函数的指针，当以后再调用java层的native函数时就会直接使用这个函数指针。

弊端：

+ 只要是声明了native函数的类都要用javah生成一个头文件
+ 生成的JNI层函数名字长，书写不方便
+ 初次调用native函数的时候需要根据函数名字去头文件搜索对的JNI层的函数，然后建立关联，保存函数指针































