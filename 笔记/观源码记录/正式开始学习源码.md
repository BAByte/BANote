[TOC]

# 正式开始学习源码

今天正式开始系统的学习安卓的源码，学习的书籍是 邓凡平《深入理解ANDROID 卷1》

# 安卓系统架构

这就要从安卓系统的架构开始说起了，安卓架构相信大家都看过一张图

![](https://img-my.csdn.net/uploads/201209/30/1348969664_7187.jpg) 

蓝色部分的开发语言是java,绿色和红色是c++/c，那绿色是什么东西？

绿色部分叫动态链接库 ，我们称作为native层，一般指的是c/c++写的函数，这些函数可以调用上层的java的代码。而java也可以调用这些c/c++ 写的函数。而红色部分就是linux内核驱动。

书上的例子十分准确，为了能记住我直接打一遍：

java程序是运行在JVM(虚拟机)中，这样就可以实现平台不相关性，java程序就能跑在不同的系统环境下。那JVM是属于哪层？就是native层，系统环境属于红色的部分，因为安卓其实就是linux，所以图中是linux，假设安卓底层是window，那红色部分就是window！我们知道，不同的系统环境对于文件或者其他设备的操作肯定是不一样的，所以需要JVM去适配，去兼容。

现在知道为什么安卓的结构是这样了吧！那你会疑问：为什么不直接用c++语言编写安卓的应用程序？那样安卓不就是一个llinux了吗？那没有那么多层的转换，不是运行效率会更加快吗？道理是这么个道理，那你问问自己：为什么你要学java不专攻c++？还有，你看linux做了这么多年，软件还是少的可怜，这种环境下，安卓当然选择拥抱java了！而且虽然一门编程语言兴起，但是不代表另一门语言会消失，早在java出生前，很多程序都是c++/c写的,所有想改朝换代不是那么的容易，所以安卓高搞这种架构也是一种折中的方案。

# 了解JNI

那就有一个问题啦，java是如何去调用c++/c的代码？？反过来呢？这里就要说到JNI了。JNI是一种技术，是方便java与c++之间相互调用对方代码的技术。（就是上图中蓝色的java和绿色的native部分怎么相互沟通的技术）。

看看下面：

~~~jva

java世界  <------ 使用JNI技术通信  --------->   native（c++）世界  ------> 对linux系统的操作。 
~~~

假设java想要调用native层的函数，就必须通过一个位于JNI层的动态链接库来实现，动态链接库就是运行时加载的库，也就是说，在java代码里面加载对应的库，就能通过java代码调用native层的的具体代码！！！！

## 从MediaScanner下手

这个是安卓中用java写的MediaScanner类，他的作用就是扫描媒体文件等等。

看看下面的关系：

~~~java
JAVA（MediaScanner） <-------JNI(libmedia_jni.so)----->Native(libmedia.so)
~~~

+ MediaScanner

  > 他是java层的一个java类

+ libmedia_jni.so

  > 他是JNI层的一个动态链接库，他里面包含了有关MediaScanner和libmedia.so关系的文件。也是c++写的

+ libmedia.so

  > 他是具体实现一些你调用的native层函数的库

我们先看看java层的代码

~~~java
public class MediaScanner implements AutoCloseable {
    ....
    static {
        System.loadLibrary("media_jni");
        native_init();
    }
    ....
}
~~~

呐呐呐！！！写在静态代码块里面，类一加载就去加载JNI层对应的动态链接库！！！这个JNI库加载时机是：任何地方，任何时候都可以加载！那什么时候用呢？别急，我们先看看java调用native层的代码在哪里

~~~java
public class MediaScanner implements AutoCloseable {
    ....
    static {
        System.loadLibrary("media_jni");
        native_init();
    }
 
    ....
        
        
    public void scanDirectories(String[] directories) {
        ...

            for (int i = 0; i < directories.length; i++) {
                processDirectory(directories[i], mClient);
            }
        
        ...
    }
    
    ...
        
        
    private native void processDirectory(String path, MediaScannerClient client);
}

~~~

仔细观察上面的两个函数。scanDirectories()是常见的java函数，他是扫描文件夹用的，但是前面说了，你操作文件系统这种东西，肯定是操作系统级别干的，那就是说是native层干的，可以看到他调用了processDirectory()函数，而这个函数他并没有具体的实现代码，还多了个native的标识,但是java就是调用这个方法去实现扫描文件夹的功能啊！怎么会什么都没有实现呢？别急！函数带有native标识 ，是为了声明这个函数将会由JNI层实现。那我们就看看JNI层的这两个函数的具体实现，看他是怎么去调用native层的c++函数。

MediaScanner的JNI层代码是在frameworks/base/media/jni/android_media_MediaScanner.cpp这个文件里面，你注意一下这个文件的名字。其实他这样命名真正的含义是：这个文件对应的java层是在包： android.media.MediaScanner.java

那我们看看他里面有没有对应java层的processDirectory()函数

~~~java

static void
android_media_MediaScanner_processDirectory(
        JNIEnv *env, jobject thiz, jstring path, jobject client)
{
    ALOGV("processDirectory");
    MediaScanner *mp = getNativeScanner_l(env, thiz);
    if (mp == NULL) {
        jniThrowException(env, kRunTimeException, "No scanner available");
        return;
    }

    if (path == NULL) {
        jniThrowException(env, kIllegalArgumentException, NULL);
        return;
    }

    const char *pathStr = env->GetStringUTFChars(path, NULL);
    if (pathStr == NULL) {  // Out of memory
        return;
    }

    MyMediaScannerClient myClient(env, client);
    MediaScanResult result = mp->processDirectory(pathStr, myClient);
    if (result == MEDIA_SCAN_RESULT_ERROR) {
        ALOGE("An error occurred while scanning directory '%s'.", pathStr);
    }
    env->ReleaseStringUTFChars(path, pathStr);
}
~~~

还真的有！！！ 

































