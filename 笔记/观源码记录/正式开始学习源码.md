[TOC]

# 正式开始学习源码

今天正式开始系统的学习安卓的源码，学习的书籍是 邓凡平《深入理解ANDROID 卷1》

# 安卓系统架构

这就要从安卓系统的架构开始说起了，安卓架构相信大家都看过一张图

![](https://img-my.csdn.net/uploads/201209/30/1348969664_7187.jpg) 

蓝色部分的开发语言是java,绿色和红色是c++/c，那绿色是什么东西？

绿色部分叫动态链接库 ，我们称作为native层，一般指的是c/c++写的函数，这些函数可以调用上层的java的代码。而java也可以调用这些c/c++ 写的函数。而红色部分就是linux内核驱动。

书上的例子十分准确，为了能记住我直接打一遍：

java程序是运行在JVM(虚拟机)中，这样就可以实现平台不相关性，java程序就能跑在不同的系统环境下。那JVM是属于哪层？就是native层，系统环境属于红色的部分，因为安卓其实就是linux，所以图中是linux，假设安卓底层是window，那红色部分就是window！我们知道，不同的系统环境对于文件或者其他设备的操作肯定是不一样的，所以需要JVM去适配，去兼容。

现在知道为什么安卓的结构是这样了吧！那你会疑问：为什么不直接用c++语言编写安卓的应用程序？那样安卓不就是一个llinux了吗？那没有那么多层的转换，不是运行效率会更加快吗？道理是这么个道理，那你问问自己：为什么你要学java不专攻c++？还有，你看linux做了这么多年，软件还是少的可怜，这种环境下，安卓当然选择拥抱java了！而且虽然一门编程语言兴起，但是不代表另一门语言会消失，早在java出生前，很多程序都是c++/c写的,所有想改朝换代不是那么的容易，所以安卓高搞这种架构也是一种折中的方案。

# 了解JNI

那就有一个问题啦，java是如何去调用c++/c的代码？？反过来呢？这里就要说到JNI了。JNI是一种技术，是方便java与c++之间相互调用对方代码的技术。（就是上图中蓝色的java和绿色的native部分怎么相互沟通的技术）。

看看下面：

~~~jva

java世界  <------ 使用JNI技术通信  --------->   native（c++）世界  ------> 对linux系统的操作。 
~~~

假设java想要调用native层的函数，就必须通过一个位于JNI层的动态链接库来实现，动态链接库就是运行时加载的库，也就是说，在java代码里面加载对应的库，就能通过java代码调用native层的的具体代码！！！！

## 从MediaScanner下手

这个是安卓中用java写的MediaScanner类，他的作用就是扫描媒体文件等等。

看看下面的关系：

~~~java
JAVA（MediaScanner） <-------JNI(libmedia_jni.so)----->Native(libmedia.so)
~~~

+ MediaScanner

  > 他是java层的一个java类

+ libmedia_jni.so

  > 他是JNI层的一个动态链接库，他里面包含了有关MediaScanner和libmedia.so关系的文件。也是c++写的

+ libmedia.so

  > 他是具体实现一些你调用的native层函数的库

我们先看看java层的代码

~~~java
public class MediaScanner implements AutoCloseable {
    ....
    static {
        System.loadLibrary("media_jni");
        native_init();
    }
    ....
}
~~~

呐呐呐！！！写在静态代码块里面，类一加载就去加载JNI层对应的动态链接库！！！这个JNI库加载时机是：任何地方，任何时候都可以加载！那什么时候用呢？别急，我们先看看java尝试去调用native层的代码在哪里

~~~java
public class MediaScanner implements AutoCloseable {
    ....
    static {
        System.loadLibrary("media_jni");
        native_init();
    }
 
    ....
        
        
    public void scanDirectories(String[] directories) {
        ...

            for (int i = 0; i < directories.length; i++) {
                processDirectory(directories[i], mClient);
            }
        
        ...
    }
    
    ...
        
        
    private native void processDirectory(String path, MediaScannerClient client);
}

~~~

仔细观察上面的两个函数。scanDirectories()是常见的java函数，他是扫描文件夹用的，但是前面说了，你操作文件系统这种东西，肯定是操作系统级别干的，那就是说是native层干的，可以看到他调用了processDirectory()函数，而这个函数他并没有具体的实现代码，还多了个native的标识,但是java就是调用这个方法去实现扫描文件夹的功能啊！怎么会什么都没有实现呢？别急！函数带有native标识 ，是为了声明这个函数将会由JNI层实现。那我们就看看JNI层的这两个函数的具体实现，看他是怎么去调用native层的c++函数。

MediaScanner的JNI层代码是在frameworks/base/media/jni/android_media_MediaScanner.cpp这个文件里面，你注意一下这个文件的名字。其实他这样命名真正的含义是：这个文件对应的java层是在包： android.media.MediaScanner.java

那我们看看他里面有没有对应java层的processDirectory()函数

~~~java

static void
android_media_MediaScanner_processDirectory(
        JNIEnv *env, jobject thiz, jstring path, jobject client)
{
    ALOGV("processDirectory");
    MediaScanner *mp = getNativeScanner_l(env, thiz);
    if (mp == NULL) {
        jniThrowException(env, kRunTimeException, "No scanner available");
        return;
    }

    if (path == NULL) {
        jniThrowException(env, kIllegalArgumentException, NULL);
        return;
    }

    const char *pathStr = env->GetStringUTFChars(path, NULL);
    if (pathStr == NULL) {  // Out of memory
        return;
    }

    MyMediaScannerClient myClient(env, client);
    MediaScanResult result = mp->processDirectory(pathStr, myClient);
    if (result == MEDIA_SCAN_RESULT_ERROR) {
        ALOGE("An error occurred while scanning directory '%s'.", pathStr);
    }
    env->ReleaseStringUTFChars(path, pathStr);
}
~~~

还真的有！！！ 一堆巴拉巴拉的代码，我们可以先不管他怎么去实现的，也不管JNI层是怎样去调用native层的函数，现在出现了一个最大的问题就是：java层的MediaScanner.java里面带有native标识的函数是如何和jNI层的android_media_MediaScanner.cpp的对应函数进行关联的？？？？

就好比你知道学生需要老师的教导，你找到了一堆学生，也找到了一堆老师，但是学生和老师是怎么关联起来的？你怎么知道其中的某一个学生是哪个老师教的？

## JNI层和Java层的关联

在书上说的关联方式有两种：

+ 静态注册
+ 动态注册

ps：注册的意思就是怎么把Java层标有native的函数和JNI层的函数关联起来。

### 静态注册

静态其实无非就是一开始就注册好（这里我理解为：就是有个声明关系的公用文件，类似于索引？），当你真的需要用到的时候就已经关联好了。我们可以发现java层的文件对应的JNI的文件的名字是很有规律的？说不定他就是根据名字来关联的？对的！但是他需要Java的工具程序javah参与，流程如下

+ 我们先编写代码，编译生产.class文件
+ 然后使用javah来生成一个叫output.h的文件，例如这个命令是：javah -o output packagename.classname  。他就会生成output.h文件，这个文件里面声明了对应的JNI层函数，只要实现里面的函数即可。

咦！那你会觉得很奇怪，我们上面没有说到什么头文件啊！也没有看到有讲到什么.h文件吧？而且不是说JNI层是android_media_MediaScanner.cpp吗？里面不是有实现java对应的函数吗？为什么突然变成在什么什么头文件里面实现了？？？

嗯。。别急，其实只是正好，MediaScanner这个类他和JNI层关联的方法不是静态方法，你在源码搜索android_media_MediaScanner.h这个文件也是搜索不到的。但是你能搜索到其他的类对应的头文件，说明注册的方法也是各有各的缺点的，需要根据具体的情况进行使用。但是我们还是要看看静态注册的流程：

> 当java层调用native标识的函数时，java虚拟机会从对应的JNI库中找到对应的函数(这里就是根据名字了，就是根据前面生成的.h头文件查询)，如果找到就会为java层和JNI层的对应函数进行关联，这个关联动作就是虚拟机保存JNI层的对应函数的指针，当以后再调用java层的native函数时就会直接使用这个函数指针。

弊端：

+ 只要是声明了native函数的类都要用javah生成一个头文件
+ 生成的JNI层函数名字长，书写不方便
+ 初次调用native函数的时候需要根据函数名字去头文件搜索对的JNI层的函数，然后建立关联，保存函数指针

### 动态注册

动态注册就是MediaScanner使用的了。静态注册是先建立一个头文件，在使用的时候javva虚拟机根据该头文件去建立java函数和JNI函数的关联。那能不能一开始就建立关联，比如说：你不一定知道这个学生是哪个学生教的，但是这个学生知道啊，你直接问他不就好了。

按照前面静态的逻辑，其实就是保存函数的指针对吧？JNI技术定义了一个结构体用来存这些东西，这样就不需要什么头文件了呀！！！这个结构体就可以直接放在JNI对应的库里面啦！！你看，前面我们说的java类是不是要加载对应的JNI库？这个库里面是不是就对应我们的android_media_MediaScanner.cpp这个文件？这个文件就相当于我们前面说的学生！！你把结构体写在里面，他不就知道自己对应的是哪个java函数了吗？？那虚拟机直接问这个“学生”不就知道对应的java层函数是哪个了吗？

这个结构体叫做JNINativeMethod,我们先看看这个结构体的结构

~~~java

tyoedef struct{
    //java中的函数名字
    const char; name;
    //java函数的签名信息，用字符串表示，是参数类型和返回类型的组合；
    const char* signature;
    //JNI层对应的函数的函数指针， 注意他是void*类型
    void* fnPtr;
} JNInativeMethod;
~~~



其实看了这个结构体的结构，你就会发现，不就是调用函数需要的条件吗？调用函数需要函数的指针吧？需要知道返回类型吧？需要知道参数吧？正好这个结构体都包含了！那怎么去使用？其实就和我们需要一个全局变量是一样的，我们在我们使用时肯定需要把这些个全局变量初始化，这样就可以直接用了。不懂这个意思没有关系，往下看。

这个记录了函数信息的结构体我们肯定是放在JNI层对应的文件里面，正如前面所说的：android_media_MediaScanner.cpp。但是我们不止一个函数，我们就定义为结构体数组，我们看看安卓源码怎么写的

~~~java
static const JNINativeMethod gMethods[] = {
    {
        "processDirectory",
        "(Ljava/lang/String;Landroid/media/MediaScannerClient;)V",
        (void *)android_media_MediaScanner_processDirectory
    },

    {
        "processFile",
        "(Ljava/lang/String;Ljava/lang/String;Landroid/media/MediaScannerClient;)V",
        (void *)android_media_MediaScanner_processFile
    },

    {
        "setLocale",
        "(Ljava/lang/String;)V",
        (void *)android_media_MediaScanner_setLocale
    },

    {
        "extractAlbumArt",
        "(Ljava/io/FileDescriptor;)[B",
        (void *)android_media_MediaScanner_extractAlbumArt
    },

    {
        "native_init",
        "()V",
        (void *)android_media_MediaScanner_native_init
    },

    {
        "native_setup",
        "()V",
        (void *)android_media_MediaScanner_native_setup
    },

    {
        "native_finalize",
        "()V",
        (void *)android_media_MediaScanner_native_finalize
    },
};
~~~

你看！！是不是直接定义好了！那既然定义好了，那是不是就要把JNI层这些函数的信息注册到java的虚拟机里面？是的，我们看看在哪个方法注册

~~~java

// This function only registers the native methods, and is called from
// JNI_OnLoad in android_media_MediaPlayer.cpp
int register_android_media_MediaScanner(JNIEnv *env)
{
    return AndroidRuntime::registerNativeMethods(env,
                kClassMediaScanner, gMethods, NELEM(gMethods));
}
~~~

可以看到调用了AndroidRuntime这个类的一个注册方法

~~~java

int register_com_android_internal_os_RuntimeInit(JNIEnv* env)
{
    return jniRegisterNativeMethods(env, "com/android/internal/os/RuntimeInit",
        gMethods, NELEM(gMethods));
}


~~~



jniRegisterNativeMethods 这个方法是安卓为了方便JNI使用的一个帮助函数，他在JNIHelp.h里面，但是我好像没有导入这个文件，找不到，但是没有关系，里面就是调用虚拟机提供的方法注册函数而已。

但是有个问题：register_android_media_MediaScanner这个方法什么时候去调用？怎么调用？一般来说我们对一些全局变量是在构造函数初始化的，但是这里是这样处理：在java层通过调用System.loadLibrary加载完JNI动态库后，会马上查找这个库中一个叫JNI_OnLoad的函数，如果有这个函数，就调用他，所以我们在使用动态注册时就需要实现这个函数，我们看看谷歌工程师是否实现了这个函数

~~~java
jint JNI_OnLoad(JavaVM* vm, void* /* reserved */)
{
    JNIEnv* env = NULL;
    jint result = -1;

    if (vm->GetEnv((void**) &env, JNI_VERSION_1_4) != JNI_OK) {
        ALOGE("ERROR: GetEnv failed\n");
        goto bail;
    }
    assert(env != NULL);

    if (register_android_media_ImageWriter(env) != JNI_OK) {
        ALOGE("ERROR: ImageWriter native registration failed");
        goto bail;
    }

    if (register_android_media_ImageReader(env) < 0) {
        ALOGE("ERROR: ImageReader native registration failed");
        goto bail;
    }

    if (register_android_media_MediaPlayer(env) < 0) {
        ALOGE("ERROR: MediaPlayer native registration failed\n");
        goto bail;
    }

    if (register_android_media_MediaRecorder(env) < 0) {
        ALOGE("ERROR: MediaRecorder native registration failed\n");
        goto bail;
    }

    if (register_android_media_MediaScanner(env) < 0) {
        ALOGE("ERROR: MediaScanner native registration failed\n");
        goto bail;
    }

    if (register_android_media_MediaMetadataRetriever(env) < 0) {
        ALOGE("ERROR: MediaMetadataRetriever native registration failed\n");
        goto bail;
    }

    if (register_android_media_AmrInputStream(env) < 0) {
        ALOGE("ERROR: AmrInputStream native registration failed\n");
        goto bail;
    }

    if (register_android_media_ResampleInputStream(env) < 0) {
        ALOGE("ERROR: ResampleInputStream native registration failed\n");
        goto bail;
    }

    if (register_android_media_MediaProfiles(env) < 0) {
        ALOGE("ERROR: MediaProfiles native registration failed");
        goto bail;
    }

    if (register_android_mtp_MtpDatabase(env) < 0) {
        ALOGE("ERROR: MtpDatabase native registration failed");
        goto bail;
    }

    if (register_android_mtp_MtpDevice(env) < 0) {
        ALOGE("ERROR: MtpDevice native registration failed");
        goto bail;
    }

    if (register_android_mtp_MtpServer(env) < 0) {
        ALOGE("ERROR: MtpServer native registration failed");
        goto bail;
    }

    if (register_android_media_MediaCodec(env) < 0) {
        ALOGE("ERROR: MediaCodec native registration failed");
        goto bail;
    }

    if (register_android_media_MediaSync(env) < 0) {
        ALOGE("ERROR: MediaSync native registration failed");
        goto bail;
    }

    if (register_android_media_MediaExtractor(env) < 0) {
        ALOGE("ERROR: MediaCodec native registration failed");
        goto bail;
    }

    if (register_android_media_MediaMuxer(env) < 0) {
        ALOGE("ERROR: MediaMuxer native registration failed");
        goto bail;
    }

    if (register_android_media_MediaCodecList(env) < 0) {
        ALOGE("ERROR: MediaCodec native registration failed");
        goto bail;
    }

    if (register_android_media_Crypto(env) < 0) {
        ALOGE("ERROR: MediaCodec native registration failed");
        goto bail;
    }

    if (register_android_media_Drm(env) < 0) {
        ALOGE("ERROR: MediaDrm native registration failed");
        goto bail;
    }

    if (register_android_media_MediaHTTPConnection(env) < 0) {
        ALOGE("ERROR: MediaHTTPConnection native registration failed");
        goto bail;
    }

    if (register_android_media_ExifInterface(env) < 0) {
        ALOGE("ERROR: ExifInterface native registration failed");
        goto bail;
    }

    /* success -- return valid version number */
    result = JNI_VERSION_1_4;

bail:
    return result;
}
~~~

是吧！！你可以看到很多都使用了动态的注册！！

我们总结一下动态注册的流程

+ 我们在java层写下native 方法，然后再写JNI层对应的动态库的c++类和对应函数
+ 然后在动态库里面，把每个c++类里面对应的java层的函数写在一个结构体数组中，并且写好该类的register_android*****函数
+ 然后在某个c文件写好JNI_OnLoad函数，在里面写好调用该库所有的register_android***方法，
+ 当我们在java层一调用System.loadLibrary加载完JNI动态库后，虚拟机会自动查找该库的JNI_OnLoad函数去调用，这样就完成了函数的关联

###　小结

其实注册就是如何如何让虚拟机知道java对应的c++函数是哪个。其实底层都是函数指针！！！所以只要有对应关系，java虚拟机就可以实现JNI层函数的调用！！

#　数据类型

虽然说java可以调用c++的函数了，但是他们的数据类型不匹配啊！！！所以就要进行转换成一个通用的数据类型。因为直接转成是不可能的，c++数据类型占用的内存和java是不一样的，那简单啊！！java比c++用的内存大，那在JNI层新创造一个JNI层对于java通用的数据类型就好了！！！而c++根本不担心！他直接操作这些通用类型的指针就好了！！所以主要的问题还是如何去JNI操作java数据类型和对象，以及转换成通用的数据类型。这里的转换关系表就自己去看书了。在p22。

# JNIEnv

前面讲了数据类型的转换，在JNI层创建了数据类型，但是C++和java都不认识他们啊！所以需要一个认识他们的工具来进行调和。他就是JNIEnv！！！你在上面的函数参数里面都能看到他的身影。他到底是何方神圣？其实他也是一个结构体，他提供了一堆JNI系统函数，通过这些函数，我们可以用c++调用java的函数，操作jni层的数据类型！！！



## 操作JNI对象



##　线程相关

他是一个线程相关的结构体，一个线程有对应的一个JNIEnv，线程A的JNIEnv不能在线程B使用。JNIEnv是在native函数转成JNI函数时虚拟机传进来的，你可以翻到最上面看看是不是！所以虚拟机是不会给错你JNIEnv的，但是！！有这样的一个问题，当我们遇到了异步操作，在java层我们在主线程想发起网络请求，但是这个网络请求是要native层发起，那是不是异步去调用java层的native函数？然后就会找到对应的c++函数去异步发起网络请求，这个时候是不是一个很漫长的过程？，当终于接收到了一个网络回复，你需要回调java层的代码，那你怎么去拿到java层对应主线程的JNIEnv？？？我们知道是在使用的java去调用c++才会有这个JNIEnv。而现在是c++去主动调用java！！他去哪里拿？你可能会想到在一开始c++被调用的时候保存下来不就好了！！这样是不行的！我们在主线程调用c++发起请求，c++创建一个线程发起，他们是不同的线程，JNIEnv就不能在c++创建的这个线程保存！那怎么办？找虚拟机啊！虚拟机提供了一个AtttachCurrentThread的方法让你去获取对应的java层线程！！虚拟机对象在哪里？？

~~~java

//第一个参数就是！！我们可以保存虚拟机对象！！！！
jint JNI_OnLoad(JavaVM* vm, void* /* reserved */)
{}
~~~

但是后台线程退出的时候，要记得释放资源！！！











































