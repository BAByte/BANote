# 简单谈谈Android中的接口隔离

JAVA反射的厉害，想必大家都十分清楚。Google作为一个API提供方，为用户也算操了点心，除了权限管理外，从设计上是怎么去隐藏危险API的? 下面我简单的yy一下。

隐藏的目的：

1.设计上：解耦。

2.安全上：防止流氓软件。

ps：本文所有观点皆猜想，你要做怎样的哈姆雷特，雨我无瓜。

# 普通应用与特权应用

在Android中，一些api如果是普通权限的应用或者是系统权限的应用(翻译过来叫特权应用)，在调用过程中是会被拦截的。

+ 其中一种实现没有什么实现难度：if判断一下uid。但效果不错。

+ 还有一种就是谷歌的权限管理。（这个东西我早晚会去看的），但是资本家的矛盾转移玩的很溜，大部分危险权限是让用户去决策的。而流氓软件也是吃死这套：不给权限不给用。

当然也不乏被反射破坏这个设计的例子：系统权限的应用是无法使用WebView的，但是依旧有使用反射去绕过这个权限的校验。具体操作可以去google看看。

# framework.jar和android.jar

我们平时开发，SDK中包含的是android.jar，默认移除所有被@hide标识的方法或者类。但在运行时加载的是framework.jar，具备完整的api。

破解这个十分简单，但是操作复杂，需要定义一个同名包和类，类里面的方法都是空实现就可以了。中心思想就是骗过编译器。当然有些系统开发者，需要自己导入framework.jar。

# 小结

结合上面两点，双管齐下，就给滥用系统API造了个不低的门槛，但是还不够高（我应该能拿个矛盾文学奖）。开发者一跳就跨过去了。

# 从进程来看

java进程之间隔离，大家知道。A程序无法直接访问B程序的类，大家也知道。所以基于这个听起来很简单，实际很复杂的道理，可以达到隔离，隐藏API的目的。下图是我们日常开发时调用系统API的过程：



![image](https://github.com/BAByte/pic/blob/master/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_a0e88f79-1918-4768-93f3-887b9d0d1950.png?raw=true)

我们从这幅图就可以很直观的看到XXXManager是XXXManagerService的对外AIDL接口。所以我们上层能使用的只有AIDL文件所提供的接口。

ps:这里直接说AIDL是因为：我在其他笔记中已经写Binder通信的够多了，我默认你懂这个东西哈。

# 小结

这里举例我们最常用到的ActivityManager：

如果没有ActivityManager提供接口，就没办法调用到ActivityManagerService的方法，这点能百分百隔离API。ActivityManager就是我们常说的中间件。从Binder通信来说，ActivityManager属于公司的前台客服。

但是如果不暴露接口，ActivityManagerService存在意义是什么？同时ActivityManagerService不只是为普通应用服务，还为系统特权应用服务，总会给出一些比较危险的API。

所以需要配合权限管理、应用角色差异化（系统应用和普通应用）、SDK（framework.jar和android.jar）实现一个相对安全的接口隔离。

谷歌工程师们看完惊呼：我没这么想过。

