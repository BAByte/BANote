[TOC]

# 7.linux多线程

在第六篇笔记里面就说过，我们先去学习一些安卓给开发者提供的工具类，这些常用类都是c++的，主要就是为了方便开发者使用linux的东西，本篇笔记就是学西多线程编程，在学习c++的时候就需要学习多线程有关的知识，奈何我没听课，c++多线程是基于操作系统来说的，我们用的是linux，安卓也是linux，所以肯定说的是linux提供的多线程API。所以说白了这笔记就是学习LInux多线程的API，并不会接触到多线程具体的实现。我们要使用 POSIX 编写多线程 C++ 程序。POSIX Threads 或 Pthreads 提供的 API ，可在多种类 Unix POSIX 系统上可用，比如 FreeBSD、NetBSD、GNU/Linux、Mac OS X 和 Solaris。

##　思考

我们想想，作为一个安卓软件开发人员，最熟悉的就是java，java不就有多线程编程吗，我们也学过？为什么要学习linux的多线程机制，首先，创建线程和进程肯定是操作系统级别的，在java里面，我们直接用java提供的API就好，jvm已经帮你映射了，平时开发主要就是处理好线程通信，异步加载等，对于单纯的开发c端来说并不难的。而对于native的代码来说是直接使用linux系统的多线程api来创建线程。作用呢？就是实现native层的多线程开发，我们现在还没接触到，但是接下来看的代码里面肯定会有不少。步入正题！



来源：

> <http://www.runoob.com/cplusplus/cpp-multithreading.html>

##　创建线程

~~~java
#include <pthread.h>
int pthread_create(pthread_t * tidp, const pthread_attr_t *attr, void *(*start_rtn)(void *), void *arg);
    // 返回：成功返回0，出错返回错误编号
~~~

看看参数

| 参数          | 描述                                                         |
| :------------ | :----------------------------------------------------------- |
| thread        | 指向线程标识符指针。                                         |
| attr          | 一个不透明的属性对象，可以被用来设置线程属性。您可以指定线程属性对象，也可以使用默认值 NULL。 |
| start_routine | 线程运行函数起始地址，一旦线程被创建就会执行。               |
| arg           | 运行函数的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。 |



## 终止线程

使用下面的程序，我们可以用它来终止一个 POSIX 线程：

```c++
#include <pthread.h>
pthread_exit (status) 
```

在这里，**pthread_exit** 用于显式地退出一个线程。通常情况下，pthread_exit() 函数是在线程完成工作后无需继续存在时被调用。

如果 main() 是在它所创建的线程之前结束，并通过 pthread_exit() 退出，那么其他线程将继续执行。否则，它们将在 main() 结束时自动被终止。但是他不会回收线程的所占用的资源

## 实例

这个实例演示了如何通过结构传递多个参数。您可以在线程回调中传递任意的数据类型，因为它指向 void，如下面的实例所示：

~~~c++
#include <iostream>
#include <cstdlib>
#include <pthread.h>
 
using namespace std;
 
#define NUM_THREADS     5
 
struct thread_data{
   int  thread_id;
   char *message;
};
 
void *PrintHello(void *threadarg)
{
   struct thread_data *my_data;
 
   my_data = (struct thread_data *) threadarg;
 
   cout << "Thread ID : " << my_data->thread_id ;
   cout << " Message : " << my_data->message << endl;
 
   pthread_exit(NULL);
}
 
int main ()
{
   pthread_t threads[NUM_THREADS];
   struct thread_data td[NUM_THREADS];
   int rc;
   int i;
 
   for( i=0; i < NUM_THREADS; i++ ){
      cout <<"main() : creating thread, " << i << endl;
      td[i].thread_id = i;
      td[i].message = (char*)"This is message";
      rc = pthread_create(&threads[i], NULL,
                          PrintHello, (void *)&td[i]);
      if (rc){
         cout << "Error:unable to create thread," << rc << endl;
         exit(-1);
      }
   }
   pthread_exit(NULL); //设置这个的原因是，如果直接return，进程会退出，所有属于该进程的线程都马上被回收，设置了后，主线程完成，主线程先退出，其他子进程继续执行
}
~~~



使用 -lpthread 库编译下面的程序：

```
$ g++ test.cpp -lpthread -o test.o
```

现在，执行程序，将产生下列结果：

```
$ g++ -Wno-write-strings test.cpp -lpthread -o test.o
$ ./test.o
main() : creating thread, 0
main() : creating thread, 1
Thread ID : 0 Message : This is message
main() : creating thread, Thread ID : 21
 Message : This is message
main() : creating thread, 3
Thread ID : 2 Message : This is message
main() : creating thread, 4
Thread ID : 3 Message : This is message
Thread ID : 4 Message : This is message
```

## 等待某个线程终止

上面的实例是在主线程最后调用pthread_exit(NULL);但是这个函数只是让线程结束，不会去回收资源，实现线程完成并且自动回收资源的的方法有两种：

+ pthread_join()

  ~~~c
  #include <pthread.h>
    // 返回：成功返回0，出错返回错误代码，thread是目标线程标识符，rval_ptr指向目标线程返回时的退出信息
  int pthread_join(pthread_t thread, void **rval_ptr);
   
  ~~~

  

  调用pthread_join的线程会阻塞，直到指定的线程返回，调用了pthread_exit，或者被取消。 

+  pthread_detach 

  ~~~c++
  #include <pthread.h>
  pthread_detach(thread_id);
  ~~~

  

  创建一个线程默认的状态是joinable, 如果一个线程结束运行但没有被join,则它的状态类似于进程中的Zombie Process,即还有一部分资源没有被回收（退出状态码），所以创建线程者应该调用pthread_join来等待线程运行结束，并可得到线程的退出代码，回收其资源（类似于wait,waitpid) 
  但是调用pthread_join(pthread_id)后，如果该线程没有运行结束，调用者会被阻塞，在有些情况下我们并不希望如此，比如在Web服务器中当主线程为每个新来的链接创建一个子线程进行处理的时候，主线程并不希望因为调用pthread_join而阻塞（因为还要继续处理之后到来的链接），这时可以在子线程中加入代码 
  pthread_detach(pthread_self()) 
  或者父线程调用 
  pthread_detach(thread_id)（非阻塞，可立即返回） 
  这将该子线程的状态设置为detached,则该线程运行结束后会自动释放所有资源。 

  

