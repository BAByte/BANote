[TOC]

# 7.linux多线程

在第六篇笔记里面就说过，我们先去学习一些安卓给开发者提供的工具类，这些常用类都是c++的，主要就是为了方便开发者使用linux的东西，本篇笔记就是学西多线程编程，在学习c++的时候就需要学习多线程有关的知识，奈何我没听课，c++多线程是基于操作系统来说的，我们用的是linux，安卓也是linux，所以肯定说的是linux提供的多线程API。所以说白了这笔记就是学习LInux多线程的API，并不会接触到多线程具体的实现。我们要使用 POSIX 编写多线程 C++ 程序。POSIX Threads 或 Pthreads 提供的 API ，可在多种类 Unix POSIX 系统上可用，比如 FreeBSD、NetBSD、GNU/Linux、Mac OS X 和 Solaris。

##　思考

我们想想，作为一个安卓软件开发人员，最熟悉的就是java，java不就有多线程编程吗，我们也学过？为什么要学习linux的多线程机制，首先，创建线程和进程肯定是操作系统级别的，在java里面，我们直接用java提供的API就好，jvm已经帮你映射了，平时开发主要就是处理好线程通信，异步加载等，对于单纯的开发c端来说并不难的。而对于native的代码来说是直接使用linux系统的多线程api来创建线程。作用呢？就是实现native层的多线程开发，我们现在还没接触到，但是接下来看的代码里面肯定会有不少。步入正题！



来源：

> <http://www.runoob.com/cplusplus/cpp-multithreading.html>

##　创建线程

~~~java
#include <pthread.h>
int pthread_create(pthread_t * tidp, const pthread_attr_t *attr, void *(*start_rtn)(void *), void *arg);
    // 返回：成功返回0，出错返回错误编号
~~~

看看参数

| 参数          | 描述                                                         |
| :------------ | :----------------------------------------------------------- |
| thread        | 指向线程标识符指针。                                         |
| attr          | 一个不透明的属性对象，可以被用来设置线程属性。您可以指定线程属性对象，也可以使用默认值 NULL。 |
| start_routine | 线程运行函数起始地址，一旦线程被创建就会执行。               |
| arg           | 运行函数的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。 |



## 终止线程

使用下面的程序，我们可以用它来终止一个 POSIX 线程：

```c++
#include <pthread.h>
pthread_exit (status) 
```

在这里，**pthread_exit** 用于显式地退出一个线程。通常情况下，pthread_exit() 函数是在线程完成工作后无需继续存在时被调用。

如果 main() 是在它所创建的线程之前结束，并通过 pthread_exit() 退出，那么其他线程将继续执行。否则，它们将在 main() 结束时自动被终止。但是他不会回收线程的所占用的资源

### 实例

这个实例演示了如何通过结构传递多个参数。您可以在线程回调中传递任意的数据类型，因为它指向 void，如下面的实例所示：

~~~c++
#include <iostream>
#include <cstdlib>
#include <pthread.h>
 
using namespace std;
 
#define NUM_THREADS     5
 
struct thread_data{
   int  thread_id;
   char *message;
};
 
void *PrintHello(void *threadarg)
{
   struct thread_data *my_data;
 
   my_data = (struct thread_data *) threadarg;
 
   cout << "Thread ID : " << my_data->thread_id ;
   cout << " Message : " << my_data->message << endl;
 
   pthread_exit(NULL);
}
 
int main ()
{
   pthread_t threads[NUM_THREADS];
   struct thread_data td[NUM_THREADS];
   int rc;
   int i;
 
   for( i=0; i < NUM_THREADS; i++ ){
      cout <<"main() : creating thread, " << i << endl;
      td[i].thread_id = i;
      td[i].message = (char*)"This is message";
      rc = pthread_create(&threads[i], NULL,
                          PrintHello, (void *)&td[i]);
      if (rc){
         cout << "Error:unable to create thread," << rc << endl;
         exit(-1);
      }
   }
   pthread_exit(NULL); //设置这个的原因是，如果直接return，进程会退出，所有属于该进程的线程都马上被回收，设置了后，主线程完成，主线程先退出，其他子进程继续执行
}
~~~



使用 -lpthread 库编译下面的程序：

```
$ g++ test.cpp -lpthread -o test.o
```

现在，执行程序，将产生下列结果：

```
$ g++ -Wno-write-strings test.cpp -lpthread -o test.o
$ ./test.o
main() : creating thread, 0
main() : creating thread, 1
Thread ID : 0 Message : This is message
main() : creating thread, Thread ID : 21
 Message : This is message
main() : creating thread, 3
Thread ID : 2 Message : This is message
main() : creating thread, 4
Thread ID : 3 Message : This is message
Thread ID : 4 Message : This is message
```

## 等待某个线程终止

上面的实例是在主线程最后调用pthread_exit(NULL);但是这个函数只是让线程结束，不会去回收资源，实现线程完成并且自动回收资源的的方法有两种：

+ pthread_join()

  ~~~c
  #include <pthread.h>
    // 返回：成功返回0，出错返回错误代码，thread是目标线程标识符，rval_ptr指向目标线程返回时的退出信息
  int pthread_join(pthread_t thread, void **rval_ptr);
   
  ~~~

  

  调用pthread_join的线程会阻塞，直到指定的线程返回，调用了pthread_exit，或者被取消。 

+  pthread_detach 

  ~~~c++
  #include <pthread.h>
  pthread_detach(thread_id);
  ~~~

  

  创建一个线程默认的状态是joinable, 如果一个线程结束运行但没有被join,则它的状态类似于进程中的Zombie Process,即还有一部分资源没有被回收（退出状态码），所以创建线程者应该调用pthread_join来等待线程运行结束，并可得到线程的退出代码，回收其资源（类似于wait,waitpid) 
  但是调用pthread_join(pthread_id)后，如果该线程没有运行结束，调用者会被阻塞，在有些情况下我们并不希望如此，比如在Web服务器中当主线程为每个新来的链接创建一个子线程进行处理的时候，主线程并不希望因为调用pthread_join而阻塞（因为还要继续处理之后到来的链接），这时可以在子线程中加入代码 
  pthread_detach(pthread_self()) 
  或者父线程调用 
  pthread_detach(thread_id)（非阻塞，可立即返回） 
  这将该子线程的状态设置为detached,则该线程运行结束后会自动释放所有资源。 

  

### 示例

  我们在主线程创建一个线程，然后让子线程睡眠５秒模拟耗时操作，我们希望主线程等待子线程完成后主线程在执行下一步操作：

  ~~~c
  #include <iostream>
  #include <cstdlib>
  #include <pthread.h>
  #include <unistd.h>
  #include <ctime>
   
  using namespace std;
   
  #define NUM_THREADS     1
   
  void *wait(void *t)
  {
     long tid;
   
     tid = *(long *)t;
  
     // 基于当前系统的当前日期/时间
     time_t now = time(0);
     // 把 now 转换为字符串形式
     char* dt = ctime(&now);
   
     cout <<"本地日期和时间：" << dt<<"---线程："<<tid<< "-开始睡眠:"<<tid<< endl;
    
     sleep(5);
     // 基于当前系统的当前日期/时间
     now = time(0);
     // 把 now 转换为字符串形式
     dt = ctime(&now);
   
     cout <<"本地日期和时间：" << dt<<"---线程："<< tid << "-睡眠完成" << endl;
     pthread_exit(NULL);
  
  }
   
  int main ()
  {
     int rc;
     int i;
     pthread_t threads[NUM_THREADS];
     pthread_attr_t attr;
     void *status;
   
     // 初始化并设置线程为可连接的（joinable），因为并不是所有POSIX创建线程都默认joinable的，用属性完后要马上解除,
     pthread_attr_init(&attr);
     pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
   
     for( i=0; i < NUM_THREADS; i++ ){
           rc = pthread_create(&threads[i], NULL, wait, (void *)&i );
        if (rc){
           cout << "Error:unable to create thread," << rc << endl;
           exit(-1);
        }
     }
  
     // 基于当前系统的当前日期/时间
     time_t now = time(0);
     // 把 now 转换为字符串形式
     char* dt = ctime(&now);
     cout <<"本地日期和时间：" << dt<<"---主线程创建进线程完成" << endl;
  	
     // 解除属性，使用完后要记得解除属性，但是不会影响前面设置好的属性，不解除会影响后面创建的线程
     pthread_attr_destroy(&attr);
  
     for( i=0; i < NUM_THREADS; i++ ){
   	// 基于当前系统的当前日期/时间
    	 time_t now2 = time(0);
     	// 把 now 转换为字符串形式
     	char* dt2 = ctime(&now);
  	cout <<"本地日期和时间：" << dt2<<"---Main:等待thread id ："<< i << rc << endl;
  	
  	//main等待其他线程执行完成
  	rc = pthread_join(threads[i], &status);
  
        if (rc){
           cout << "Error:unable to join," << rc << endl;
           exit(-1);
        }
     }
   
     // 基于当前系统的当前日期/时间
     now = time(0);
     // 把 now 转换为字符串形式
     dt = ctime(&now);
     cout <<"本地日期和时间：" << dt<< "---Main: 继续执行一些代码，然后退出." << endl;
     return 0;
  }
  ~~~

  结果：

  ~~~c
  本地日期和时间：Sat Mar 30 21:34:03 2019                                                                                              
  ---主线程创建进线程完成                                                                                                               
  本地日期和时间：Sat Mar 30 21:34:03 2019                                                                                              
  ---线程：1-开始睡眠:1                                                                                                                 
  本地日期和时间：Sat Mar 30 21:34:03 2019                                                                                              
  ---Main:等待thread id ：00                                                                                                            
  本地日期和时间：Sat Mar 30 21:34:08 2019                                                                                              
  ---线程：1-睡眠完成                                                                                                                   
  本地日期和时间：Sat Mar 30 21:34:08 2019                                                                                              
  ---Main: 继续执行一些代码，然后退出.
  ~~~

  可以看到主线程被阻塞了！而且当子线程结束后，他所占用的资源也被自动释放了。

### 实例

  但是很多时候是主线程肯定不能阻塞的，但是我们想让线程完成后自动回收资源

  ~~~c
  #include <iostream>
  #include <cstdlib>
  #include <pthread.h>
  #include <unistd.h>
  #include <ctime>
  
  using namespace std;
  
  #define NUM_THREADS     1
  
  void *wait(void *t)
  {
     //分离，让他结束自动回收资源
     pthread_detach(pthread_self());
     long tid;
  
     tid = *(long *)t;
  
     // 基于当前系统的当前日期/时间
     time_t now = time(0);
     // 把 now 转换为字符串形式
     char* dt = ctime(&now);
  
     cout <<"本地日期和时间：" << dt<<"---线程："<<tid<< "-开始睡眠:"<<tid<< endl;
  
     sleep(5);
     // 基于当前系统的当前日期/时间
     now = time(0);
     // 把 now 转换为字符串形式
     dt = ctime(&now);
  
     cout <<"本地日期和时间：" << dt<<"---线程："<< tid << "-睡眠完成" << endl;
    // pthread_exit(NULL);
  
  }
  
  int main ()
  {
     int rc;
     int i;
     pthread_t threads[NUM_THREADS];
     pthread_attr_t attr;
     void *status;
  
     // 初始化并设置线程为可连接的（joinable），因为并不是所有POSIX创建线程都默认joinable的，用属性完后要马上解除,
     pthread_attr_init(&attr);
     pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
  
     for( i=0; i < NUM_THREADS; i++ ){
           rc = pthread_create(&threads[i], NULL, wait, (void *)&i );
        if (rc){
           cout << "Error:unable to create thread," << rc << endl;
           exit(-1);
        }
     }
  
     // 基于当前系统的当前日期/时间
     time_t now = time(0);
     // 把 now 转换为字符串形式
     char* dt = ctime(&now);
     cout <<"本地日期和时间：" << dt<<"---主线程创建进线程完成" << endl;
  
     // 解除属性，使用完后要记得解除属性，但是不会影响前面设置好的属性，不解除会影响后面创建的线程
     pthread_attr_destroy(&attr);
  
  
     // 基于当前系统的当前日期/时间
     now = time(0);
     // 把 now 转换为字符串形式
     dt = ctime(&now);
     cout <<"本地日期和时间：" << dt<< "---Main: 继续执行一些代码，然后退出." << endl;
     return 0;
  }
  ~~~

  

  结果：

  ~~~c
  本地日期和时间：Sat Mar 30 22:19:35 2019
  ---主线程创建进线程完成
  本地日期和时间：Sat Mar 30 22:19:35 2019
  ---线程：1-开始睡眠:1
  本地日期和时间：Sat Mar 30 22:19:35 2019
  ---Main: 继续执行一些代码，然后退出.
  ~~~

---

  

  ## 互斥量

  　　互斥量本质是一把锁，在访问公共资源前对互斥量设置（加锁），确保同一时间只有一个线程访问数据，在访问完成后再释放（解锁）互斥量。在互斥量加锁之后，其他线程试图对该互斥量再次加锁时都会被阻塞，知道当前线程释放互斥锁。如果释放互斥量时有一个以上的互斥量，那么所有在该互斥量上阻塞的线程都会变成可运行状态，第一个变成运行的线程可以对互斥量加锁，其他线程看到互斥量依然是锁着的，只能再次阻塞等待该互斥量。

  ​	互斥量用pthread_mutex_t数据类型表示，在使用互斥量之前，必须使用pthread_mutex_init函数对它进行初始化，注意，使用完毕后需调用pthread_mutex_destroy。

  ~~~c
  #include <pthread.h>
  int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);
  int pthread_mutex_destroy(pthread_mutex_t *mutex);
      // 两个函数返回值，成功返回0，否则返回错误码
  ~~~

  pthread_mutex_init用于初始化互斥锁，mutexattr用于指定互斥锁的属性，若为NULL，则表示默认属性。除了用这个函数初始化互斥所外，还可以用如下方式初始化：pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER。
  　　pthread_mutex_destroy用于销毁互斥锁，以释放占用的内核资源，销毁一个已经加锁的互斥锁将导致不可预期的后果。

  ~~~c
  #include <pthread.h>
  int pthread_mutex_lock(pthread_mutex_t *mutex);
  int pthread_mutex_trylock(pthread_mutex_t *mutex);
  int pthread_mutex_unlock(pthread_mutex_t *mutex);
      // 成功返回0，否则返回错误码
  ~~~

  　pthread_mutex_lock以原子操作给一个互斥锁加锁。如果目标互斥锁已经被加锁，则pthread_mutex_lock则被阻塞，直到该互斥锁占有者把它给解锁。
  　　pthread_mutex_trylock和pthread_mutex_lock类似，不过它始终立即返回，而不论被操作的互斥锁是否加锁，是pthread_mutex_lock的非阻塞版本。当目标互斥锁未被加锁时，pthread_mutex_trylock进行加锁操作；否则将返回EBUSY错误码。注意：这里讨论的pthread_mutex_lock和pthread_mutex_trylock是针对普通锁而言的，对于其他类型的锁，这两个加锁函数会有不同的行为。
  　　pthread_mutex_unlock以原子操作方式给一个互斥锁进行解锁操作。如果此时有其他线程正在等待这个互斥锁，则这些线程中的一个将获得它。

  ~~~c
  #include <iostream>
  #include <cstdlib>
  #include <pthread.h>
  #include <unistd.h>
  #include <ctime>
  #include <string.h>
  
  using namespace std;
   
  pthread_mutex_t g_mutex;
  int g_cnt = 0;
  
  void *func(void *arg)
  {
      int loop = 3;
      long result =(long)arg;
  
      while (loop > 0) {
          if (g_cnt % 3 == result) {
              switch (result)
              {
                  case 0: {
                      cout <<pthread_self()<<"--- a\n"<<endl;
                      break;
                  }
                  case 1: {
                      cout <<pthread_self()<<"--- b\n"<<endl;
                      break;
                  }
                  case 2: {
                      cout <<pthread_self()<<"--- c\n"<<endl;
                      break;
                  }
                  default: {
                      return NULL;
                  }
              }
  
              pthread_mutex_lock(&g_mutex);
              g_cnt++;
              loop--;
              pthread_mutex_unlock(&g_mutex);
          }
      }
  
      return NULL;
  }
  
  int main(int argc, char * *argv)
  {
      pthread_t t1, t2, t3;
  
      //设置互斥量，设置为默认属性
      pthread_mutex_init(&g_mutex, NULL);
  
      pthread_create(&t1, NULL, func, (void *)0);
      pthread_create(&t2, NULL, func, (void *)1);
      pthread_create(&t3, NULL, func, (void *)2);
  
      pthread_join(t1, NULL);
      pthread_join(t2, NULL);
      pthread_join(t3, NULL);
  
      return 0;
  }
  ~~~

  结果：

  ~~~c
  140352635881216--- a
  
  140352627488512--- b
  
  140352619095808--- c
  
  140352635881216--- a
  
  140352627488512--- b
  
  140352619095808--- c
  
  140352635881216--- a
  
  140352627488512--- b
  
  140352619095808--- c
  ~~~

