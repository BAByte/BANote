[TOC]

# 9. 深入理解Binder

首先要说清楚的是，本次学习的是native层的Binder，而不是java层的，后面会再讲java层的，所以下面讲到的进程通信都是native之间的进程进行通信，而不是java层的。

# Binder通信的实现原理

每个进程在运行时系统都会把各个进程隔离，每个进程都会被分到一块内存，以便用来运行程序。在linux上，不同的进程可能会运行在不同的空间中：有的进程在内核空间，有的在用户空间。那Binder跨进程通信是如何实现的呢？就是通过Binder驱动实现的，而这个Binder驱动运行在内核空间，每个进程只需要向该驱动打开设备，并且映射内存就可以实现共享一部分文件进行数据的交互，并且通过ioctl方式与内核进行交互。

Binder的架构是属于c/s架构，所以会有客户端去找服务端的过程，这就类似于打电话：

在很久以前，打电话是这样的：

~~~java
+ 你打电话给服务中心，请帮我联系一下A。
+ 服务中心就帮你接通了A
+ 然后你和A就能愉快的通话了。
~~~

对应基于Binder的进程通讯这是不是这样呢：

~~~java
+ 某个客户端打电话给Binder，请帮我联系一下A服务端。
+ Binder就帮你接通了A
+ 然后你和A就能愉快的通话了。
~~~

是这样吧？这里服务中心是指的是binder，你仔细想想，他负责了帮客户端去找到服务端，然后还要为他们提供”通话服务“！！任务会不会重了一点？

那现代的打电话过程是怎样的呢？

~~~java
+ 你查找通讯录，然后拨通了A的电话号码
+ 服务中心为你接通A
+ 你和A愉快通讯
~~~

你一看，嗯？多了个查找通讯录的过程，你知道这个号码对应的是A，服务中心也知道他是A，所以问题出来了，这个服务中心在这里到底是不是BInder？其实不是，按照上面的例子来说，你可能觉得这个服务中心是BInder，但是你想想，在现实生活中，你是怎么拿到A的手机号码的？A告诉你的呀！是你认识A，所以会有A的号码，但是在开发中不是这样的，某个客户端只是说：我要能处理多媒体信息的服务端！！就像现实中找某个公司

我从这个通讯录开始吧！但是我们不知道这个通讯录在哪里啊，但是我们很容易找到服务！那服务端肯定要联系这个通讯录吧！所以我们接下来的目标就是;

~~~java
+ 找一个native服务
+ 找到这个nativie注册binder的过程
+ 揪出我们说的“总管”
~~~



# MediaService

首先要先明白这是个native的服务，而不是我们平时开发所用到的service，他是和zygote是一个类型的，都是main类型的服务。负责为安卓搞定linux的多媒体的东西。我们看看他是什么时候会启动

~~~java
service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server
    class main
    socket zygote stream 660 root system
    onrestart write /sys/android_power/request_state wake
    onrestart write /sys/power/state on
    onrestart restart audioserver
    onrestart restart cameraserver
    onrestart restart media //就是这个！！在zygote启动的时候会去重新启动。
    onrestart restart netd
    writepid /dev/cpuset/foreground/tasks

~~~

你可能会疑惑，前面不是说zygote留了个socket吗？这不就是可以进程通信？但是需要注意的是，我们说的是他是留给他的 “子孙后代” 联系他的，从上面可以看出来MediaSercive是