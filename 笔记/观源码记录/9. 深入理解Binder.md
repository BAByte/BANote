[TOC]

# 9. 深入理解Binder

首先要说清楚的是，本次学习的是native层的Binder，而不是java层的，后面会再讲java层的，所以下面讲到的进程通信都是native之间的进程进行通信，而不是java层的。

# Binder通信的实现原理

每个进程在运行时系统都会把各个进程隔离，每个进程都会被分到一块内存，以便用来运行程序。在linux上，不同的进程可能会运行在不同的空间中：有的进程在内核空间，有的在用户空间。那Binder跨进程通信是如何实现的呢？就是通过Binder驱动实现的，而这个Binder驱动运行在内核空间，每个进程只需要向该驱动打开设备，并且映射内存就可以实现共享一部分文件进行数据的交互，并且通过ioctl方式与内核进行交互。BInder驱动就作为一个中间者进行两个进程之间的传话者。

Binder的架构是属于c/s架构，所以会有客户端去找服务端的过程，这就类似于打电话：

在很久以前，打电话是这样的：

~~~java
+ 你打电话给服务中心，请帮我联系一下A。
+ 服务中心就帮你接通了A
+ 然后你和A就能愉快的通话了。
~~~

对应基于Binder的进程通讯这是不是这样呢：

~~~java
+ 某个客户端打电话给Binder，请帮我联系一下A服务端。
+ Binder就帮你接通了A
+ 然后你和A就能愉快的通话了。
~~~

是这样吧？这里服务中心是指的是binder，你仔细想想，他负责了帮客户端去找到服务端，然后还要为他们提供”通话服务“！！任务会不会重了一点？

那现代的打电话过程是怎样的呢？

~~~java
+ 你查找通讯录，然后拨通了A的电话号码
+ 服务中心为你接通A
+ 你和A愉快通讯
~~~

你一看，嗯？多了个查找通讯录的过程，你知道这个号码对应的是A，服务中心看你拨打的电话后也知道他是A，就帮你接通了。基于Binder通信是这样的

~~~java
+ 某个客户端要找A服务端
+ 向通讯录通信！我要A服务端
+ 通讯录给你了A服务的代理对象
+ 你和A服务端通过服务中心提供的通信功能在愉快的聊天
~~~

所以说后面这种才是符合现实生活中的逻辑！BInder只负责通信，他才不负责帮你查找别的服务端！所以说负责查找的功能是由这个通讯录实现的吧！所以每一个服务端都要向这个通讯录进行注册吧？那是不是要找到一个服务端，然后查看他是怎么去向通讯录注册的？

# MediaServer

首先要先明白这是个native的服务端，而不是我们平时开发所用到的service，他是和zygote是一个类型的，都是main类型的服务。负责为安卓搞定linux的多媒体的东西。我们看看他是什么时候会启动

~~~java
service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server
    class main
    socket zygote stream 660 root system
    onrestart write /sys/android_power/request_state wake
    onrestart write /sys/power/state on
    onrestart restart audioserver
    onrestart restart cameraserver
    onrestart restart media //就是这个！！在zygote启动的时候会去重新启动。
    onrestart restart netd
    writepid /dev/cpuset/foreground/tasks

~~~

你可能会疑惑，前面不是说zygote留了个socket吗？这不就是可以进程通信？但是需要注意的是，我们说的是他是留给他的 “子孙后代” 联系他的，从上面可以看出来MediaSercive是和zygote进程是同一个级别的哦！！所以这个Media进程和zygote进程进行通信是跨进程的，他们使用的是Binder！所以我们没有找错。

在此之前，我们再想一个问题：这个所谓向的通讯录注册的过程，是不是也是需要进程通信呢？是的！！！所以我们在找服务端向这个通信录注册的过程就会讲BInder通信，前面只是在给你介绍Binder架构的一小部分！

看看这个服务端的初始化过程吧！

~~~java
//media/ba/sd/aosp/frameworks/av/media/mediaserver/main_mediaserver.cpp


int main(int argc __unused, char **argv __unused)
{
    signal(SIGPIPE, SIG_IGN);

    //这个ProcessState可是非常的重要，等下会讲
    sp<ProcessState> proc(ProcessState::self());
    //获取了一个IServiceManager，这里就是去向通讯录注册！！！
    sp<IServiceManager> sm(defaultServiceManager());
    ALOGI("ServiceManager: %p", sm.get());
    InitializeIcuOrDie();
    
    //初始化多媒体服务
    MediaPlayerService::instantiate();
    ResourceManagerService::instantiate();
    registerExtensions();
    
   	//这两个方法我们放在最后面分析
    ProcessState::self()->startThreadPool();
    IPCThreadState::self()->joinThreadPool();
}
~~~

每一个进程都有一个ProcessState，他负责保存这个进程的信息，和进行一些初始化操作，所以应该是一开始就创建他。在上面的代码中可以看到注册成功后拿到的是IServiceManager对象，但是我们一直说的通讯录其实就是ServiceManager！

为什么是IServiceManager而不是ServiceManager呢？这就涉及到Binder通信的过程了，客户端和服务端通信的过程中，两个进程都不会拿到对方的真正实例，而是一个代理接口对象，里面只有具体实现的函数，但是函数都没有具体的实现，所以从这里我们可以推测出BInder的通信过程：



+ 客户端 class A 里面定义了一堆方法，然后又定义了一个interface IA，里面也定义了相同的方法，比如

~~~c

class A{
	public void method1(){
		//省略一堆代码
	}
	public void method2(){
		//省略一堆代码
	}
}

Interface IA{
	public void method1(){}
	public void method2(){}
}

~~~

+ 然后服务端也是定义了一个代理类，在这里，服务端是serviceManager。
+ 然后客户端向serviceManager注册，这里会涉及到进程通信
+ 客户端向Binder驱动说老子要找ServiceManager进行注册！BInder驱动会返回一个IServiceManager对象
+ 客户端拿到这个对象，调用方法，注意！这里调用的是空方法，但是！BInder驱动知道你要调用的是ServiceManager的哪个方法，会帮你去调用serviceManager的方法，然后把结果返回给你！！(这个过程其实非常的复杂，但是简单的说就是这样）所以说，客户端并没有真正的去操作到serviceManager，而是Binder驱动去帮他操作的

可以看到我们的MediaServer很快就使用BInder驱动，使用驱动我们都知道需要去驱动打开设备，那在哪呢？这个操作也是需要进程一被初始化就进行的，所以应该是在ProcessState初始化的时候，看看代码就知道了

~~~c
//media/ba/sd/aosp/frameworks/native/libs/binder/ProcessState.cpp
ProcessState::ProcessState()
    : mDriverFD(open_driver()) //哦！在这里，就去打开了Binder设备
    , mVMStart(MAP_FAILED) 
    , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER)
    , mThreadCountDecrement(PTHREAD_COND_INITIALIZER)
    , mExecutingThreadsCount(0)
    , mMaxThreads(DEFAULT_MAX_BINDER_THREADS)
    , mStarvationStartTimeMs(0)
    , mManagesContexts(false)
    , mBinderContextCheckFunc(NULL)
    , mBinderContextUserData(NULL)
    , mThreadPoolStarted(false)
    , mThreadPoolSeq(1)
{
    if (mDriverFD >= 0) {
        // mmap the binder, providing a chunk of virtual address space to receive transactions.mmap操作提供了一种机制，让用户程序直接访问设备内存，这种机制，相比较在用户空间和内核空间互相拷贝数据，效率更高。这里就是前面说的每个进程其实都是和驱动共享了一部分内存，这样这些进程和驱动的数据交互会变得快速和方便，这其实是一个很重要的方法
        mVMStart = mmap(0, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0);
        if (mVMStart == MAP_FAILED) {
            // *sigh*
            ALOGE("Using /dev/binder failed: unable to mmap transaction memory.\n");
            close(mDriverFD);
            mDriverFD = -1;
        }
    }

    LOG_ALWAYS_FATAL_IF(mDriverFD < 0, "Binder driver could not be opened.  Terminating.");
}


static int open_driver()
{
    //很熟悉的代码吧！打开后还进行了一些配置
    int fd = open("/dev/binder", O_RDWR | O_CLOEXEC);
    if (fd >= 0) {
        int vers = 0;
        status_t result = ioctl(fd, BINDER_VERSION, &vers);
        if (result == -1) {
            ALOGE("Binder ioctl to obtain version failed: %s", strerror(errno));
            close(fd);
            fd = -1;
        }
        if (result != 0 || vers != BINDER_CURRENT_PROTOCOL_VERSION) {
            ALOGE("Binder driver protocol does not match user space protocol!");
            close(fd);
            fd = -1;
        }
        //设置了fd支持的最大线程数是15
        size_t maxThreads = DEFAULT_MAX_BINDER_THREADS;
        result = ioctl(fd, BINDER_SET_MAX_THREADS, &maxThreads);
        if (result == -1) {
            ALOGE("Binder ioctl to set max threads failed: %s", strerror(errno));
        }
    } else {
        ALOGW("Opening '/dev/binder' failed: %s\n", strerror(errno));
    }
    return fd;
}
~~~

现在我们知道了该进程在接下来和其他进程的通信都是经过BInder驱动！而且和驱动还共享了一部分内存用于数据交换。上面我们说了客户端拿到了IServiceManager的对象后，调用他的方法进行通信，但是其实是BInder驱动去帮你调用，然后返回结果的，那这些调用过程的数据是怎么传输的呢？就是通过共享的fd！！！客户端把数据放进去，然后告诉Binder驱动，Binder驱动去取，然后做对应的操作！！

但是还有一个疑问，Binder是怎么知道我们要调用的是ServiceManager服务端？我们继续看下去

~~~c
//media/ba/sd/aosp/frameworks/av/media/mediaserver/main_mediaserver.cpp


int main(int argc __unused, char **argv __unused)
{
    signal(SIGPIPE, SIG_IGN);

    //这个ProcessState可是非常的重要，等下会讲
    sp<ProcessState> proc(ProcessState::self());
    //获取了一个IServiceManager，这里就是去向通讯录注册！！！我们下面仔细分析这个defaultServiceManager（）
    sp<IServiceManager> sm(defaultServiceManager());
   ...
}



~~~

~~~c
//media/ba/sd/aosp/frameworks/native/libs/binder/IServiceManager.cpp
sp<IServiceManager> defaultServiceManager()
{
    if (gDefaultServiceManager != NULL) return gDefaultServiceManager;

    {
        AutoMutex _l(gDefaultServiceManagerLock);
        while (gDefaultServiceManager == NULL) {
            gDefaultServiceManager = interface_cast<IServiceManager>(
                ProcessState::self()->getContextObject(NULL));
            if (gDefaultServiceManager == NULL)
                sleep(1);
        }
    }

    return gDefaultServiceManager;
}
~~~





