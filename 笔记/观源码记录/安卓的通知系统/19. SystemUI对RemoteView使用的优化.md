# 19. SystemUI对RemoteView使用的优化

我现在已经知道了安卓N之后和安卓N之前的RemoteView在SystemUI中是怎么使用的，但是不知道为什么要这样使用。

安卓N之前在客户端每一次构建通知都会构建RemoteView，但是在安卓N之后，remoteView的构建工作变成了SystemUI负责。这一种延时加载的方案就像懒汉式工厂模式一样，但是我还看到了谷歌工程师好像是做了一个RemoteView的缓存操作！然后根据缓存的RemoteView指判断通知内容是否一样，然后是否要去更新UI。

因为我自己做的时候是直接对通知进行排重，然后进行刷新的，所以我先知道SystemUI是怎样进行通知的排重的。

# RemoteView的缓存机制

假设客户端的目标版本是安卓7.0以上，且没有自定义RemoteView的情况下：

## 第一次发通知：

+ app：Notification  ：   没有remoteView
+ NotificationManagerService：StatusBarNotification    ：    没有remoteView
+ BaseStatusUI：NotificationData   ：判断有没有remoteView，没有就生成一个

但是生成和判断有没有缓存都是使用同一个方法,整体的步骤如下：

~~~java
//Android/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/NotificationData.java
public boolean cacheContentViews(Context ctx, Notification updatedNotification) {
    boolean applyInPlace = false;
  //如果不等于Null说明已经有缓存了
    if (updatedNotification != null) {
      //接下来就是去判断缓存中的remoteView是否和新来的一样
        final Notification.Builder updatedNotificationBuilder
                = Notification.Builder.recoverBuilder(ctx, updatedNotification);
      //这里是给新来的RemoteView进行数据的绑定
   final RemoteViews newContentView = updatedNotificationBuilder.createContentView();
         ...

         ...
   boolean sameCustomView = Objects.equals(
            notification.getNotification().extras.getBoolean(
                    Notification.EXTRA_CONTAINS_CUSTOM_VIEW),
            updatedNotification.extras.getBoolean(
                    Notification.EXTRA_CONTAINS_CUSTOM_VIEW));
    applyInPlace = compareRemoteViews(cachedContentView, newContentView)
      && sameCustomView;
 
      //不管怎样都把新来的进行缓存
      cachedContentView = newContentView;
      
    //如果不存在就新建一个
    } else {
      final Notification.Builder builder
        = Notification.Builder.recoverBuilder(ctx, notification.getNotification());
      cachedContentView = builder.createContentView();
      cachedBigContentView = builder.createBigContentView();
      cachedHeadsUpContentView = builder.createHeadsUpContentView();
      cachedPublicContentView = builder.makePublicContentView();
      applyInPlace = false;
    }
  return applyInPlace;
  
~~~

当applyInPlace的值为false时就需要去添加新的通知，当applyInPlace为true，代表是需要刷新，我们看看是怎么去比较的

~~~java
  // Returns true if the RemoteViews are the same.
  private boolean compareRemoteViews(final RemoteViews a, final RemoteViews b) {
      return (a == null && b == null) ||
              (a != null && b != null
              && b.getPackage() != null
              && a.getPackage() != null
              && a.getPackage().equals(b.getPackage())
              && a.getLayoutId() == b.getLayoutId());
  }
~~~

我是使用key比较的，我们看看是怎么生成key的

