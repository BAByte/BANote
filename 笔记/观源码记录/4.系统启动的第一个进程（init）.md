[TOC]

# 4.系统启动的第一个进程（init）

init是一个进程，他的进程号为1，厉害吧！！书上说他是天字第一号进程！！但是当我开始看下去的时候我就懵逼了，init和zygote到底有什么关系？？？分别是什么？属性服务又是什么？假设一开始不知道这些概念，直接看书，真的是一脸懵逼的！所以我决定在笔记的开篇先来吹吹这三者的关系。

init进程是启动的第一个进程，init主要负责创建系统需要的几个关键进程，zygote就是他的子进程。

zygote进程负责什么呢？安卓是由两个不同的世界组成的：

+ java
+ c++或者c

zygote就是java世界的开创者，这样一说你大概就猜到java虚拟机是跑在哪里了，当然这些只是后话。后面再分析。

所以说init进程就是负责linux系统的启动：

+ 挂载硬件设备
+ 解析系统的配置文件和硬件平台相关的配置文件
+ 初始化系统属性服务
+ 进入无限循环，等待事件发生

那init进程就是先创建了个linux的系统环境，然后去创建安卓的系统环境。在上面的哪一步开始创建zygote进程进而开创属于安卓的java世界呢？在解析系统的配置文件这一步，这个配置文件里面有实现具体创建安卓系统的各种进程和服务的操作，我们再后面分析。

属性服务是啥？在windows系统中有个叫注册表的东西，这个注册表存的是类似键值对这样的东西，系统或者某些应用程序会把自己的一些属性，存储在系统注册表中，当系统重启或者程序重启，他就可以根据注册表来恢复这些属性。你可能会怀疑，这种配置文件不就放在存储设备上吗，为什么要搞个注册表这样的东西，我们看看windows的解释

> 注册表是[windows操作系统](https://baike.baidu.com/item/windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)中的一个核心数据库，其中存放着各种参数，直接控制着[**windows**](https://baike.baidu.com/item/windows)的启动、硬件[驱动程序](https://baike.baidu.com/item/%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F)的[装载](https://baike.baidu.com/item/%E8%A3%85%E8%BD%BD)以及一些windows应用程序的运行，从而在整个系统中起着核心作用。这些作用包括了软、硬件的相关配置和状态信息，比如注册表中保存有应用程序和资源管理器外壳的初始条件、首选项和卸载数据等，联网计算机的整个系统的设置和各种许可，文件扩展名与应用程序的关联，硬件部件的描述、状态和属性，性能记录和其他底层的系统状态信息，以及其他数据等。
>
> 具体来说，在启动Windows时，Registry会对照已有硬件配置数据，检测新的硬件信息；系统内核从Registry中选取信息，包括要装入什么设备驱动程序，以及依什么次序装入，内核传送回它自身的信息，例如版权号等；同时设备驱动程序也向Registry传送数据，并从Registry接收装入和配置参数，一个好的设备驱动程序会告诉Registry它在使用什么系统资源，例如硬件中断或DMA通道等，另外，设备驱动程序还要报告所发现的配置数据；为应用程序或硬件的运行提供增加新的配置数据的服务。

现在应该明白了吧？这些属性是系统需要用的，而不是你应用程序自己要用的。比如说你去办身份证，在办理身份证的这个过程，你的资料是给相关机构登记使用的，这个机构也记录了很多人的身份信息。他们找你，或者查你的适合需要用到这些信息。属性服务大概就是这么个意思。

现在我们就要正式进入init进程的启动了！看看下图吧

![image](https://img-blog.csdn.net/2018041401483899?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N4ajE1OTc1Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

# init进程

任何程序肯定是先在一个类文件实现一个main方法，从这个main方法启动的（你会怀疑，为什么在写安卓应用的时候没有main方法？如果你有这个疑问，只能说是你自己没有理解四大组件的生命周期），那我们肯定要找到init进程的类文件，以及的他main方法！

该文件在：

~~~
system/core/init/init.cpp
~~~

部分代码

~~~c
int main(int argc, char** argv) {
   ...

    // Get the basic filesystem setup we need put together in the initramdisk
    // on / and then we'll let the rc file figure out the rest.
    //这里就是开始挂载文件，创建一些文件夹，这是linux启动相关的，可以不深入
    if (is_first_stage) {
        mount("tmpfs", "/dev", "tmpfs", MS_NOSUID, "mode=0755");
        mkdir("/dev/pts", 0755);
        mkdir("/dev/socket", 0755);
        mount("devpts", "/dev/pts", "devpts", 0, NULL);
        #define MAKE_STR(x) __STRING(x)
        mount("proc", "/proc", "proc", 0, "hidepid=2,gid=" MAKE_STR(AID_READPROC));
        mount("sysfs", "/sys", "sysfs", 0, NULL);
    }

    // We must have some place other than / to create the device nodes for
    // kmsg and null, otherwise we won't be able to remount / read-only
    // later on. Now that tmpfs is mounted on /dev, we can actually talk
    // to the outside world.这里是定向日志输出设备为kmsg，当这个文件一旦被打开其他进程就无法访问该设备，就是说，这是init进程自己的日志输入目录，你们谁都不能碰
    open_devnull_stdio();
    klog_init();
    klog_set_level(KLOG_NOTICE_LEVEL);

  

    /* Set up SELinux, including loading the SELinux policy if we're in the kernel domain.
    设置SELinux policy策略,Android 使用 SELinux 对所有进程强制执行强制访问控制 (MAC)，其中包括以 Root/超级用户权限运行的进程（也称为 Linux 功能）。SELinux 能够限制特权进程并能够自动创建安全政策，从而可提升 Android 的安全性。
关于SELinux 中有详细的介绍。(https://source.android.com/security/selinux/)。需要翻墙。*/
    selinux_initialize(is_first_stage);
    
    /*创建epoll句柄,epoll仅仅是一个异步事件的通知机制，其本身并不作任何的IO读写操作，它只负责告诉你是不是可以读或可以写了，而具体的读写操作，还要应用程序自己来完成。
该函数生成一个epoll专用的文件描述符。它其实是在内核申请一空间，用来存放你想关注的fd上是否发生的事件。size就是你在这个epoll fd上能关注的最大fd数，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值。需要注意的是，当创建好epoll句柄后，它就会占用一个fd值，在Linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。*/

     epoll_fd = epoll_create1(EPOLL_CLOEXEC);
    if (epoll_fd == -1) {
        ERROR("epoll_create1 failed: %s\n", strerror(errno));
        exit(1);
    }
    ...
    
    if (!is_first_stage) {
        // Indicate that booting is in progress to background fw loaders, etc.
        close(open("/dev/.booting", O_WRONLY | O_CREAT | O_CLOEXEC, 0000));

        //初始化属性服务
        property_init();

    ...
    }
    ...

    //对子进程设置退出信号函数，假设退出的进程是zygote，该函数内部会找到Zygote进程并且移除所有zygote进程的信息，然后重启该进程，为什么要这么做呢？因为在Linux中，父进程调用fork创建子进程后，子进程突然终止了，但是父进程不知道，所有父进程的进程表还是会保留着这个子进程的一些信息，而系统进程表是有限资源，如果进程被耗尽，就无法去创建新的进程。
    signal_handler_init();

    //导入默认的环境变量
    property_load_boot_defaults();
    export_oem_lock_status();
    
    //启动属性服务,创建了socket套接字，然后监听，并且调用register_epoll_handler函数把socket的fd放入了epoll中。
    start_property_service();


    //获取解析器，添加解析类型，这里等下后面会讲为什么要给这个解析器设置这些sectionParser
    Parser& parser = Parser::GetInstance();
    parser.AddSectionParser("service",std::make_unique<ServiceParser>());
    parser.AddSectionParser("on", std::make_unique<ActionParser>());
    parser.AddSectionParser("import", std::make_unique<ImportParser>());
    
    //用解析器解析配置文件,在解析完配置文件后会获得一系列的action（具体把获取action放在哪里我现在也不清楚，等下我们分析配置文件的时候应该会知道）
    parser.ParseConfig("/init.rc");

    //在安卓不知道几开始，使用把action交给了这个ActionManager管理
    ActionManager& am = ActionManager::GetInstance();

    //init将action执行分为4个阶段：early-init，init，early-boot，boot
    am.QueueEventTrigger("early-init");

    //接下来就是，把一堆action以及action携带的command对应的执行函数名传进去当成一个事件，去启动
    am.QueueBuiltinAction(keychord_init_action, "keychord_init");
    ...

    
    // Trigger all the boot actions to get us started.
    am.QueueEventTrigger("init");

    // Repeat mix_hwrng_into_linux_rng in case /dev/hw_random or /dev/random
    // wasn't ready immediately after wait_for_coldboot_done
    am.QueueBuiltinAction(mix_hwrng_into_linux_rng_action, "mix_hwrng_into_linux_rng");

    // Don't mount filesystems or start core system services in charger mode.
    std::string bootmode = property_get("ro.bootmode");
    if (bootmode == "charger") {
        am.QueueEventTrigger("charger");
    } else {
        //在书上写的后两个init过程。我在安卓7.0源码并没有找到，所以可能他进一步封装了变成了late-init
        am.QueueEventTrigger("late-init");
    }

    // Run all property triggers based on current state of the properties.
    //这里应该去初始化属性服务的一些东西
    am.QueueBuiltinAction(queue_property_triggers_action, "queue_property_triggers");

    
   
    //这是一个无限循环，先去执行完init需要走完的操作，然后等待即将发生的事件
    while (true) {
        
        //这里不是在等待即将发生的事件，说明初始化过程是在这里执行的
        if (!waiting_for_exec) {
            //am 去执行一个个前面设置的事件
            am.ExecuteOneCommand();
            
            //重启死去的进程
            restart_processes();
        }

        int timeout = -1;
        if (process_needs_restart) {
            timeout = (process_needs_restart - gettime()) * 1000;
            if (timeout < 0)
                timeout = 0;
        }

        
        if (am.HasMoreCommands()) {
            timeout = 0;
        }

        bootchart_sample(&timeout);

        epoll_event ev;
        int nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &ev, 1, timeout));
        if (nr == -1) {
            ERROR("epoll_wait failed: %s\n", strerror(errno));
        } else if (nr == 1) {
             //通过epoll来监听，处理属性服务相关的事情。
            ((void (*)()) ev.data.ptr)();
        }
    }

    return 0;
}
~~~

所以说，比较重点的就是解析配置文件发生了什么，为什么要在解析前设置很多AddSectionParser，section是什么意思？到底是如何解析的？获取到action是什么意思？

# init.rc

> init.rc是一个配置文件，内部由Android初始化语言编写（Android Init Language）的脚本文件，可以参考谷歌官方文档：https://android.googlesource.com/platform/system/core/+/master/init/README.md

他干了什么呢?

>   它负责系统的初始设置........（后面会讲到底干了什么）

既然是脚本文件，他属于谷歌自定义的一种格式，那就要有一定的规范！下面这句话的意思就是，AIL由5种类型组成！：Actions, Commands, Services, Options, and Imports.

>  The Android Init Language consists of five broad classes of statements: Actions, Commands, Services, Options, and Imports.

## action

action是command的序列（你就当做他是一堆命令的集合），他具有触发器(trigger)，当一个事件发生时与一个action的触发器匹配时，该action被添加到一个待执行队列的尾部（除非它已经在队列中）。队列中的每个action都按顺序出列，并且该action中的每个command都按顺序执行。Init处理活动中命令执行之间的其他活动（设备创建/销毁，属性设置，进程重启）。

action的书写采取以下形式：

~~~
on <trigger> [&& <trigger>]*
   <command>
   <command>
   <command>
~~~

action将添加到队列中，并根据解析包含它们的文件的顺序执行（请参阅“imports”部分），然后按顺序在单个文件中执行。

示例

~~~
on boot
   setprop a 1
   setprop b 2

on boot && property:true=true
   setprop c 1
   setprop d 2

on boot
   setprop e 1
   setprop f 2
~~~

然后当`boot`触发发生并假设property:  true等于时`true`，执行的命令的顺序将是：

~~~jav
setprop a 1 
setprop b 2 
setprop c 1 
setprop d 2 
setprop e 1 
setprop f 2
~~~























