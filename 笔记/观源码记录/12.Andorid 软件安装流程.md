[toc]

# Andorid 软件安装流程

近期在做静默安装时遇到了一些问题，由于对软件安装流程的不了解，浪费了些时间。下定决心看看安卓的软件安装流程。做了个笔记。

ps: Android的软件安装，管理等流程十分的复杂，并不是一两篇几千字的笔记就能讲完的。本文只是简单的去了解一下，网上不缺写的好的，分析的十分到位的文章，可自行查看。

# 我所认为的软件安装流程

我所认为的软件安装：就是将软件包拷贝到某个目录，然后系统的软件包管理工具分析这个软件的信息并进行保存。下面我从源码过一遍这个大致流程。

根据安卓系统的设计，会有一个服务专门管理软件服务 --- PackageManagerService，这是Framework层的服务。



# Android软件安装的方式

我们常知道的软件来源只有两种：

+ 系统预置app
+ 用户安装

# 系统预置的app目录

一般系统预置的app在这几个目录：/vendor/app （厂商定制代码） /system/app，/system/vendor/app，以及/system/priv-app等

# 用户安装的app目录

/data/app

# 系统预置app的安装流程

这些软件的安装界面过程和界面我们平时也没看到，只知道启动就装上了，所以就找到下手点：**PackageManagerService的启动**。

先看构造函数吧：

~~~java

1354      public PackageManagerService(Context context, Installer installer,
1355              boolean factoryTest, boolean onlyCore) {
1419          synchronized (mPackages) {
  								//这里获取了用户软件的安装目录，这里稍后再进行分析
1426              File dataDir = Environment.getDataDirectory();
1427              mAppDataDir = new File(dataDir, "data");
1428              mAppInstallDir = new File(dataDir, "app");
1429              mAppLib32InstallDir = new File(dataDir, "app-lib");
1430              mAsecInternalPath = new File(dataDir, "app-asec").getPath();
1431              mUserAppDataDir = new File(dataDir, "user");
1432              mDrmAppPrivateInstallDir = new File(dataDir, "app-private");
  
  								//这里只处理framework-res.apk，和/core-libart.jar，因为这是android5以上的源码，系统虚拟机是ART，会在									//安装时进行dex转换成ART所需要文件的操作，而这两个东西没有代码。所以为了不报一堆错误日志，直接排除了。
  								frameworkDir = new File(Environment.getRootDirectory(), "framework");
1555  
1556              // Gross hack for now: we know this file doesn't contain any
1557              // code, so don't dexopt it to avoid the resulting log spew.
1558              alreadyDexOpted.add(frameworkDir.getPath() + "/framework-res.apk");
1559  
1560              // Gross hack for now: we know this file is only part of
1561              // the boot class path for art, so don't dexopt it to
1562              // avoid the resulting log spew.
1563              alreadyDexOpted.add(frameworkDir.getPath() + "/core-libart.jar");


 									//谷歌翻译：收集供应商覆盖程序包。（在扫描任何应用程序之前执行此操作。）出于安全性和版本匹配的原因，请仅考虑
									//覆盖软件包（如果它们位于/vendor/overlay中）
1606              // Collect vendor overlay packages.
1607              // (Do this before scanning any apps.)
1608              // For security and version matching reason, only consider
1609              // overlay packages if they reside in VENDOR_OVERLAY_DIR:/vendor/overlay.
1610              File vendorOverlayDir = new File(VENDOR_OVERLAY_DIR);
  								//扫描/vendor/overlay目录，并且设置flag：SCAN_TRUSTED_OVERLAY，具体什么意思暂时不清楚
1611              scanDirLI(vendorOverlayDir, PackageParser.PARSE_IS_SYSTEM
1612                      | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags | SCAN_TRUSTED_OVERLAY, 0);
1613  
1614              // Find base frameworks (resource packages without code).
1615              scanDirLI(frameworkDir, PackageParser.PARSE_IS_SYSTEM
1616                      | PackageParser.PARSE_IS_SYSTEM_DIR
1617                      | PackageParser.PARSE_IS_PRIVILEGED,
1618                      scanFlags | SCAN_NO_DEX, 0);
1619  
1620              // Collected privileged system packages.扫描/system/priv-app目录下的app
1621              final File privilegedAppDir = new File(Environment.getRootDirectory(), "priv-app");
1622              scanDirLI(privilegedAppDir, PackageParser.PARSE_IS_SYSTEM
1623                      | PackageParser.PARSE_IS_SYSTEM_DIR
1624                      | PackageParser.PARSE_IS_PRIVILEGED, scanFlags, 0);
1625  
1626              // Collect ordinary system packages.扫描/system/app目录下的app
1627              systemAppDir = new File(Environment.getRootDirectory(), "app");
1628              scanDirLI(systemAppDir, PackageParser.PARSE_IS_SYSTEM
1629                      | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);
1636  
1637              // Collect all vendor packages. 扫描/vendor/app目录下的app
1638              vendorAppDir = new File("/vendor/app");
1639              //try {
1640             //     vendorAppDir = vendorAppDir.getCanonicalFile();
1641              //} catch (IOException e) {
1642                  // failed to look up canonical path, continue with original one
1643              //}
1644              scanDirLI(vendorAppDir, PackageParser.PARSE_IS_SYSTEM
1645                      | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);
1646  
1647              // Collect all OEM packages.扫描ome厂商目录下的app
1648              final File oemAppDir = new File(Environment.getOemDirectory(), "app");
1649              scanDirLI(oemAppDir, PackageParser.PARSE_IS_SYSTEM
1650                      | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);
1651  
1652              if (DEBUG_UPGRADE) Log.v(TAG, "Running installd update commands");
1653              mInstaller.moveFiles();
1654  
  								//接下来就是删除已经不在的system app，以及一些版本回退，
1655              // Prune any system packages that no longer exist.
   								if (!mOnlyCore) {
                    //这里进行/data/app目录下的软件扫描。并不是安装
                      scanDirLI(mAppInstallDir, 0, scanFlags | SCAN_REQUIRE_KNOWN, 0);
1730  
1731                  scanDirLI(mDrmAppPrivateInstallDir, PackageParser.PARSE_FORWARD_LOCK,
1732                          scanFlags | SCAN_REQUIRE_KNOWN, 0);
1734                  /**
											 *删除通过OTA删除的所有更新的系统应用程序的禁用程序包设置。
											 *如果它们不是以前更新的应用程序，则将其完全删除;否则，只需撤销其系统级权限即可。
1735                   * Remove disable package settings for any updated system
1736                   * apps that were removed via an OTA. If they're not a
1737                   * previously-updated app, remove them completely.
1738                   * Otherwise, just revoke their system-level permissions.
1739                   */
1740                  for (String deletedAppName : possiblyDeletedUpdatedSystemApps) {
1741                      PackageParser.Package deletedPkg = mPackages.get(deletedAppName);
1742                      mSettings.removeDisabledSystemPackageLPw(deletedAppName);
1743  
1744                      String msg;
1745                      if (deletedPkg == null) {
1746                          msg = "Updated system package " + deletedAppName
1747                                  + " no longer exists; wiping its data";
1748                          removeDataDirsLI(deletedAppName);
1749                      } else {
1750                          msg = "Updated system app + " + deletedAppName
1751                                  + " no longer present; removing system privileges for "
1752                                  + deletedAppName;
1753  
1754                          deletedPkg.applicationInfo.flags &= ~ApplicationInfo.FLAG_SYSTEM;
1755  
1756                          PackageSetting deletedPs = mSettings.mPackages.get(deletedAppName);
1757                          deletedPs.pkgFlags &= ~ApplicationInfo.FLAG_SYSTEM;
1758                      }
1759                      logCriticalInfo(Log.WARN, msg);
1760                  }
1656   
1761  
1762                  /**
											 *确保确实出现了我们期望出现在userdata分区上的所有系统应用程序。
											 * 如果它们从未出现过，请向后回滚版本并重新启动系统版本。
1763                   * Make sure all system apps that we expected to appear on
1764                   * the userdata partition actually showed up. If they never
1765                   * appeared, crawl back and revive the system version.
1766                   */
1767                  for (int i = 0; i < expectingBetter.size(); i++) {
1768                  ...
											}
1882  
  						//初始化了安装服务，并且把用户安装目录传了进去，猜测mInstallerService是后续用户安装app时用的
1883          mInstallerService = new PackageInstallerService(context, this, mAppInstallDir);
1884  
1885          // Now after opening every single application zip, make sure they
1886          // are all flushed.  Not really needed, but keeps things nice and
1887          // tidy.
1888          Runtime.getRuntime().gc();
1889      }
1890  
~~~



## 小结

系统启动后，PackageManagerService的一些流程如下：（并不是完整流程）

+ 获取用户app相关目录
+ 将framework-res.apk等不需要进行DEX转换的apk和jar包进行排除
+ 收集供应商覆盖程序包。
+ 扫描/system/priv-app目录下的app
+ 扫描/system/app目录下的app
+ 扫描/vendor/app目录下的app
+ 扫描ome厂商目录下的app
+ 做一些软件的数据清理等等
+ 初始化PackageInstallerService

这里有些小细节：data/下的目录虽然一开始就获取了，但是却在最后使用。这里可能是为了防止system的app将data的覆盖了。

接下来就看scanDirLI方法做了什么

## scanDirLI ()

~~~java
4405      private void scanDirLI(File dir, int parseFlags, int scanFlags, long currentTime) {
4406          final File[] files = dir.listFiles();
4407         ...
4421          for (File file : files) {
4422          ...
4429              ...
4435              PackageParser.Package pkg = null;
4436              try {
  										//又去进行了一次扫描
4437                  pkg = scanPackageLI(file, parseFlags | PackageParser.PARSE_MUST_BE_APK,
4438                          scanFlags, currentTime, null);
4439              } catch (PackageManagerException e) {
4440                  ...}
  						if(SystemProperties.get("persist.sys.qb.enable","false").equals("true")) {
4453                  if(SystemProperties.get("persist.sys.qb.flag","true").equals("false")) {
4454                      if ((mAppInstallDir != null) && mAppInstallDir.equals(dir)) {
4455                          if (pkg != null) {
4456                              mDataAppPackage.add(pkg.packageName);
4457                          }
4458                      }
4459                  } else {
4460                      if ((mAppInstallDir != null) && mAppInstallDir.equals(dir)) {
4461                          if (pkg != null && mAddPackageLast != null) {
4462             //这里在某个条件下会发送安装广播，是否可以理解为上面的scanPackageLI方法已经进行软件了安装																											
  sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,mAddPackageLast,null,null,null,null);
4463                          }
4464                      }
4465                  }
4466              }
4470      }
~~~

scanDirLI函数应该是软件安装的入口，他做的工作就是去扫描传进来的软件目录，调用的是scanPackageLI方法，接下来看看scanPackageLI方法：

~~~java
 /*
4550       *  Scan a package and return the newly parsed package.
4551       *  Returns null in case of errors and the error code is stored in mLastScanError
4552       */
4553      private PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags,
4554              long currentTime, UserHandle user) throws PackageManagerException {
4555          if (DEBUG_INSTALL) Slog.d(TAG, "Parsing: " + scanFile);
4556          parseFlags |= mDefParseFlags;
  						//包解析器
4557          PackageParser pp = new PackageParser();
  						...
                
               //解析软件包，获取软件的一些信息，进行完整性检测
4566          final PackageParser.Package pkg;
4567          try {
 									//在给定位置解析包。 自动检测程序包是整体样式（单个APK文件）还是群集样式（APK目录）。
									//这会对群集样式的软件包执行完整性检查，例如要求相同的软件包名称和版本代码，单个基本APK和唯一的拆分名称。
									// 请注意，这不会执行签名验证。 必须分别在{@link #collectCertificates（Package，int）}中完成。
  								//@see #parsePackageLite（File，int）
  								//这里就是去解析AndroidMainifest.xml了
4568              pkg = pp.parsePackage(scanFile, parseFlags);
4569          } catch (PackageParserException e) {
4570              throw PackageManagerException.from(e);
4571          }
4572  
  						//判断是否更新、覆盖安装apk等,处理签名，系统预装版本和用户安装版本是否相同等操作，一般以系统预装为主。如果系、统版本比用户安装版本低，会以用户版本为主
4573         ....
  
  					//进行签名计算或者获取，因为下面有签名比对
       			 collectCertificatesLI(ps, pkg, scanFile, policyFlags);
4672          /*
4673           * A new system app appeared, but we already had a non-system one of the
4674           * same name installed earlier.
4675           */
4676          boolean shouldHideSystemApp = false;
4677          if (updatedPkg == null && ps != null
4678                  && (parseFlags & PackageParser.PARSE_IS_SYSTEM_DIR) != 0 && !isSystemApp(ps)) {
4679              /*
4680               * Check to make sure the signatures match first. If they don't,
4681               * wipe the installed application and its data.
									 * 可以看到签名不一致，会卸载已经安装的应用
4682               */
4683              if (compareSignatures(ps.signatures.mSignatures, pkg.mSignatures)
4684                      != PackageManager.SIGNATURE_MATCH) {
4685                  logCriticalInfo(Log.WARN, "Package " + ps.name + " appeared on system, but"
4686                          + " signatures don't match existing userdata copy; removing");
4687                  deletePackageLI(pkg.packageName, null, true, null, null, 0, null, false);
4688                  ps = null;
4689              } else {
4690                  /*
4691                   * If the newly-added system app is an older version than the
4692                   * already installed version, hide it. It will be scanned later
4693                   * and re-added like an update.注意，当新旧都是预装的系统app才能低版本覆盖，这里是暂时隐藏，
											 *后面会重新以升级的方式进行安装
4694                   */
4695                  if (pkg.mVersionCode <= ps.versionCode) {
4696                      shouldHideSystemApp = true;
4697                      logCriticalInfo(Log.INFO, "Package " + ps.name + " appeared at " + scanFile
4698                              + " but new version " + pkg.mVersionCode + " better than installed "
4699                              + ps.versionCode + "; hiding system");
4700                  } else {
4701                      /*
4702                       * The newly found system app is a newer version that the
4703                       * one previously installed. Simply remove the
4704                       * already-installed application and replace it with our own
4705                       * while keeping the application data.
													 * 高版本就是直接覆盖了，但是会保留数据
4706                       */
4707                      logCriticalInfo(Log.WARN, "Package " + ps.name + " at " + scanFile
4708                              + " reverting from " + ps.codePathString + ": new version "
4709                              + pkg.mVersionCode + " better than installed " + ps.versionCode);
4710                      InstallArgs args = createInstallArgsForExisting(packageFlagsToInstallFlags(ps),
4711                              ps.codePathString, ps.resourcePathString, ps.legacyNativeLibraryPathString,
4712                              getAppDexInstructionSets(ps));
4713                      synchronized (mInstallLock) {
4714                          args.cleanUpResourcesLI();
4715                      }
4716                  }
4717              }
4718          }
4719  
4746          //这里会把软件文件的路径，资源等路径设置好
4747          pkg.applicationInfo.setCodePath(pkg.codePath);
4748          pkg.applicationInfo.setBaseCodePath(pkg.baseCodePath);
4749          pkg.applicationInfo.setSplitCodePaths(pkg.splitCodePaths);
4750          pkg.applicationInfo.setResourcePath(resourcePath);
4751          pkg.applicationInfo.setBaseResourcePath(baseResourcePath);
4752          pkg.applicationInfo.setSplitResourcePaths(pkg.splitCodePaths);
4753  
  						//接下来正式开始进行安装包的解压
4754          // Note that we invoke the following method only if we are about to unpack an application
4755          PackageParser.Package scannedPkg = scanPackageLI(pkg, parseFlags, scanFlags
4756                  | SCAN_UPDATE_SIGNATURE, currentTime, user);
4757  
4758          /*
4759           * If the system app should be overridden by a previously installed
4760           * data, hide the system app now and let the /data/app scan pick it up
4761           * again.
							*
4762           */
4763          if (shouldHideSystemApp) {
4764              synchronized (mPackages) {
4765                  /*
4766                   * We have to grant systems permissions before we hide, because
4767                   * grantPermissions will assume the package update is trying to
4768                   * expand its permissions.
4769                   */
4770                  grantPermissionsLPw(pkg, true, pkg.packageName);
4771                  mSettings.disableSystemPackageLPw(pkg.packageName);
4772              }
4773          }
4774  
4775          return scannedPkg;
4776      }
4777  
~~~

## 小结

+ 使用PackageParser解析AndroidMainifest.xml
+ 根据是否是已经安装过去处理系统app与用户安装的app的关系
+ 签名校验，不一致的数据会直接被抹除
+ 设置软件代码，等资源的路径
+ 开始解压安装包

这里注意到，一些状态都是根据标志位去存储的，这比写一些true和false要好的多，我写过一篇笔记记录过原因:[android 源码中常用的flag](https://github.com/BAByte/BANote/blob/master/%E7%AC%94%E8%AE%B0/%E8%AF%BB%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E7%AC%94%E8%AE%B0/%E5%AE%89%E5%8D%93%E6%BA%90%E7%A0%81%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84Flag%E8%AF%AD%E5%8F%A5.md)

由于data目录下的app是最后安装的，做了一个版本校验，一般情况下会以预装的为主。

## AndroidMainifest.xml的解析

~~~java
 /**
740       * Parse the package at the given location. Automatically detects if the
741       * package is a monolithic style (single APK file) or cluster style
742       * (directory of APKs).
743       * <p>
744       * This performs sanity checking on cluster style packages, such as
745       * requiring identical package name and version codes, a single base APK,
746       * and unique split names.
747       * <p>
748       * Note that this <em>does not</em> perform signature verification; that
749       * must be done separately in {@link #collectCertificates(Package, int)}.
750       *
751       * @see #parsePackageLite(File, int)
752       */
				//是单个apk还是传了个目录，接着上面分析，这里是传了个目录
753      public Package parsePackage(File packageFile, int flags) throws PackageParserException {
754          if (packageFile.isDirectory()) {
755              return parseClusterPackage(packageFile, flags);
756          } else {
757              return parseMonolithicPackage(packageFile, flags);
758          }
759      }
~~~

接着看parseClusterPackage 方法：

~~~java
761      /**
762       * Parse all APKs contained in the given directory, treating them as a
763       * single package. This also performs sanity checking, such as requiring
764       * identical package name and version codes, a single base APK, and unique
765       * split names.
766       * <p>
767       * Note that this <em>does not</em> perform signature verification; that
768       * must be done separately in {@link #collectCertificates(Package, int)}.
769       */
770      private Package parseClusterPackage(File packageDir, int flags) throws PackageParserException {
  						//这里是安装split apks 的流程，不分析这种apk，
771          final PackageLite lite = parseClusterPackageLite(packageDir, 0);
772  ...
778          final AssetManager assets = new AssetManager();
779          try {
780            ...
  							//所以正常的apk是在这里去解析AndroidMainifest.xml
791              final Package pkg = parseBaseApk(baseApk, assets, flags);
792              if (pkg == null) {
793                  throw new PackageParserException(INSTALL_PARSE_FAILED_NOT_APK,
794                          "Failed to parse base APK: " + baseApk);
795              }
796  
  							...
809              pkg.codePath = packageDir.getAbsolutePath();
810              return pkg;
811          } finally {
812              IoUtils.closeQuietly(assets);
813          }
814      }
~~~

接下来