[toc]

# Andorid 软件安装流程

近期在做静默安装时遇到了一些问题，由于对软件安装流程的不了解，浪费了些时间。下定决心看看安卓的软件安装流程。做了个笔记。

ps: Android的软件安装，管理等流程十分的复杂，并不是一两篇几千字的笔记就能讲完的。本文只是简单的去了解一下，网上不缺写的好，分析的十分到位的文章，可自行查看。

# 我所认为的软件安装流程

我所认为的软件安装：就是将软件包拷贝到某个目录，然后系统的软件包管理工具分析这个软件的信息并进行保存。下面我从源码过一遍这个大致流程，看看对不对。

根据安卓系统的设计，会有一个服务专门管理软件服务 --- PackageManagerService，所以就从这个服务下手了。

# Android软件安装的方式

我们常知道的软件来源只有两种：

+ 系统预置app
+ 用户安装

# 系统预置的app目录

一般系统预置的app在这几个目录：/vendor/app （厂商定制代码） /system/app，/system/vendor/app，以及/system/priv-app等

# 用户安装的app目录

/data/app

# 系统预置app的安装流程

这些软件的安装界面过程和界面我们平时也没看到，只知道启动就装上了，所以就找到下手点：**PackageManagerService的启动**。

先看构造函数吧：

~~~java

1354      public PackageManagerService(Context context, Installer installer,
1355              boolean factoryTest, boolean onlyCore) {
1419          synchronized (mPackages) {
  								//这里获取了用户软件的安装目录，数据存储目录
1426              File dataDir = Environment.getDataDirectory();
  								//就是/data/data/,   /data/app/,安装的软件都是放在这里
1427              mAppDataDir = new File(dataDir, "data");
1428              mAppInstallDir = new File(dataDir, "app"); 
1429              mAppLib32InstallDir = new File(dataDir, "app-lib");
1430              mAsecInternalPath = new File(dataDir, "app-asec").getPath();
1431              mUserAppDataDir = new File(dataDir, "user");
1432              mDrmAppPrivateInstallDir = new File(dataDir, "app-private");
  
  								//这里只处理framework-res.apk，和/core-libart.jar，因为这是android5以上的源码，系统虚拟机是ART，会在									//安装时进行dex转换成ART所需要文件的操作，而这两个东西没有代码。所以为了不报一堆错误日志，直接排除了。
  								frameworkDir = new File(Environment.getRootDirectory(), "framework");
1555  
1556              // Gross hack for now: we know this file doesn't contain any
1557              // code, so don't dexopt it to avoid the resulting log spew.
1558              alreadyDexOpted.add(frameworkDir.getPath() + "/framework-res.apk");
1559  
1560              // Gross hack for now: we know this file is only part of
1561              // the boot class path for art, so don't dexopt it to
1562              // avoid the resulting log spew.
1563              alreadyDexOpted.add(frameworkDir.getPath() + "/core-libart.jar");


 									//谷歌翻译：收集供应商覆盖程序包。（在扫描任何应用程序之前执行此操作。）出于安全性和版本匹配的原因，请仅考虑
									//覆盖软件包（如果它们位于/vendor/overlay中）
1606              // Collect vendor overlay packages.
1607              // (Do this before scanning any apps.)
1608              // For security and version matching reason, only consider
1609              // overlay packages if they reside in VENDOR_OVERLAY_DIR:/vendor/overlay.
1610              File vendorOverlayDir = new File(VENDOR_OVERLAY_DIR);
  								//扫描/vendor/overlay目录，并且设置flag：SCAN_TRUSTED_OVERLAY，具体什么意思暂时不清楚
1611              scanDirLI(vendorOverlayDir, PackageParser.PARSE_IS_SYSTEM
1612                      | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags | SCAN_TRUSTED_OVERLAY, 0);
1613  
1614              // Find base frameworks (resource packages without code).
1615              scanDirLI(frameworkDir, PackageParser.PARSE_IS_SYSTEM
1616                      | PackageParser.PARSE_IS_SYSTEM_DIR
1617                      | PackageParser.PARSE_IS_PRIVILEGED,
1618                      scanFlags | SCAN_NO_DEX, 0);
1619  
1620              // Collected privileged system packages.扫描/system/priv-app目录下的app
1621              final File privilegedAppDir = new File(Environment.getRootDirectory(), "priv-app");
1622              scanDirLI(privilegedAppDir, PackageParser.PARSE_IS_SYSTEM
1623                      | PackageParser.PARSE_IS_SYSTEM_DIR
1624                      | PackageParser.PARSE_IS_PRIVILEGED, scanFlags, 0);
1625  
1626              // Collect ordinary system packages.扫描/system/app目录下的app
1627              systemAppDir = new File(Environment.getRootDirectory(), "app");
1628              scanDirLI(systemAppDir, PackageParser.PARSE_IS_SYSTEM
1629                      | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);
1636  
1637              // Collect all vendor packages. 扫描/vendor/app目录下的app
1638              vendorAppDir = new File("/vendor/app");
1639              //try {
1640             //     vendorAppDir = vendorAppDir.getCanonicalFile();
1641              //} catch (IOException e) {
1642                  // failed to look up canonical path, continue with original one
1643              //}
1644              scanDirLI(vendorAppDir, PackageParser.PARSE_IS_SYSTEM
1645                      | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);
1646  
1647              // Collect all OEM packages.扫描ome厂商目录下的app
1648              final File oemAppDir = new File(Environment.getOemDirectory(), "app");
1649              scanDirLI(oemAppDir, PackageParser.PARSE_IS_SYSTEM
1650                      | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);
1651  
1652              if (DEBUG_UPGRADE) Log.v(TAG, "Running installd update commands");
1653              mInstaller.moveFiles();
1654  
  								//接下来就是删除已经不在的system app，以及一些版本回退，
1655              // Prune any system packages that no longer exist.
  								//mOnlyCore 是指当前是否是以安全模式启动，如果不是则进行软件扫描，关于coreApp下文会进行详细解释
   								if (!mOnlyCore) {
                    //这里进行/data/app目录下的软件扫描。并不是安装
                      scanDirLI(mAppInstallDir, 0, scanFlags | SCAN_REQUIRE_KNOWN, 0);
1730  
1731                  scanDirLI(mDrmAppPrivateInstallDir, PackageParser.PARSE_FORWARD_LOCK,
1732                          scanFlags | SCAN_REQUIRE_KNOWN, 0);
1734                  /**
											 *删除通过OTA删除的所有更新的系统应用程序的禁用程序包设置。
											 *如果它们不是以前更新的应用程序，则将其完全删除;否则，只需撤销其系统级权限即可。
1735                   * Remove disable package settings for any updated system
1736                   * apps that were removed via an OTA. If they're not a
1737                   * previously-updated app, remove them completely.
1738                   * Otherwise, just revoke their system-level permissions.
1739                   */
1740                  for (String deletedAppName : possiblyDeletedUpdatedSystemApps) {
1741                      PackageParser.Package deletedPkg = mPackages.get(deletedAppName);
1742                      mSettings.removeDisabledSystemPackageLPw(deletedAppName);
1743  
1744                      String msg;
1745                      if (deletedPkg == null) {
1746                          msg = "Updated system package " + deletedAppName
1747                                  + " no longer exists; wiping its data";
1748                          removeDataDirsLI(deletedAppName);
1749                      } else {
1750                          msg = "Updated system app + " + deletedAppName
1751                                  + " no longer present; removing system privileges for "
1752                                  + deletedAppName;
1753  
1754                          deletedPkg.applicationInfo.flags &= ~ApplicationInfo.FLAG_SYSTEM;
1755  
1756                          PackageSetting deletedPs = mSettings.mPackages.get(deletedAppName);
1757                          deletedPs.pkgFlags &= ~ApplicationInfo.FLAG_SYSTEM;
1758                      }
1759                      logCriticalInfo(Log.WARN, msg);
1760                  }
1656   
1761  
1762                  /**
											 *确保确实出现了我们期望出现在userdata分区上的所有系统应用程序。
											 * 如果它们从未出现过，请向后回滚版本并重新启动系统版本。
1763                   * Make sure all system apps that we expected to appear on
1764                   * the userdata partition actually showed up. If they never
1765                   * appeared, crawl back and revive the system version.
1766                   */
1767                  for (int i = 0; i < expectingBetter.size(); i++) {
1768                  ...
											}
1882  
  						//初始化了安装服务，并且把用户安装目录传了进去，猜测mInstallerService是后续用户安装app时用的
1883          mInstallerService = new PackageInstallerService(context, this, mAppInstallDir);
1884  
1885          // Now after opening every single application zip, make sure they
1886          // are all flushed.  Not really needed, but keeps things nice and
1887          // tidy.
1888          Runtime.getRuntime().gc();
1889      }
1890  
~~~



## 小结

系统启动后，PackageManagerService构造函数里的一些流程如下：（并不是完整流程）

+ 获取用户app相关目录
+ 将framework-res.apk等不需要进行DEX转换的apk和jar包进行排除（添加进白名单）
+ 收集供应商覆盖程序包。
+ 扫描/system/priv-app目录下的app
+ 扫描/system/app目录下的app
+ 扫描/vendor/app目录下的app
+ 扫描ome厂商目录下的app
+ 做一些软件的数据清理等等
+ 初始化PackageInstallerService

这里有些小细节：

1. data/下的目录虽然一开始就获取了，但是却在最后使用。这里可能是为了防止system的app将用户主动安装的app覆盖?

2. “coreApp” 指的是AndroidManifest中属性coreApp值为true

~~~xml
<manifest xmlns:tools="http://schemas.android.com/tools"
    package="com.example.test"
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:versionCode="1"
    android:versionName="1.0"
    android:sharedUserId="android.uid.system"
    coreApp="true">
~~~

coreApp =“ true”表示应用程序将在启用特定的启动模式（可能是“安全模式”）时启动。

> 在dalvik中(实际为android2.2以上引入的技术),如同其他大多数jvm一样,都采用的是jit来做及时翻译(动态翻译),将dex或odex中并排的dalvik code(或者叫smali指令集)**运行态**翻译成native code去执行.jit的引入使得dalvik提升了3~6倍的性能
>
> 而在art中,完全抛弃了dalvik的jit,使用了aot直接在安装时用dex2oat将其完全翻译成native code.这一技术的引入,使得虚拟机执行指令的速度又一重大提升

这里我画一个流程图，后面我会慢慢的补全这个流程图

![image](https://github.com/BAByte/pic/blob/master/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_b78e9c28-41ea-4bf9-aa05-92e887f01bf2.png?raw=true)

接下来就看scanDirLI方法做了什么

## scanDirLI ()

~~~java
4405      private void scanDirLI(File dir, int parseFlags, int scanFlags, long currentTime) {
4406          final File[] files = dir.listFiles();
4407         ...
  					//循环遍历该目录下的所有安装包
4421          for (File file : files) {
4422          ...
4429              ...
4435              PackageParser.Package pkg = null;
4436              try {
  										//又去进行了一次扫描
4437                  pkg = scanPackageLI(file, parseFlags | PackageParser.PARSE_MUST_BE_APK,
4438                          scanFlags, currentTime, null);
4439              } catch (PackageManagerException e) {
4440                  ...}
  						if(SystemProperties.get("persist.sys.qb.enable","false").equals("true")) {
4453                  if(SystemProperties.get("persist.sys.qb.flag","true").equals("false")) {
4454                      if ((mAppInstallDir != null) && mAppInstallDir.equals(dir)) {
4455                          if (pkg != null) {
  																//这里只存了包名
4456                              mDataAppPackage.add(pkg.packageName);
4457                          }
4458                      }
4459                  } else {
4460                      if ((mAppInstallDir != null) && mAppInstallDir.equals(dir)) {
4461                          if (pkg != null && mAddPackageLast != null) {
4462             //这里在某个条件下会发送安装广播，是否可以理解为上面的scanPackageLI方法已经进行软件了安装																//mAddPackageLast 应该就是这里的pkg，说明软件安装其实是一个一个
  sendPackageBroadcast(Intent.ACTION_PACKAGE_ADDED,mAddPackageLast,null,null,null,null);
4463                          }
4464                      }
4465                  }
4466              }
4470      }
~~~

## 小结

scanDirLI函数应该是软件安装的入口，他做的工作就是：

1. 扫描传进来的软件目录下的所有apk
2. 调用PackageParser类的scanPackageLI方法对apk进行解析
3. 发送安装软件广播

当扫描完后发了个应用安装的广播。通过mAddPackageLast可以看出软件安装是一个一个进行的，同时这里留下了一个疑点mAddPackageLast在哪里赋值的？

## PackageParser.scanPackageLI()

~~~java
 /*
4550       *  Scan a package and return the newly parsed package.
4551       *  Returns null in case of errors and the error code is stored in mLastScanError
4552       */
4553      private PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags,
4554              long currentTime, UserHandle user) throws PackageManagerException {
4555          if (DEBUG_INSTALL) Slog.d(TAG, "Parsing: " + scanFile);
4556          parseFlags |= mDefParseFlags;
  						//包解析器
4557          PackageParser pp = new PackageParser();
  						...
                
               //解析软件包，获取软件的一些信息，进行完整性检测
4566          final PackageParser.Package pkg;
4567          try {
 									//在给定位置解析包。 自动检测程序包是整体样式（单个APK文件）还是群集样式（APK目录）。
									//这会对群集样式的软件包执行完整性检查，例如要求相同的软件包名称和版本代码，单个基本APK和唯一的拆分名称。
									// 请注意，这不会执行签名验证。 必须分别在{@link #collectCertificates（Package，int）}中完成。
  								//@see #parsePackageLite（File，int）
  								//这里就是去解析AndroidMainifest.xml了
4568              pkg = pp.parsePackage(scanFile, parseFlags);
4569          } catch (PackageParserException e) {
4570              throw PackageManagerException.from(e);
4571          }
4572  
  						//判断是否更新、覆盖安装apk等,处理签名，系统预装版本和用户安装版本是否相同等操作，一般以系统预装为主。如果系、统版本比用户安装版本低，会以用户版本为主
4573         ....
  
  					//进行签名计算或者获取，因为下面有签名比对
       			 collectCertificatesLI(ps, pkg, scanFile, policyFlags);
4672          /*
4673           * A new system app appeared, but we already had a non-system one of the
4674           * same name installed earlier.
4675           */
4676          boolean shouldHideSystemApp = false;
4677          if (updatedPkg == null && ps != null
4678                  && (parseFlags & PackageParser.PARSE_IS_SYSTEM_DIR) != 0 && !isSystemApp(ps)) {
4679              /*
4680               * Check to make sure the signatures match first. If they don't,
4681               * wipe the installed application and its data.
									 * 可以看到签名不一致，会卸载已经安装的应用
4682               */
4683              if (compareSignatures(ps.signatures.mSignatures, pkg.mSignatures)
4684                      != PackageManager.SIGNATURE_MATCH) {
4685                  logCriticalInfo(Log.WARN, "Package " + ps.name + " appeared on system, but"
4686                          + " signatures don't match existing userdata copy; removing");
4687                  deletePackageLI(pkg.packageName, null, true, null, null, 0, null, false);
4688                  ps = null;
4689              } else {
4690                  /*
4691                   * If the newly-added system app is an older version than the
4692                   * already installed version, hide it. It will be scanned later
4693                   * and re-added like an update.注意，当新旧都是预装的系统app才能低版本覆盖，这里是暂时隐藏，
											 *后面会重新以升级的方式进行安装
4694                   */
4695                  if (pkg.mVersionCode <= ps.versionCode) {
4696                      shouldHideSystemApp = true;
4697                      logCriticalInfo(Log.INFO, "Package " + ps.name + " appeared at " + scanFile
4698                              + " but new version " + pkg.mVersionCode + " better than installed "
4699                              + ps.versionCode + "; hiding system");
4700                  } else {
4701                      /*
4702                       * The newly found system app is a newer version that the
4703                       * one previously installed. Simply remove the
4704                       * already-installed application and replace it with our own
4705                       * while keeping the application data.
													 * 高版本就是直接覆盖了，但是会保留数据
4706                       */
4707                      logCriticalInfo(Log.WARN, "Package " + ps.name + " at " + scanFile
4708                              + " reverting from " + ps.codePathString + ": new version "
4709                              + pkg.mVersionCode + " better than installed " + ps.versionCode);
4710                      InstallArgs args = createInstallArgsForExisting(packageFlagsToInstallFlags(ps),
4711                              ps.codePathString, ps.resourcePathString, ps.legacyNativeLibraryPathString,
4712                              getAppDexInstructionSets(ps));
4713                      synchronized (mInstallLock) {
4714                          args.cleanUpResourcesLI();
4715                      }
4716                  }
4717              }
4718          }
4719  
4746          //这里会把软件文件的路径，资源等路径设置好,这里出现了split字样，下面解释这个是什么意思
4747          pkg.applicationInfo.setCodePath(pkg.codePath);
4748          pkg.applicationInfo.setBaseCodePath(pkg.baseCodePath);
4749          pkg.applicationInfo.setSplitCodePaths(pkg.splitCodePaths);
4750          pkg.applicationInfo.setResourcePath(resourcePath);
4751          pkg.applicationInfo.setBaseResourcePath(baseResourcePath);
4752          pkg.applicationInfo.setSplitResourcePaths(pkg.splitCodePaths);
4753  
  						//接下来正式开始进行安装包的解压
4754          // Note that we invoke the following method only if we are about to unpack an application
4755          PackageParser.Package scannedPkg = scanPackageLI(pkg, parseFlags, scanFlags
4756                  | SCAN_UPDATE_SIGNATURE, currentTime, user);
4757  
4758          /*
4759           * If the system app should be overridden by a previously installed
4760           * data, hide the system app now and let the /data/app scan pick it up
4761           * again.
							*
4762           */
4763          if (shouldHideSystemApp) {
4764              synchronized (mPackages) {
4765                  /*
4766                   * We have to grant systems permissions before we hide, because
4767                   * grantPermissions will assume the package update is trying to
4768                   * expand its permissions.
4769                   */
4770                  grantPermissionsLPw(pkg, true, pkg.packageName);
4771                  mSettings.disableSystemPackageLPw(pkg.packageName);
4772              }
4773          }
4774  
4775          return scannedPkg;
4776      }
4777  
~~~

## 小结

+ 使用PackageParser解析AndroidMainifest.xml，并生成包含该安装包信息的Package对象
+ 根据是否是已经安装的情况，处理系统app与用户安装的app的关系
+ 签名校验，不一致的数据会直接被抹除
+ 设置软件代码，等资源的路径
+ 开始解压安装包

这里注意到，一些状态都是根据标志位去存储的，这比写一些true和false要好的多，我写过一篇笔记记录过:[android 源码中常用的flag](https://github.com/BAByte/BANote/blob/master/%E7%AC%94%E8%AE%B0/%E8%AF%BB%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E7%AC%94%E8%AE%B0/%E5%AE%89%E5%8D%93%E6%BA%90%E7%A0%81%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84Flag%E8%AF%AD%E5%8F%A5.md)

data目录下的app是最后安装的，做了一个版本校验，一般情况下会以预装的为主。

> Android5.0引入了Split APK机制，这是为了解决65536上限以及APK安装包越来越大等问题。Split APK机制可以将一个APK，拆分成多个独立APK。 在引入了Split APK机制后，APK有两种分类：
>
> - Single APK：安装文件为一个完整的APK，即base APK。Android称其为Monolithic。
> - Mutiple APK：安装文件在一个文件目录中，其内部有多个被拆分的APK，这些APK由一个 base APK和一个或多个split APK组成。Android称其为Cluster。

## AndroidMainifest.xml的解析

~~~java
 /**
740       * Parse the package at the given location. Automatically detects if the
741       * package is a monolithic style (single APK file) or cluster style
742       * (directory of APKs).
743       * <p>
744       * This performs sanity checking on cluster style packages, such as
745       * requiring identical package name and version codes, a single base APK,
746       * and unique split names.
747       * <p>
748       * Note that this <em>does not</em> perform signature verification; that
749       * must be done separately in {@link #collectCertificates(Package, int)}.
750       *
751       * @see #parsePackageLite(File, int)
752       */
				//是单个apk还是传了个目录
753      public Package parsePackage(File packageFile, int flags) throws PackageParserException {
754          if (packageFile.isDirectory()) {
755              return parseClusterPackage(packageFile, flags);
756          } else {
757              return parseMonolithicPackage(packageFile, flags);
758          }
759      }
~~~

如果要解析的packageFile是一个目录，说明是Mutiple APK，就需要调用parseClusterPackage方法来解析，如果是Single APK则调用parseMonolithicPackage方法来解析。挑一个复杂的parseClusterPackage 方法看：

~~~java
761      /**
762       * Parse all APKs contained in the given directory, treating them as a
763       * single package. This also performs sanity checking, such as requiring
764       * identical package name and version codes, a single base APK, and unique
765       * split names.
766       * <p>
767       * Note that this <em>does not</em> perform signature verification; that
768       * must be done separately in {@link #collectCertificates(Package, int)}.
769       */
770      private Package parseClusterPackage(File packageDir, int flags) throws PackageParserException {
  						//这里是安装split apks 的流程，不分析这种apk，
771          final PackageLite lite = parseClusterPackageLite(packageDir, 0);
772  ...
778          final AssetManager assets = new AssetManager();
779          try {
780            ...
  							//解析BaseApk的AndroidMainifest.xml文件
791              final Package pkg = parseBaseApk(baseApk, assets, flags);
792              if (pkg == null) {
793                  throw new PackageParserException(INSTALL_PARSE_FAILED_NOT_APK,
794                          "Failed to parse base APK: " + baseApk);
795              }
  								//统计split apk的数量
797              if (!ArrayUtils.isEmpty(lite.splitNames)) {
798                  final int num = lite.splitNames.length;
799                  pkg.splitNames = lite.splitNames;
800                  pkg.splitCodePaths = lite.splitCodePaths;
801                  pkg.splitRevisionCodes = lite.splitRevisionCodes;
802                  pkg.splitFlags = new int[num];
  										
  										//split apk的安装
804                  for (int i = 0; i < num; i++) {
805                      parseSplitApk(pkg, i, assets, flags);
806                  }
807              }
796  
  							...
809              pkg.codePath = packageDir.getAbsolutePath();
810              return pkg;
811          } finally {
812              IoUtils.closeQuietly(assets);
813          }
814      }
~~~

关于解析AndroidMainifest的代码十分夸张， 足足有1千多行代码！需要先简单的了解AndroidMainifest.xml的组成：

### AndroidMainifest.xml概览

请阅读：[官方文档](https://developer.android.com/guide/topics/manifest/manifest-intro.html)

解析XML文件在学习《Android第一行代码》时就已经了解，不管源码采用哪种方式解析，最终的目的都是把xml的节点解析后生成java对象。这里简单的说说AndroidManifinest.xml的组成，以及xml节点所对应的对象。

~~~xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.ba.ex.mvvmsample">
  
<!--PackageInfo-->
    <uses-permission android:name="android.permission.INTERNET" />

  <!--ApplicationInfo-->
    <application
        android:name="com.ba.ex.mvvmsample.App">
      
      <!--ActivityInfo-->
        <activity
            android:name=".ui.MainActivity"
            android:label="@string/app_name">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
      
      <!--ServiceInfo-->
        <service android:name=""/>
      
       <!--reciver的解析是使用解析Activity的方法解析的-->
        <receiver android:name=""/>
      
        <!--ProviderInfo-->
        <provider
            android:authorities=""
            android:name=""/>
    </application>

</manifest>
~~~

广播接收器和Activity是使用同一个解析方法，至于为什么，就懒得研究了,不是本文重点。

下面我们看看parseBaseApk的方法，验证一下对应的对象是否正确：

~~~java
864      private Package parseBaseApk(File apkFile, AssetManager assets, int flags)
865              throws PackageParserException {
866          final String apkPath = apkFile.getAbsolutePath();
867  ...
874  
  					//这东西
875          Resources res = null;
  					//这东西熟悉吧，xml解析器
876          XmlResourceParser parser = null;
877          try {
878              res = new Resources(assets, mMetrics, null);
879              assets.setConfiguration(0, 0, null, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
880                      Build.VERSION.RESOURCES_SDK_INT);
881              parser = assets.openXmlResourceParser(cookie, ANDROID_MANIFEST_FILENAME);
882  
883              final String[] outError = new String[1];
  								//去正式解析
884              final Package pkg = parseBaseApk(res, parser, flags, outError);
885         ...
903      }
904  
~~~

初始化了xml解析器，然后调用了parseBaseApk的重载方法：

~~~java
335      /**
1336       * Parse the manifest of a <em>base APK</em>.
1337       * <p>
1338       * When adding new features, carefully consider if they should also be
1339       * supported by split APKs.
1340       */
1341      private Package parseBaseApk(Resources res, XmlResourceParser parser, int flags,
1342              String[] outError) throws XmlPullParserException, IOException {	
  					//解析Application标签
1438              if (tagName.equals("application")) {
1439                ...
  										//解析四大组件
1452                  if (!parseBaseApplication(pkg, res, parser, attrs, flags, outError)) {
1453                      return null;
1454                  }
									}
  							//权限相关的
1484              } else if (tagName.equals("permission-group")) {
1485                  if (parsePermissionGroup(pkg, flags, res, parser, attrs, outError) == null) {
1486                      return null;
1487                  }
1488              } else if (tagName.equals("permission")) {
1489                  if (parsePermission(pkg, res, parser, attrs, outError) == null) {
1490                      return null;
1491                  }
1492              } else if (tagName.equals("permission-tree")) {
1493                  if (parsePermissionTree(pkg, res, parser, attrs, outError) == null) {
1494                      return null;
1495                  }
1496              } else if (tagName.equals("uses-permission")) {
1497                  if (!parseUsesPermission(pkg, res, parser, attrs, outError)) {
1498                      return null;
1499                  }
1500              } else if (tagName.equals("uses-configuration")) {...}
							...
					}
~~~

解析application标签的item，这里我们只看四大组件。parseBaseApplication：

~~~java
2399      /**
2400       * Parse the {@code application} XML tree at the current parse location in a
2401       * <em>base APK</em> manifest.
2402       * <p>
2403       * When adding new features, carefully consider if they should also be
2404       * supported by split APKs.
2405       */
2406      private boolean parseBaseApplication(Package owner, Resources res,
2407              XmlPullParser parser, AttributeSet attrs, int flags, String[] outError)
2408          throws XmlPullParserException, IOException {
  						 while ((type = parser.next()) != XmlPullParser.END_DOCUMENT
2641                  && (type != XmlPullParser.END_TAG || parser.getDepth() > innerDepth)) {
2642              if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
2643                  continue;
2644              }
2645  
2646              String tagName = parser.getName();
                 //就是解析Activity
2647              if (tagName.equals("activity")) {
2648                  Activity a = parseActivity(owner, res, parser, attrs, flags, outError, false,
2649                          owner.baseHardwareAccelerated);
2650                  if (a == null) {
2651                      mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
2652                      return false;
2653                  }
2654  
2655                  owner.activities.add(a);
2656  						//可以看到解析receiver是和Activity用同一个方法
2657              } else if (tagName.equals("receiver")) {
2658                  Activity a = parseActivity(owner, res, parser, attrs, flags, outError, true, false);
2659                  if (a == null) {
2660                      mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
2661                      return false;
2662                  }
2663  
2664                  owner.receivers.add(a);
2665  
2666              } else if (tagName.equals("service")) {
2667                  Service s = parseService(owner, res, parser, attrs, flags, outError);
2668                  if (s == null) {
2669                      mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
2670                      return false;
2671                  }
2672  
2673                  owner.services.add(s);
2674  
2675              } else if (tagName.equals("provider")) {
2676                  Provider p = parseProvider(owner, res, parser, attrs, flags, outError);
2677                  if (p == null) {
2678                      mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;
2679                      return false;
2680                  }
2681  
2682                  owner.providers.add(p);
2683  
2684              }
                 ...
					}
~~~

返回的是对应的四大组件类型，除了广播接收器是Activity。

~~~java
2952      private Activity parseActivity(Package owner, Resources res,
2953              XmlPullParser parser, AttributeSet attrs, int flags, String[] outError,
2954              boolean receiver, boolean hardwareAccelerated)
2955              throws XmlPullParserException, IOException {
     Activity a = new Activity(mParseActivityArgs, new ActivityInfo());
  ...
}
~~~

找到ActivityInfo，验证了上文的说法。接下来我们看看最终得到的Package包含了什么信息

~~~java
public final static class Package implements Parcelable {
    public String packageName;
    public String manifestPackageName;
    public String[] splitNames;
    public String volumeUuid;
    public String codePath;
    public String baseCodePath;
    ...
    public ApplicationInfo applicationInfo = new ApplicationInfo();
    public final ArrayList<Permission> permissions = new ArrayList<Permission>(0);
    public final ArrayList<PermissionGroup> permissionGroups = new ArrayList<PermissionGroup>(0);
    public final ArrayList<Activity> activities = new ArrayList<Activity>(0);//1
    public final ArrayList<Activity> receivers = new ArrayList<Activity>(0);
    public final ArrayList<Provider> providers = new ArrayList<Provider>(0);
    public final ArrayList<Service> services = new ArrayList<Service>(0);
    public final ArrayList<Instrumentation> instrumentation = new ArrayList<Instrumentation>(0);
...
}
~~~

这样一来，一个软件的所有信息就被系统的PMS知道啦！

## 小结

这里可看到安卓包是区分：

+ Single APK：安装文件为一个完整的APK，即base APK。Android称其为Monolithic。

+ Mutiple APK：安装文件在一个文件目录中，其内部有多个被拆分的APK，这些APK由一个 base APK和一个或多个split APK组成。Android称其为Cluster。

是先判断安装包类型，然后用对应的方法去解析。

对于Single APK 解析base apk

对于Mutiple会去统计拆分的apk数量，然后一个个解析。

拿到应用的Package后，又做了什么？让我们回到