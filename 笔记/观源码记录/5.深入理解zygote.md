[TOC]

# 5.深入理解zygote

先复习一遍安卓系统架构！！！！

![image](https://img-blog.csdn.net/20170902000611474?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hqMTU5NzUz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)



前面我们一直强调安卓存在两个世界：c/c++ 和java世界，在前面的笔记中都是在c/c++世界，但是对于安卓应用开发者来说前面的东西不是那么的亲切，相信你与我一样，迫不及待的想进入安卓中java的世界了！别急，我们先思考几个问题：

+ 一个程序就是一个进程，但是在安卓软件开发中，我们很少接触到进程这个概念，我们根本不需要写什么main函数。也找不到创建进程的地方，那安卓系统是怎样去给各个应用分配进程的？
+ 我们平时经常会使用到系统提供的service，比如ActivityManager。在以前学习binder的时候就知道我们程序的进程需要通过binder实现AIDL技术进而与ActivityManager通信，但是这些个系统服务进程是什么时候启动的？
+ app又是怎么启动的？



我们先重温一遍init.rc里面关于zygote的定义。

~~~java
//后面的参数会传到main方法中
service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote
    class main
    socket zygote stream 660 root system
    onrestart write /sys/android_power/request_state wake
    onrestart write /sys/power/state on
    onrestart restart audioserver
    onrestart restart cameraserver
    onrestart restart media
    onrestart restart netd
    writepid /dev/cpuset/foreground/tasks

~~~

根据cpu的不同加载的rc文件也是不一样的，看到上面的代码估计你也能猜出来另外三个zygote*.rc是怎样的，具体选择哪个文件和编译时定义的ro.zygote值有关。

~~~jav
import /init.${ro.zygote}.rc
~~~



关键字service告诉init进程创建一个名为"zygote"的进程，这个zygote进程要执行的程序是/system/bin/app_process64，后面是要传给app_process64的参数。

   接下来的"class main"表示执行system/bin/app_process64后调用main方法，socket关键字表示这个zygote进程需要一个名称为"zygote"的socket资源，这样，系统启动后，我们就可以在/dev/socket目录下看到有一个名为zygote的文件，onrestart关键字表示这个zygote进程重启时需要执行的命令，最后一个writepid关键字表示需要重写系统pid。

通过上面我们知道Zygote进程要执行的程序便是app_process64了，它位于frameworks/base/cmds/app_process/app_main.cpp文件中，入口函数是main。（app_process64 or app_process32 都是通过frameworks/base/cmds/app_process编译出来的，只是由编译环境来决定生成那个文件）

接下来我们就要看看这个进程是如何启动安卓系统的！！

# zygote的初始化



看看zygote进程对应的源文件：app_main.cpp的代码

~~~java
//app_main.cpp
//这两个参数就是传进来的参数
int main(int argc, char* const argv[])
{
    .......
    while (i < argc) {
        const char* arg = argv[i++];
         //在init.rc里配置了前面的这些参数，而Zygote进程启动的时候，
            //Init进程会传过来--zygote，所以此处把变量zygote
            //设置为true代表启动zygote
        if (strcmp(arg, "--zygote") == 0) {
            zygote = true;
            //这里就是换名字
            niceName = ZYGOTE_NICE_NAME;
            //ZYGOTE_NICE_NAME字符串内容就是“Zygote”，此处已被换名字
        } else if (strcmp(arg, "--start-system-server") == 0) {
            startSystemServer = true;
            //在init.rc里配置了前面的这些参数，而Zygote进程启动的时候，
            //Init进程会传过来这些参数，所以此处把变量startSystemServer
            //设置为true代表启动SystemServer
        } else if (strcmp(arg, "--application") == 0) 
        .......
    }
    ......

    if (zygote) {
        runtime.start("com.android.internal.os.ZygoteInit", args, zygote);
        //zygote为true代表的是Zygote进程，也就是说现在正在启动的是Zygote进程，
        //我们知道Zygote进程用于孵化子进程，Zygote进程孵化子进程是通过自己的资源赋值一份，
        //来fork一个新的子进程，也就是说子进程也会进入这个文件的main函数，因此，
        //这里的main函数被调用并不只是Zygote启动的时候被调用。这里通过zygote这个变量来区分，
        //如果是Zygote进程本身，就会进入到if里，否则就会进入到下面的else if里，代表子进程启动。
    } else if (className) {
        //关于这里，我认为是用来调试程序的，后面会讲
        runtime.start("com.android.internal.os.RuntimeInit", args, zygote);
    } else {
        .......
    }
}

~~~

可以看到调用了runtime.start()这个方法，这里就要讲讲这个runtime了，他可厉害了！他在app_main.cpp里面被声明为一个内部类

~~~java
//app_main.cpp
class AppRuntime : public AndroidRuntime
{
    //复写了几个方法，可以暂时不管

    virtual void onVmCreated(JNIEnv* env)
    {
       ...
    }

    virtual void onStarted()
    {
       ...
    }

    virtual void onZygoteInit()
    {
       ...
    }

    virtual void onExit(int code)
    {
      ...
    }


    String8 mClassName;
    Vector<String8> mArgs;
    jclass mClass;
};

}
~~~

可以看到他叫appRuntime，他的父类叫androidRuntime，他的作用就体现在名字上了！！！还记得安卓的架构图吗？AppRuntime层就是讲这两个东西，AndroidRuntime是负责跑起安卓系统服务的进程，appRuntime是负责跑应用程序的进程，但是你会疑惑，前面在app_process的main方法里面调用的是start方法，但是appRuntime类里面没有这个方法，你看，现在是属于启动安卓系统的过程，当然是AndroidRuntime负责的啊，我们看androidRuntime的代码，

~~~java
//AndroidRuntime.cpp
void AndroidRuntime::start(const char* className, const Vector<String8>& options, bool zygote)
{
...

    /* start the virtual machine */
    //启动java虚拟机
    JniInvocation jni_invocation;
    jni_invocation.Init(NULL);
    JNIEnv* env;
    if (startVm(&mJavaVM, &env, zygote) != 0) {
        return;
    }
    onVmCreated(env);

   
    //注册JNI函数，这样c++才能调用java的代码。java才能调用c++的代码
    if (startReg(env) < 0) {
        ALOGE("Unable to register all android natives\n");
        return;
    }

    /*
     * We want to call main() with a String array with arguments in it.
     * At present we have two arguments, the class name and an option string.
     * Create an array to hold them.用jni技术创键数组和字符串来保存java的函数名字
     */
    jclass stringClass;
    jobjectArray strArray;
    jstring classNameStr;

    stringClass = env->FindClass("java/lang/String");
    assert(stringClass != NULL);
    //设置第一个参数为frameworks/base/core/java/com/android/internal/os/ZygoteInit.java
    strArray = env->NewObjectArray(options.size() + 1, stringClass, NULL);
    assert(strArray != NULL);
    classNameStr = env->NewStringUTF(className);
    assert(classNameStr != NULL);
    env->SetObjectArrayElement(strArray, 0, classNameStr);

    for (size_t i = 0; i < options.size(); ++i) {
        jstring optionsStr = env->NewStringUTF(options.itemAt(i).string());
        assert(optionsStr != NULL);
        env->SetObjectArrayElement(strArray, i + 1, optionsStr);
    }

    /*
     * Start VM.  This thread becomes the main thread of the VM, and will
     * not return until the VM exits.就是去开启javaVm，
     */
    char* slashClassName = toSlashClassName(className);
    jclass startClass = env->FindClass(slashClassName);
    if (startClass == NULL) {
        ALOGE("JavaVM unable to locate class '%s'\n", slashClassName);
        /* keep going */
    } else {
        jmethodID startMeth = env->GetStaticMethodID(startClass, "main",
            "([Ljava/lang/String;)V");
        if (startMeth == NULL) {
            ALOGE("JavaVM unable to find main() in '%s'\n", className);
            /* keep going */
        } else {
            //通过函数名字去调用java的代码
            env->CallStaticVoidMethod(startClass, startMeth, strArray);

...
}
~~~

AndroidRuntime是先开启javaVM，然后注册jni，这里就很有意思了！！想象一下！现在zygote进程就像盘古一样，在c++中开辟出java的世界！！！然后通过jni技术，去调用'frameworks/base/core/java/com/android/internal/os/ZygoteInit.java'的main函数！！！zygote进程正式进入java世界！关于jni函数注册我就不写了，感兴趣自己查一下！！！！我们看看ZygoteInit.java的main函数干了些什么

~~~java
   public static void main(String argv[]) {
       		//给当前zygote进程创建一个socket，zygote实现进程通信的方法是socket，他创建的是一个服务端的socket，后面会讲为什么要创建这个服务端的socket
            registerZygoteSocket(socketName);
           ...
               
            //为刚刚创建的java世界，搞几个山头，种点树木，搞几个动物，其实就是加载很多的常用类，就算现在不加载，等下也会加载的！！！这里涉及到一个很好玩的知识点，等下讲
            preload();
      ...

          //去启动SystemServer！！！
            if (startSystemServer) {
                startSystemServer(abiList, socketName);
            }

            //进入一个无限循环，等等socket事件的发生
            runSelectLoop(abiList);

       		//循环退出就关闭socket
            closeServerSocket();
        } catch (MethodAndArgsCaller caller) {
       		//这是一个非常重要的东西，后面会讲到，现在不理
            caller.run();
        } catch (Throwable ex) {
            Log.e(TAG, "Zygote died with exception", ex);
            closeServerSocket();
            throw ex;
        }
    }
~~~

+ 可以看到进入java世界的第一件事情就是建立一个服务端的socket，
+ 但是刚刚创建出来的java世界什么都没有，当然要预加载一些常用的类，增添一些色彩啦！！！
+ 然后去启动systemService！！！这个非常重要！！他就是framework层的代表！！framework层里面的东西都归他管，比如ActivityManagerService！！！
+ 然后zygote就进入一个无限循环等待事件的发生了
+ 但是他还等待着一个叫MethodAndArgsCaller异常的发生，这是为什么呢？后面会讲的

zygote进程使用AndroidRuntime去创建了java世界，并且为java世界做了一些建设，但是他觉得自己太累了！！就创建了个systemService来去打理java世界，然后自己就陷入沉睡了！但是他留了一个socket！！后代子孙可以通过这个socket来把zygote唤醒！！！像不像盘古开天辟地？像吧！！！！

所以说systemService可是java世界最重要的东西,他可是java世界的管理人啊！！看看zygote是如何创建这个systemService的！

~~~java
//frameworks/base/core/java/com/android/internal/os/ZygoteInit.java    
/**
     * Prepare the arguments and fork for the system server process.
     */
    private static boolean startSystemServer(String abiList, String socketName)
            throws MethodAndArgsCaller, RuntimeException {
       ...

        int pid;

        try {
            //可以看到很熟悉的代码！！还是去调用fork函数去复制进程！！
            /* Request to fork the system server process */
            pid = Zygote.forkSystemServer(
                    parsedArgs.uid, parsedArgs.gid,
                    parsedArgs.gids,
                    parsedArgs.debugFlags,
                    null,
                    parsedArgs.permittedCapabilities,
                    parsedArgs.effectiveCapabilities);
        } catch (IllegalArgumentException ex) {
            throw new RuntimeException(ex);
        }

        /* For child process 然后在子进程做了一些处理*/
        if (pid == 0) {
            if (hasSecondZygote(abiList)) {
                waitForSecondaryZygote(socketName);
            }

            handleSystemServerProcess(parsedArgs);
        }

        return true;
    }
~~~

原来systemService是zygote的子进程呀！所以说zygote进程在创建了systemService进程后就去睡觉了，剩下的事情都给systemService去做了！那我们看看他做了什么东西

~~~java
//frameworks/base/core/java/com/android/internal/os/ZygoteInit.java   

/**
     * Finish remaining work for the newly forked system server process.
     */
    private static void handleSystemServerProcess(
            ZygoteConnection.Arguments parsedArgs)
            throws ZygoteInit.MethodAndArgsCaller {

        //一开始就关了socket，为什么呢？因为zygote创建了socket来让后代子孙唤醒他，fork出来的systemService也有这个socket，但是systemService不需要这个，就关了呗！
        closeServerSocket();

            /*
             * Pass the remaining arguments to SystemServer.
             */
            RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);
        }

        /* should never reach here */
    }
~~~

他去调用了RuntimeInit类的zygoteInit方法，这个类也是非常的重要，我们看看这个方法干了什么

~~~java
//frameworks/base/core/java/com/android/internal/os/RuntimeInit.java
public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)
            throws ZygoteInit.MethodAndArgsCaller {
        if (DEBUG) Slog.d(TAG, "RuntimeInit: Starting application from zygote");

      ...
         //启动Binder线程池
        nativeZygoteInit();
    	//systemService的main方法
        applicationInit(targetSdkVersion, argv, classLoader);
    }
~~~

他进行了两个很重要的操作，第一个是启动binder线程池，然后去启动systemService的main方法，为什么要启动这个binder呢？在安卓的java进程通信用的是Binder机制！！不是socket！比如你的程序想和ActivityManagerService通信，就要使用基于BInder实现的AIDL技术！这个你肯定知道吧？而binder实现是c++实现的，所以这里java代码其实是通过jni技术去启动binder线程池，对应jni的c++的方法是

~~~java
//AndroidRuntime.cpp

static AndroidRuntime* gCurRuntime = NULL;

AndroidRuntime::AndroidRuntime(char* argBlockStart, const size_t argBlockLength) :
        mExitWithoutCleanup(false),
        mArgBlockStart(argBlockStart),
        mArgBlockLength(argBlockLength)
{
 ...
    gCurRuntime = this;
}


static void com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz)
{
    gCurRuntime->onZygoteInit();
}
~~~

gCurRuntime是AndroidRuntime对象，他调用了onZygoteInit()方法！但是！！！他真正去调用的不是AndroidRuntime类的onZygoteInit()方法，我们知道面向对象的语言都有多态这个说法，而且在c++里面当子类复写了父类的某个方法！并且加上了virtual修饰后，假设这个对象是子类，但是被向上转型了，调用的还是子类的方法，我们看看AndroidRuntime的子类AppRuntime有没有复写！（前面已经说过了，有的）

~~~java
//app_main.cpp
class AppRuntime : public AndroidRuntime
{
public:
    AppRuntime(char* argBlockStart, const size_t argBlockLength)
        : AndroidRuntime(argBlockStart, argBlockLength)
        , mClass(NULL)
    {
    }

    void setClassNameAndArgs(const String8& className, int argc, char * const *argv) {
        mClassName = className;
        for (int i = 0; i < argc; ++i) {
             mArgs.add(String8(argv[i]));
        }
    }

    virtual void onVmCreated(JNIEnv* env)
    {
        if (mClassName.isEmpty()) {
            return; // Zygote. Nothing to do here.
        }
        
        mClass = reinterpret_cast<jclass>(env->NewGlobalRef(mClass));
    }

    virtual void onStarted()
    {
        sp<ProcessState> proc = ProcessState::self();
        ALOGV("App process: starting thread pool.\n");
        proc->startThreadPool();

        AndroidRuntime* ar = AndroidRuntime::getRuntime();
        ar->callMain(mClassName, mClass, mArgs);

        IPCThreadState::self()->stopProcess();
    }

    virtual void onZygoteInit()
    {
        sp<ProcessState> proc = ProcessState::self();
        ALOGV("App process: starting thread pool.\n");
        proc->startThreadPool();
    }

    virtual void onExit(int code)
    {
        if (mClassName.isEmpty()) {
            // if zygote
            IPCThreadState::self()->stopProcess();
        }

        AndroidRuntime::onExit(code);
    }


    String8 mClassName;
    Vector<String8> mArgs;
    jclass mClass;
};
~~~

他复习了几个方法，其中就有onZygoteInit()方法，现在要确认的就是gCurRuntime是AppRuntime对象还是AndroidRuntime对象！那就要回到最初的起点：app_main.cpp

~~~java
//app_main.cpp
int main(int argc, char* const argv[])
{
    ...
    AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv));
    ...
}
~~~

可以看到，他是AppRuntime！！所以执行的下面这个代码

~~~java
  virtual void onZygoteInit()
    {
        sp<ProcessState> proc = ProcessState::self();
        ALOGV("App process: starting thread pool.\n");
      	//这个函数就是用来启动binder线程池的，具体的启动过程，以后再学习！！
        proc->startThreadPool();
    }
~~~

这里小结一下！我们知道其实真正的runtime实现居然是AppRuntime！！这里很有意思的，一开始我们就说了AndroidRuntime是负责安卓系统进程的启动，而AppRuntime是负责应用进程的启动！他使用了继承和多态的思想去实现功能划分，对象复用的操作，牛逼吧！！！废话不多说，我们回到systemService的部分，给systemService启动了binder线程后，就开始进入systemService类的main方法了。我们看看代码

~~~java
//media/ba/sd/aosp/frameworks/base/core/java/com/android/internal/os/RuntimeInit.java    
private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)
            throws ZygoteInit.MethodAndArgsCaller {
     ...

        // Remaining arguments are passed to the start class's static main
        invokeStaticMain(args.startClass, args.startArgs, classLoader);
    }
...

   
    private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader)
            throws ZygoteInit.MethodAndArgsCaller {
        Class<?> cl;

        try {
            //通过反射获取到systemService的java类
            cl = Class.forName(className, true, classLoader);
        } catch (ClassNotFoundException ex) {
            throw new RuntimeException(
                    "Missing class when invoking static main " + className,
                    ex);
        }

        Method m;
        try {
            //获取systemService的main方法
            m = cl.getMethod("main", new Class[] { String[].class });
        }
    ...

      //嗯？反射得到systemService的类后居然直接抛出异常了？？
        throw new ZygoteInit.MethodAndArgsCaller(m, argv);
    }
~~~

来了来了，终于到了最骚的地方！！！

























