[TOC]

# 5.深入理解zygote

前面我们一直强调安卓存在两个世界：c/c++ 和java世界，在前面的笔记中都是在c/c++世界，但是对于安卓应用开发者来说前面的东西不是那么的亲切，相信你与我一样，迫不及待的想进入安卓中java的世界了！别急，我们先思考几个问题：

+ 一个程序就是一个进程，但是在安卓软件开发中，我们很少接触到进程这个概念，我们根本不需要写什么main函数。也找不到创建进程的地方，那安卓系统是怎样去给各个应用分配进程的？
+ 我们平时经常会使用到系统提供的service，比如ActivityManager。在以前学习binder的时候就知道我们程序的进程需要通过binder实现AIDL技术进而与ActivityManager通信，但是这些个系统服务进程是什么时候启动的？
+ app又是怎么启动的？



我们先重温一遍init.rc里面关于zygote的定义。

~~~java
//后面的参数会传到main方法中
service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote
    class main
    socket zygote stream 660 root system
    onrestart write /sys/android_power/request_state wake
    onrestart write /sys/power/state on
    onrestart restart audioserver
    onrestart restart cameraserver
    onrestart restart media
    onrestart restart netd
    writepid /dev/cpuset/foreground/tasks

~~~

根据cpu的不同加载的rc文件也是不一样的，看到上面的代码估计你也能猜出来另外三个zygote*.rc是怎样的，具体选择哪个文件和编译时定义的ro.zygote值有关。

~~~jav
import /init.${ro.zygote}.rc
~~~



关键字service告诉init进程创建一个名为"zygote"的进程，这个zygote进程要执行的程序是/system/bin/app_process64，后面是要传给app_process64的参数。

   接下来的"class main"表示执行system/bin/app_process64后调用main方法，socket关键字表示这个zygote进程需要一个名称为"zygote"的socket资源，这样，系统启动后，我们就可以在/dev/socket目录下看到有一个名为zygote的文件，onrestart关键字表示这个zygote进程重启时需要执行的命令，最后一个writepid关键字表示需要重写系统pid。

通过上面我们知道Zygote进程要执行的程序便是app_process64了，它位于frameworks/base/cmds/app_process/app_main.cpp文件中，入口函数是main。（app_process64 or app_process32 都是通过frameworks/base/cmds/app_process编译出来的，只是由编译环境来决定生成那个文件）

# zygote的初始化



看看zygote进程对应的源文件：app_main

~~~java
//app_main.cpp
//这两个参数就是传进来的参数
int main(int argc, char* const argv[])
{
    .......
    while (i < argc) {
        const char* arg = argv[i++];
         //在init.rc里配置了前面的这些参数，而Zygote进程启动的时候，
            //Init进程会传过来--zygote，所以此处把变量zygote
            //设置为true代表启动zygote
        if (strcmp(arg, "--zygote") == 0) {
            zygote = true;
            //这里就是换名字
            niceName = ZYGOTE_NICE_NAME;
            //ZYGOTE_NICE_NAME字符串内容就是“Zygote”，此处已被换名字
        } else if (strcmp(arg, "--start-system-server") == 0) {
            startSystemServer = true;
            //在init.rc里配置了前面的这些参数，而Zygote进程启动的时候，
            //Init进程会传过来这些参数，所以此处把变量startSystemServer
            //设置为true代表启动SystemServer
        } else if (strcmp(arg, "--application") == 0) 
        .......
    }
    ......

    if (zygote) {
        runtime.start("com.android.internal.os.ZygoteInit", args, zygote);
        //zygote为true代表的是Zygote进程，也就是说现在正在启动的是Zygote进程，
        //我们知道Zygote进程用于孵化子进程，Zygote进程孵化子进程是通过自己的资源赋值一份，
        //来fork一个新的子进程，也就是说子进程也会进入这个文件的main函数，因此，
        //这里的main函数被调用并不只是Zygote启动的时候被调用。这里通过zygote这个变量来区分，
        //如果是Zygote进程本身，就会进入到if里，否则就会进入到下面的else if里，代表子进程启动。
    } else if (className) {
        //关于这里，我认为是用来调试程序的，后面会讲
        runtime.start("com.android.internal.os.RuntimeInit", args, zygote);
    } else {
        .......
    }
}

~~~

可以看到调用了runtime.start()这个方法，这里就要讲讲这个runtime了，他可厉害了！他被声明为一个内部类

~~~java
//app_main.cpp
class AppRuntime : public AndroidRuntime
{
    //复写了几个方法，可以暂时不管

    virtual void onVmCreated(JNIEnv* env)
    {
       ...
    }

    virtual void onStarted()
    {
       ...
    }

    virtual void onZygoteInit()
    {
       ...
    }

    virtual void onExit(int code)
    {
      ...
    }


    String8 mClassName;
    Vector<String8> mArgs;
    jclass mClass;
};

}
~~~

可以看到他叫appRuntime，他的父类叫androidRuntime，他的作用就体现在名字上了！！！还记得安卓的架构图吗？AppRuntime层就是讲这两个东西，AndroidRuntime是负责跑起安卓系统服务的进程，appRuntime是负责跑应用程序的进程，但是你会疑惑，前面在app_process的main方法里面调用的是start方法，但是appRuntime类里面没有这个方法，你看，现在是属于启动安卓系统的过程，当然是AndroidRuntime负责的啊，我们看androidRuntime的代码，

~~~java
//AndroidRuntime.cpp
void AndroidRuntime::start(const char* className, const Vector<String8>& options, bool zygote)
{
...

    /* start the virtual machine */
    //启动java虚拟机
    JniInvocation jni_invocation;
    jni_invocation.Init(NULL);
    JNIEnv* env;
    if (startVm(&mJavaVM, &env, zygote) != 0) {
        return;
    }
    onVmCreated(env);

   
    //注册JNI函数，这样c++才能调用java的代码。java才能调用c++的代码
    if (startReg(env) < 0) {
        ALOGE("Unable to register all android natives\n");
        return;
    }

    /*
     * We want to call main() with a String array with arguments in it.
     * At present we have two arguments, the class name and an option string.
     * Create an array to hold them.用jni技术创键数组和字符串来保存java的函数名字
     */
    jclass stringClass;
    jobjectArray strArray;
    jstring classNameStr;

    stringClass = env->FindClass("java/lang/String");
    assert(stringClass != NULL);
    //设置第一个参数为frameworks/base/core/java/com/android/internal/os/ZygoteInit.java
    strArray = env->NewObjectArray(options.size() + 1, stringClass, NULL);
    assert(strArray != NULL);
    classNameStr = env->NewStringUTF(className);
    assert(classNameStr != NULL);
    env->SetObjectArrayElement(strArray, 0, classNameStr);

    for (size_t i = 0; i < options.size(); ++i) {
        jstring optionsStr = env->NewStringUTF(options.itemAt(i).string());
        assert(optionsStr != NULL);
        env->SetObjectArrayElement(strArray, i + 1, optionsStr);
    }

    /*
     * Start VM.  This thread becomes the main thread of the VM, and will
     * not return until the VM exits.就是去开启javaVm，
     */
    char* slashClassName = toSlashClassName(className);
    jclass startClass = env->FindClass(slashClassName);
    if (startClass == NULL) {
        ALOGE("JavaVM unable to locate class '%s'\n", slashClassName);
        /* keep going */
    } else {
        jmethodID startMeth = env->GetStaticMethodID(startClass, "main",
            "([Ljava/lang/String;)V");
        if (startMeth == NULL) {
            ALOGE("JavaVM unable to find main() in '%s'\n", className);
            /* keep going */
        } else {
            //通过函数名字去调用java的代码
            env->CallStaticVoidMethod(startClass, startMeth, strArray);

...
}
~~~

AndroidRuntime是先开启javaVM，然后注册jni，这里就很有意思了！！想象一下！现在zygote进程就像盘古一样，在c++中开辟出java的世界！！！然后通过jni技术，去调用'frameworks/base/core/java/com/android/internal/os/ZygoteInit.java'的main函数！！！正式进入java世界！！！我们看看这个ZygoteInit.java的main函数干了些什么

~~~java
   public static void main(String argv[]) {
       		//给当前zygote进程创建一个socket，zygote实现进程通信的方法是socket，他创建的是一个服务端的socket，后面会讲为什么要创建这个服务端的socket
            registerZygoteSocket(socketName);
           ...
               
            //为刚刚chujava
            preload();
      ...

          //去启动SystemServer！！！
            if (startSystemServer) {
                startSystemServer(abiList, socketName);
            }

            //进入一个无限循环，等等事件的发生
            runSelectLoop(abiList);

       		//循环退出就关闭socket
            closeServerSocket();
        } catch (MethodAndArgsCaller caller) {
       		//这是一个非常重要的东西，后面会讲到，现在不理
            caller.run();
        } catch (Throwable ex) {
            Log.e(TAG, "Zygote died with exception", ex);
            closeServerSocket();
            throw ex;
        }
    }
~~~









































