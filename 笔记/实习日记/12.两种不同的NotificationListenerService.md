# 12.两种不同的NotificationListenerService

NotificationManagerService会把通知分给向他注册的INotificationListener

## 注册的两种方案：

### 方案A

+ 新建一个继承自NotificationListenerService的service。
+ 该service在onBinder方法里面返回给NotificationManagerListener的是INotificationListener的实现类NotificationListenerWrapper（INotificationListener和NotificationListenerWrapper都是hide的）
+ NotificationListenerWrapper里面定义了给我们Serivce回调的接口
+ 所以我们需要实现NotificationListenerWrapper定义好给我们service回调的接口
+ 当NotificationManangerService收到app发送的通知后会发布到所有注册的INotificationListener，
+ 所以我们刚刚注册的NotificationListenerWrapper也会收到这些通知，NotificationListenerWrapper会调用我们Service的回调方法，我们就可以从这些方法中拿到通知了。
+ 我们需要在AndroidManifest.xml文件注册该服务并且声明监听通知的权限，该服务不需要我们手动启动，因为当我们给了某个应用权限后，会在Setting的数据库里面保存该服务的信息，NotificationManagerService会从Setting的内容提供器中拿到这些服务，然后启动这些服务，然后通过服务的onBinder方法拿到该服务的INotificationListener。进行注册

#### 方案A小结

也就是说android提供了一种简便的方法让我们去监听通知，但是该方法有局限性：

+ 必须要依赖于service，假设我们需要在Activity进行通知的展示，我们就要处理Service和Activity的绑定，而onBinder里面返回的Binder实例已经被NotificationListenerService定义好了，我们如果自己定义一个Binder是不能继承NotificationListenerWrapper的，因为NotificationListenerWrapper是hide的（当然系统应用可以不考虑这个问题），也就是说和Activity或者其他组件进行交互也变得麻烦了。并且当有多个不同的Activity或者其他的Class希望取得这个通知的时候都是需要向这个通知获取，处理起来就很麻烦

## 我的想法

我需要的是能非常简单的让任何一个Class都具备监听通知的能力，那么也就摆脱了对Service依赖的烦恼

### 方案B

由方案A可以知道，想监听通知，其实就是向NotificationManagerSerivce注册一个INotificationListener。

所以我可以写一个本地的NotificationCenter，这是一个观察者模式，由他定义这个INotificationListener，当NotificationManagerSevice有消息来的时候，会调用到这个NotificationCenter的INotificationListener定义的回调方法，我们就可以在里面对所有的观察者进行发布通知，所以需要监听系统中的通知只实现我定义好的观察者接口并且向NotificationCenter注册就好了。

我的NotificationCenter是单例，这样就不会导致向NotificationManagerService注册多次了。

那么一来任何一个Class类想要监听通知服务就变得简单了！

## 方案B小结

其实两种方法的原理都是向NotificationManangerService注册一个INotificationListener，方案B的INotificationListener是我们自己定义的，但是这个INotificationListener是hide的，如果要使用方案B就要解决这个hide的问题。

# 拓展思考

## 另一种程序保活途径

我们以前想要给我们的程序做保活，有几种常见的方法：

+ 前台服务：这是最常用也是最官方的方式
+ 进程守护：是有前提的，是当我们的app是被动杀的，而不是用户主动点击清除后台。用户一旦主动清除后台那么就会把两个进程都给干掉
+ 监听广播：也是有前提的，当我们重启时必须要打开过程序一次后才能有效，而且会被一些系统检测为耗电应用。
+ 接入第三方推送服务：很多app都接入了一些推送服务，推送服务为了能保证app及时的收到推送，会通过正在运行的当前接入他们服务的app去唤醒其他也接入了他们推送服务的app，为了保证平台覆盖率，你还可以同时接入多个推送服务，推送服务一般都是使用另一个进程去运行的，而且该进程所占资源并不会很大

## 让APP变成NotificationListenerService

当我们的程序有NotificationListenerService，并且拥有通知权限，那么当程序被杀死，NotificationManagerService会reBinder这个服务，那么这个服务就会被重新启动了！！！！假设我们的应用是系统应用，那么根本就不需要在乎这个通知权限了，系统应用是不需要动态申请权限的。

## 我的通知列表是否会受到DOS攻击？

有没有可能会有某个恶意软件不断的发通知，导致我的NotificationCenter不断的收到这些垃圾通知？不会的，在前面的日志中有讲过NotificationManagerService会对非系统应用或者非NotificationListenerService发出的通知进行发送频率和数量的限制。

但是有意思的是源码中是怎么去判断当前通知是否是NotificationListenerService发出的呢？

我们向NotificationManagerService注册NotificationListenerService的时候他是会把应用包名和NotificationListenerService一起存在一个info里面。

当我们Notification想要入队的时候，他是怎么判断该Notification是否是一个NotificationListenerService发出来的呢？是的，根据程序包名，Notification会带有发出程序的包名，NotificationManagerService就是根据这个包名去info类取，如果取出不为null，那么就认为这个Notification是NotificationListenerService发出的！！

所以按照我们在方案A分析的来看，如果我们程序如果有的NotificationListenerService，那么我们的程序进行大量的通知发送，那是不是就符合了是NotificationListenerService进行发送通知？那么其他的开发者是否就可以利用这个进行高频大量通知的发送呢？是的！可以,这是安卓设计的一个缺陷，



