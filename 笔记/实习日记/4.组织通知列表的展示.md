# 4.组织通知列表的展示

我在服务内启动我定义的MaxhubNotificationUI，并且在里面使用mWindowManager，添加了一个悬浮窗，所以我们需要考虑service的生命周期，最重要的就是这个知识点：在整个生命周期内，只有**startCommand()**能被多次调用。其他方法只能被调用**一次**。（即只能绑定和解绑一次。）。所以我们需要注意的就是：不要在startCommand中进行我们Bar的初始化和启动！

 # 展示通知需要考虑的问题

+ 通知列表和我们平时的列表不同，我希望的是当有新通知来的时候通知是从头部加入，并且其他通知向下退
+ 当应用发送不带有remoteView的通知时，我希望展示默认的通知样式，当用户设置了remoteView的时候，我希望能显示用户的remoteView，并且该remoteView能够实时更新
+ 当同一个应用不断发送通知时，如何进行排重处理？
+ 清除所有通知的功能。
+ 单独清除功能？
+ 点击通知后是否需要取消显示通知？

# 在使用RecyclerView自带的动画时遇到的问题

因为我想插入通知时能有动画，所以我使用了recyclerview自带的插入动画，但是我平时做添加recycler的头部或者尾部时，会在recycler的getItemCount方法返回假的数据长度，而正是因为这个假的数据长度导致插入动画出现超出数组长度的问题！并且在大量加入通知的情况下，也是会发生这个问题

# 解决方法

我换了一种实现方案，使用帧布局，把占位view放到列表的底部，当没有通知的时候隐藏列表，这样占位view就显示出来了。并且不使用默认动画。

# 测试使用PendingIntent的时候学到的知识

在Android中，我们常常使用PendingIntent来表达一种“留待日后处理”的意思。从这个角度来说，PendingIntent可以被理解为一种特殊的异步处理机制。不过，单就命名而言，PendingIntent其实具有一定误导性，因为它既不继承于Intent，也不包含Intent，它的核心可以粗略地汇总成四个字——“异步激发”。
很明显，这种异步激发常常是要跨进程执行的。比如说A进程作为发起端，它可以从系统“获取”一个PendingIntent，然后A进程可以将PendingIntent对象通过binder机制“传递”给B进程，再由B进程在未来某个合适时机，“回调”PendingIntent对象的send()动作，完成激发。感觉挺有意思的，有空再深入学习！



