# 代码重构

## 一切的开始

INotificationListener接口定义了很多回调方法，NotificationManangerService会从该接口返回app发出的通知，所以我需要实现该接口并且向NotificationManagerService进行注册，

我设计了一个LocalNotificaitonManager来专门负责向NotificationManangerService进行注册操作；

但是由于该接口从NotificationManangerService回调回来后是异步的，而且数据类型不是我想要的类型

所以设计了一个抽象类：BaseBar，在里面实现INotificationListener的接口，专职负责从该接口的回调方法中处理好数据类型，并且切换线程，我希望能直接拿到通知就能进行展示，而不用去处理线程问题，

所以我需要定义一个自己的通知回调接口：SimpleNotificationListener来让BaseBar的子类去实现，BaseBar会在主线程通过该接口定义的回调方法内返回给子类

我设计了个NotificationListUI类，接继承自BaseBar，实现SimpleNotificationListener的具体方法，就可以愉快的从该接口的回调拿到notification进行展示了！不需要担心数据类型，和线程切换的问题。

使用也很简单，只需要实例化我们的NotificationListUI然后传给LocalNotificaitonManager，让他去向NotificationManangerService注册就好了。

# 新的需求

需要加浮动通知，但是原来的NotificationListUI里面已经处理了很多逻辑了，而且这个浮动通知和这个NotificationListUI没有多大关联。并不会影响到彼此

所以我新写了个FloatNotificationUI。很舒服，都是直接继承BaseBar，实现SimpleNotificationListener的具体方法。

然后使用LocalNotificaitonManager就可以向NotificationManangerService进行注册了

但是问题也出现了，我的NotificationListUI已经注册过一次了，为什么我还要注册多一次？假设我再多加锁屏展示通知的UI是不是又要多注册一次？

# 修改结构

新的设计是，我增加了一个LocalNortificationCenter，由他专门负责实现INotificationListener接口，然后去向NotificationManangerService注册。这是一个观察者模式，LocalNortificationCenter会把从NotificationManangerService拿到的通知，处理好数据类型的转换后，分发给所有观察者

而我的BaseBar变成了观察者，唯一需要做的就是切换线程，然后在主线程回调给子类。

而两个子类：FloatNotificationUI和NotificationListUI就只需要向LocalNortificationCenter订阅通知就好了。

这样一来就保证了我的程序其实只需要向NotificationManangerService注册一次。而且扩展性也高，增加一个BaseBar的子类或者修改，都不会影响其他。

# RecyclerView局部刷新

## 遇到的问题1

局部刷新闪烁的问题，当我调用notifyItemChanged方法来单独刷新一个Item的时候，该Item会闪烁。

## 解决问题1

因为该方法是有默认动画的，所以我单独把该方法的动画关闭就不会闪烁了。

## 遇到的问题2

在以前我是直接使用notifyDataSetChange方法来直接刷新，所以我常写的逻辑就是

~~~java
 list.remove(position);
list.add(positon);
adapter.notifyDataSetChange();
~~~

这样使用不会出现数据不同步的问题，因为notifyDataSetChange去同步了数据源和adapter内部数据。

但是当我使用局部指定位置刷新的时候就会出现IndexOutOfBoundsException，list是外部数据集，对该外部数据集做了两个操作：先移除数据，然后添加数据，之后notify数据集。这里，添加数数据时（Adapter的内部数据集内容还处在外部数据集移除数据之前），造成了内部和外部数据集不一致。

## 解决问题2

在进行数据移除和数据增加时，务必要保证RecyclerView的Adapter中的数据集和移除／添加等操作后的数据集保持一致！就是及时的调用notifyXXXX就好了。



